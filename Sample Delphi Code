unit BatchGiftProcessingFrm;

interface                                

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, Dialogs,
  SmartInspect, siAuto, pidiSysUtils, pidiTypes, pidiOpCodes, RzErrHnd, ImgList, ActnList,
  pidiBaseFrm, pidiTabPageFrm, pidiTabSheetFrm, pidiPageControlInfo, pidiTabSheetInfo,
  EventSearchClientFrm, AccountSearchClientFrm, pidiCoreClientDM, GiftProcessingClientDM, 
  AccountClientDM, DonationClientDM, DonationCodesClientDM, AccountCodesClientDM,
  AcknowledgementCodesClientDM, EventClientDM, EventCodesClientDM, EFTInfoFrm, CCInfoFrm,
  PickPledgeClientFrm, PickVehicleFrm, AccountMinEditClientFrm, pidiAstaGlobal, IniFiles, RzBizCmp,
  pidCdsAccess, pidDataCtrls, sSkinProvider, DB, ExtCtrls, Menus, wwDialog, wwrcdvw, DBClient,
  wwclient, Wwdatsrc, PidDataSet, wwrcdpnl, Wwdbcomb, wwdbedit, RzCommon,
  wwdblook, Mask, Wwdotdot, Wwdbigrd, RzTabs, Grids, Wwdbgrid, RzPanel, RzSplit,
  wwSpeedButton, wwDBNavigator, wwclearpanel, RzStatus, wwdbdatetimepicker,
  StdCtrls, sEdit, HostEdit, fcCombo, fctreecombo, RzLabel, Buttons,
  sSpeedButton, acAlphaImageList, cxGraphics, cxControls,
  cxLookAndFeels, cxLookAndFeelPainters, cxSplitter, sLabel, sMaskEdit,
  sCustomComboEdit, sTooledit, sSpinEdit, cxStyles, cxCustomData, cxFilter,
  cxData, cxDataStorage, cxEdit, cxDBData, cxButtonEdit, cxDropDownEdit,
  cxGridLevel, cxGridCustomTableView, cxGridTableView, cxGridDBTableView,
  cxClasses, cxGridCustomView, pidiDevExpressCtrls, cxGrid, cxCheckBox,
  cxDBLookupComboBox, sCheckBox, cxTextEdit, cxLabel, cxEditRepositoryItems,
  cxDBEditRepository, cxCurrencyEdit, xmldom, XMLIntf, msxmldom, XMLDoc,
  XSLProd, SimpleDS;

type
  TfrmBatchGiftProcessing = class(TfrmPidiTabPage)
    sSkinProvider: TsSkinProvider;
    splMain: TcxSplitter;                                    
    puOptions: TPopupMenu;
    dsGiftProcessing: TpidDataSource;
    dsEventDonationType: TpidDataSource;
    dsEventDonationSubType: TpidDataSource;
    dsChapterCode: TpidDataSource;
    dsAcctCode: TpidDataSource;
    TabImoIho: TRzTabSheet;
    TabMatchingGift: TRzTabSheet;
    TabGiftMembership: TRzTabSheet;
    TabPremiums: TRzTabSheet;
    TabSoftCredit: TRzTabSheet;
    TabCreditCardInfo: TRzTabSheet;
    TabEftInfo: TRzTabSheet;
    TabSplitDonations: TRzTabSheet;
    TabIROrders: TRzTabSheet;
    pnlDonationGrd: TRzPanel;
    pnlDonationsIn: TRzPanel;
    pnlBottom: TRzPanel;
    pnlStatus: TRzStatusPane;
    pnlButtons: TRzPanel;
    pnlSearch: TRzPanel;
    pnlSearchCancel: TRzPanel;
    pnlSearchCriteria: TRzPanel;
    pnlOptions: TRzPanel;
    pnlNavigator: TRzPanel;
    pnlHdrBtn: TRzPanel;
    btnOptionsTop: TsSpeedButton;
    btnOptionsLower: TsSpeedButton;
    btnPickBatch: TsSpeedButton;
    btnSearch: TsSpeedButton;
    btnCancelBatch: TsSpeedButton;
    btnSave: TsSpeedButton;
    btnCancelAndClose: TsSpeedButton;
    btnViewBatch: TsSpeedButton;
    btnViewRecord: TsSpeedButton;
    mnuAttachTrackingRecord: TMenuItem;
    mnuReallocateSustainerExtraAmount: TMenuItem;
    mnuAttachVehicle: TMenuItem;
    gbxDonations: TRzGroupBox;
    navMain: TpidDBNavigator;
    navMainFirst: TwwNavButton;
    navMainPrior: TwwNavButton;
    navMainNext: TwwNavButton;
    navMainLast: TwwNavButton;
    navMainInsert: TwwNavButton;
    navMainDelete: TwwNavButton;
    navMainEdit: TwwNavButton;
    navMainPost: TwwNavButton;
    navMainCancel: TwwNavButton;
    spinAutoCommit: TsSpinEdit;
    txtBatch: TsEdit;
    dtpBatchDate: TsDateEdit;
    lblAutoCommit: TsLabel;
    lblBatchDate: TsLabel;
    lblBatchNumber: TsLabel;
    grdMain: TPIDIDevExpressGrid;
    grdMainLevel: TcxGridLevel;
    grdMainTableView: TPIDIDBTableView;
    grdMainTableViewAccountId: TcxGridDBColumn;
    grdMainTableViewAltID: TcxGridDBColumn;
    grdMainTableViewFullName: TcxGridDBColumn;
    grdMainTableViewMcd: TcxGridDBColumn;
    grdMainTableViewFlag_List: TcxGridDBColumn;
    grdMainTableViewInterest_List: TcxGridDBColumn;
    grdMainTableViewSuppress_List: TcxGridDBColumn;
    grdMainTableViewFMV: TcxGridDBColumn;
    grdMainTableViewTicketPrice: TcxGridDBColumn;
    grdMainTableViewNbrTickets: TcxGridDBColumn;
    grdMainTableViewAmount: TcxGridDBColumn;
    grdMainTableViewCCInfo: TcxGridDBColumn;
    grdMainTableViewCheckNumber: TcxGridDBColumn;
    grdMainTableViewCheckDate: TcxGridDBColumn;
    grdMainTableViewCCLastApproval: TcxGridDBColumn;
    grdMainTableViewGivingLevel: TcxGridDBColumn;
    grdMainTableViewAcctCode: TcxGridDBColumn;
    grdMainTableViewAckCode: TcxGridDBColumn;
    grdMainTableViewAckDate: TcxGridDBColumn;
    grdMainTableViewAckStatus: TcxGridDBColumn;
    grdMainTableViewNoAck: TcxGridDBColumn;
    grdMainTableViewNoCalc: TcxGridDBColumn;
    grdMainTableViewHomePhone: TcxGridDBColumn;
    grdMainTableViewEmailAddress: TcxGridDBColumn;
    grdMainTableViewTickerSymbol: TcxGridDBColumn;
    grdMainTableViewItemDesc: TcxGridDBColumn;
    grdMainTableViewNumberShares: TcxGridDBColumn;
    grdMainTableViewTaxDate: TcxGridDBColumn;
    grdMainTableViewTaxValue: TcxGridDBColumn;
    grdMainTableViewLowValue: TcxGridDBColumn;
    grdMainTableViewHighValue: TcxGridDBColumn;
    grdMainTableViewSignedBy: TcxGridDBColumn;
    grdMainTableViewFec: TcxGridDBColumn;
    grdMainTableViewRestrictionDesc: TcxGridDBColumn;
    grdMainTableViewPlgAmount: TcxGridDBColumn;
    grdMainTableViewPlgFreqDesc: TcxGridDBColumn;
    grdMainTableViewPlgFreqId: TcxGridDBColumn;
    grdMainTableViewPlgMethodDesc: TcxGridDBColumn;
    grdMainTableViewSoftCredit: TcxGridDBColumn;
    grdMainTableViewSplitGift2: TcxGridDBColumn;
    grdMainTableViewPremium_List: TcxGridDBColumn;
    grdMainTableViewOrderIr: TcxGridDBColumn;
    grdMainTableViewPlgMethod: TcxGridDBColumn;
    grdMainTableViewSolicitorList: TcxGridDBColumn;
    grdMainTableViewSplitGift: TcxGridDBColumn;
    grdMainTableViewEvent_ID: TcxGridDBColumn;
    grdMainTableViewEvent_Name: TcxGridDBColumn;
    grdMainTableViewEvent_PurchaserName: TcxGridDBColumn;
    grdMainTableViewEvent_GuestName: TcxGridDBColumn;
    grdMainTableViewEvent_DonationType: TcxGridDBColumn;
    grdMainTableViewEvent_DonationSubType: TcxGridDBColumn;
    grdMainTableViewGroupDonations: TcxGridDBColumn;
    grdMainTableViewExtraAmount: TcxGridDBColumn;
    grdMainTableViewVendorId: TcxGridDBColumn;
    grdMainTableViewNotes: TcxGridDBColumn;
    grdMainTableViewAdjCode: TcxGridDBColumn;
    grdMainTableViewPrg: TcxGridDBColumn;
    grdMainTableViewChapterDesc: TcxGridDBColumn;
    grdMainTableViewChapter: TcxGridDBColumn;
    grdMainTableViewDonType: TcxGridDBColumn;
    AccountIdButtonEdit: TcxEditRepositoryButtonItem;
    dsFlagCode: TpidDataSource;
    dsInterestCode: TpidDataSource;
    dsSuppressCode: TpidDataSource;
    FlagCodeDropDown: TcxEditRepositoryLookupComboBoxItem;
    InterestCodeDropDown: TcxEditRepositoryLookupComboBoxItem;
    SuppressCodeDropDown: TcxEditRepositoryLookupComboBoxItem;
    grdMainTableViewDepartment: TcxGridDBColumn;
    dsDepartment: TpidDataSource;
    dsDonType: TpidDataSource;
    grdMainTableViewApplyPrefix: TcxGridDBColumn;
    dsProgram: TpidDataSource;
    grdMainTableViewPrgDesc: TcxGridDBColumn;
    grdMainTableViewCategoryDesc: TcxGridDBColumn;
    dsCategory: TpidDataSource;
    grdMainTableViewMatchingStatusDesc: TcxGridDBColumn;
    dsMatchingStatus: TpidDataSource;
    dsFundCode: TpidDataSource;
    grdMainTableViewFundCode: TcxGridDBColumn;
    grdMainTableViewSustainerClass: TcxGridDBColumn;
    grdMainTableViewRecurrence: TcxGridDBColumn;
    dsRecurrence: TpidDataSource;
    dsSustainerClass: TpidDataSource;
    dsPledgeDesc: TpidDataSource;
    dsPledgeFreqDesc: TpidDataSource;
    grdMainTableViewMedium: TcxGridDBColumn;
    dsMedium: TpidDataSource;
    dsRestrictionCode: TpidDataSource;
    dsGivingLevel: TpidDataSource;
    dsTransCode: TpidDataSource;
    dsAckCode: TpidDataSource;
    dsAckStatus: TpidDataSource;
    grdMainTableViewActivist_List: TcxGridDBColumn;
    dsGLStatus: TpidDataSource;   // 08/20/2013 RRR B-04715    Moved from Unicef
    grdMainTableViewGLStatus: TcxGridDBColumn;  // 08/20/2013 RRR B-04715    Moved from Unicef
    grdMainTableViewDonationID: TcxGridDBColumn; //07/14/2014 RRR D-04955 used in grdMainTableViewCanFocusRecord
    mnuDetachVehicle: TMenuItem;
    N1: TMenuItem;
    N2: TMenuItem;
    mnuAttachPledge: TMenuItem;
    mnuDetachPledge: TMenuItem;
//  mnuWriteOff: TMenuItem;  //01/02/2015 RRR  D-05249     //02/24/2015 RRR D-05313  Feature removed
//  N3: TMenuItem;    //02/24/2015 RRR D-05313
    N4: TMenuItem;
    // Form Functions
    procedure FormCreate(Sender: TObject);
    procedure FormAfterCreate(Sender: TObject); override;
    procedure FormAfterShow(Sender: TObject); override;  //10/28/2014 RRR D-05185
    procedure FormDestroy(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
    // Tab Functions
    procedure pgcMainChange(Sender: TObject);
    // Main Grid Behaviors
    procedure grdMainTableViewFocusedRecordChanged(Sender: TcxCustomGridTableView;
      APrevFocusedRecord, AFocusedRecord: TcxCustomGridRecord;
      ANewItemRecordFocusingChanged: Boolean);
    procedure grdMainEnter(Sender: TObject);
    procedure grdMainExit(Sender: TObject);
    procedure grdMainViewStylesGetContentStyle(Sender: TcxCustomGridTableView;
      ARecord: TcxCustomGridRecord; AItem: TcxCustomGridTableItem;
      out AStyle: TcxStyle);
    procedure grdMainTableViewEditKeyDown(Sender: TcxCustomGridTableView;
      AItem: TcxCustomGridTableItem; AEdit: TcxCustomEdit; var Key: Word;
      Shift: TShiftState);
    procedure grdMainTableViewEditKeyUp(Sender: TcxCustomGridTableView;
      AItem: TcxCustomGridTableItem; AEdit: TcxCustomEdit; var Key: Word;
      Shift: TShiftState);
    procedure grdMainTableViewMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure grdMainTableViewAccountIdPropertiesButtonClick(Sender: TObject;
       AButtonIndex: Integer);
    procedure grdMainTableViewAccountIdPropertiesEditValueChanged(
       Sender: TObject);
    procedure grdMainTableViewMcdPropertiesButtonClick(Sender: TObject;
      AButtonIndex: Integer);
    procedure grdMainTableViewEvent_NamePropertiesButtonClick(Sender: TObject;
      AButtonIndex: Integer);
    procedure grdMainTableViewEvent_PurchaserNamePropertiesButtonClick(Sender: TObject;
      AButtonIndex: Integer);
    procedure grdMainTableViewEvent_GuestNamePropertiesButtonClick(Sender: TObject;
      AButtonIndex: Integer);
    procedure grdMainTableViewSolicitorListPropertiesButtonClick(
      Sender: TObject; AButtonIndex: Integer);
    procedure grdMainTableViewMatchingStatusDescPropertiesPopup(Sender: TObject);
    // If a column wants to activate the ShowTab, assign this in the OnChange
    procedure StandardGridColumnOnChange(Sender: TObject);
    procedure btnOptionsTopClick(Sender: TObject);
    procedure btnSearchClick(Sender: TObject);
    procedure btnCancelBatchClick(Sender: TObject);
    procedure btnCancelAndCloseClick(Sender: TObject);
    procedure btnViewRecordClick(Sender: TObject);
    procedure btnPickBatchClick(Sender: TObject);
    procedure btnViewBatchClick(Sender: TObject);
    procedure puOptionsPopup(Sender: TObject);
    procedure txtBatchKeyPress(Sender: TObject; var Key: Char);
    procedure txtDateEraseMeKeyPress(Sender: TObject; var Key: Char);
    // Menu items
    procedure mnuDetachPledgeOnClick(Sender: TObject);
    procedure mnuAttachPledgeOnClick(Sender: TObject);
    procedure mnuReloadDonorInfoClick(Sender: TObject);
    procedure mnuAttachTrackingRecordClick(Sender: TObject);
    procedure mnuReallocateSustainerExtraAmountClick(Sender: TObject);
    procedure mnuAttachVehicleClick(Sender: TObject);
    procedure grdMainTableViewMcdPropertiesEditValueChanged(Sender: TObject);
    procedure dtpBatchDateKeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure txtBatchKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure grdMainTableViewCellClick(Sender: TcxCustomGridTableView;
      ACellViewInfo: TcxGridTableDataCellViewInfo; AButton: TMouseButton;
      AShift: TShiftState; var AHandled: Boolean);
    procedure grdMainTableViewFocusedItemChanged(Sender: TcxCustomGridTableView; APrevFocusedItem,
      AFocusedItem: TcxCustomGridTableItem);
    procedure grdMainTableViewPrgDescPropertiesEditValueChanged(
      Sender: TObject);
    procedure grdMainTableViewCodeListPropertiesButtonClick(Sender: TObject;
      AButtonIndex: Integer);
    procedure FormActivate(Sender: TObject);
    procedure grdMainTableViewDonTypePropertiesInitPopup(Sender: TObject);
    procedure splMainAfterOpen(Sender: TObject);
    procedure splMainMoved(Sender: TObject);
    procedure grdMainResize(Sender: TObject);
    procedure grdMainTableViewAccountIdPropertiesValidate(Sender: TObject;
      var DisplayValue: Variant; var ErrorText: TCaption; var Error: Boolean);
    procedure grdMainTableViewCanFocusRecord(Sender: TcxCustomGridTableView;  //07/14/2014 RRR D-04955
      ARecord: TcxCustomGridRecord; var AAllow: Boolean);
    procedure grdMainTableViewCategoryDescPropertiesCloseUp(Sender: TObject);
    procedure grdMainTableViewMatchingStatusDescPropertiesCloseUp(Sender: TObject);
    procedure mnuDetachVehicleClick(Sender: TObject);
//  procedure mnuWriteOffClick(Sender: TObject);       //01/02/2015 RRR  D-05249    //02/24/2015 RRR D-05313  Feature removed
    procedure grdMainTableViewResetColumns(Sender: TObject);
  private
    FBatchDateStr: string;
    FNextFlagID: Integer;
    FNextInterestID: Integer;
    FNextSuppID: Integer;
    FWorkInProgress: Boolean;
    FCursorLocSet: Boolean;
    FEditDonationID: Integer;
    FNoSave: Boolean;
    FLastUpdatedBatch: String;
    // 10/24/2014 gms d-05138 DEPRECATED no longer needed; LockBatch will check the lock status on the
    //   batch log record itself.
    // FBatchIsLocked: Boolean;
    // 7/21/2014 gms d-04866 DEPRECATED no longer needed; was only used in OnCanFocusRecord
    //   no longer used there
    // FLastDonID: Integer;   //07/14/2014 RRR D-04955

    procedure ShowPledgeColumns;
  protected
    //****************** KEEP MEMBERS *********************
    FDmGiftProcessing: TdmGiftProcessingClient;
    dsBatchLog: TpidDataSource;
    FRefreshTabs: Boolean;

    // Auto Open Feature. Set values - FormShow opens.
    FAutoOpenBatchStr: string;
    FAutoOpenBatchDate: TDateTime;
    FAutoOpenBatch: Boolean;

    FProspectSearch: Boolean;

    //*****************************************************

    FTotalAmount: Currency;
    FBatchDate: TDate;
    FChapter1Label: string;
    FChapter2Label: string;
    FAllowCreditCardEntry: Boolean;  //CCFA Only - can enter CC INFO on all CC Donations
    FSkipValidation: Boolean;
    FEditDonation: Boolean;
    FInsertDonation: Boolean;
    FAnyVehicleDons: Boolean;
    FAnyNewVehicles: Boolean;
    FAnySplitDonations: Boolean;
    FBatchPosted: Boolean;
    FBatchSoftClosed: Boolean;
    FIsValidating: Boolean;
    FIsRO: Boolean;
    FIsDMP: Boolean;
    FOrigRecCode: string;
    FOrigDonType: string;
    FOrig_RSR: string;
    FOrig_Chapter_Credit: string;
    FFundType: string;    //Used by PPFA
    FSuppLabel: string;
    FEventList: TStrings;
    FRestrictedFieldList: TStringList;
    FSearchMode: Boolean;
    FAlwaysShowDonType: Boolean;
    FAlwaysShowTaxDate: Boolean;
    FStaticGL: Boolean;
    FShowAltID: Boolean;
    FAltIDFieldName: string;
    FDonationCount: Integer;
    FLinkedGiftID: Integer;
    // set in OnFocusedItemChanged, is the currently focused column
    FFocusedGridTableItem: TcxCustomGridTableItem;
    FSplitterChangedProcessed: Boolean;
    FCanEditGLStatus: Boolean;     // 08/20/2013 RRR B-04715

    //****************** KEEP METHODS *********************
    procedure ResetForm(); override;
    procedure ApplyOptionsToGrid(pTurnOffEvent: Boolean); virtual;
    procedure ApplyCustomOptionsToGrid; virtual;
    procedure SetRestrictedEditingColumn(); virtual;
    procedure DoCancel(pMessageToDisplay: Integer); virtual;
    procedure SetBatchLabel(); virtual;
    procedure LockBatch(pLockBatch: Boolean);

    // Search
    procedure DoAccountSearch();
    procedure DoSearch();
    procedure DoBatchSearch(); virtual;
    procedure FillDonationGrid;
    procedure FillInSCFields; virtual;
    procedure SetCheckedColumns(pFromFillDonationGridMethod: Boolean); virtual;
    procedure SetCustomCheckedColumns(pFromFillDonationGridMethod: Boolean); virtual;
    procedure DisplayQtys; virtual;
    // 4/3/2014 gms d-04662 adding account ID parameter for caller to send in;
    //    used in editvaluechanged to use the entered account ID before assignment to field
    function CanChangeAccount(pAccountID: Integer): Boolean; // Not virtual

    // Gift Processing DataSet Event Listeners
    procedure GiftProcessingAutoCommitDataEventCallBack;
    procedure GiftProcessingBeforeInsertDataEventCallBack;
    procedure GiftProcessingAfterInsertDataEventCallBack;
    procedure GiftProcessingAfterDeleteDataEventCallBack;
    procedure GiftProcessingAfterPostDataEventCallBack;
    procedure GiftProcessingOnPrgChangeDataEventCallBack;

    // "SAVE" Related Methods
    procedure SaveRoutine; override;
    procedure PreUpdateRoutine(); // Not virtual
    function UpdateTheDatabase(pDelogSql: TStringList; pCopyGiftProcessing: TpidCDSProvider): Boolean; // Not virtual   //04/28/2014 RRR D-04751 - Add parameter
    procedure AddAdditionalUpdateTheDatabaseDataSets(pList: TList); virtual;
    procedure GenerateDataEntryLogSql(pDeLogSQLList: TStringList; pCopyGiftProcessing: TpidCDSProvider); // Not virtual   //04/28/2014 RRR D-04751 - Add parameter

    // Main tab Changing Methods
    procedure ShowTab(pForceShowTab: TcxGridDBColumn = nil); // Not virtual
    (* 6/19/2014 gms b-05611 no longer using threads to move field to field
    // See MoveToNextField in Public below
    procedure ThreadedMoveToNextField;
    // See MoveToField in Public below
    procedure ThreadedMoveToField(pDevExpressGridView: TPIDIDBTableView; pFieldName: string); // Not virtual
    *)

    // New Initialize Methods
    procedure InitializeTabImoIho; // Not virtual
    procedure InitializeTabMatchingGift; // Not virtual
    procedure InitializeTabGiftMembership; // Not virtual
    procedure InitializeTabPremiums; // Not virtual
    procedure InitializeTabSoftCredit; // Not virtual
    procedure InitializeTabCreditCardInfo; // Not virtual
    procedure InitializeTabEFTInfo; // Not virtual
    // procedure InitializeTabSplitDonations; // Not virtual
    procedure InitializeTabIROrders; // Not virtual

    // Edit Account Record Methods
    procedure DoGiftProcEditAccountRecord(pMinEditMode: TGiftProcMinEditMode;
       pAccountId: Integer; pLoop: Boolean); virtual;
    function DoMinAdd: Boolean; virtual;
    procedure DoMinEdit(pMinEditMode: TGiftProcMinEditMode; pAccountId: Integer;
       pLoop: Boolean); virtual;

    // Event Ticket Purchase Dialog
    procedure DoGetEventTicketPurchaserGuest();

    // Do something with these
    function DeferConstraintsSQL: TStringList;
    procedure PrintRoutine; override;

    function HasChanges(pDataSet: TpidCdsProvider; pAccountID: Integer): Boolean;

    // Pledge
    procedure AddJournaledPledge(); virtual;
    procedure CheckJournaledPledge(); virtual;
    procedure AddTrackingRecordPledge; virtual;   // 10/01/2013 RRR D-04371
    procedure DisablePledgeFields;
    procedure EnablePledgeFields;

    // Mail Code
    // used for special client processing after the mail code's value changes; ATC
    procedure MailCodeClientEditValueChanged; virtual;

    // Master
    // looks like below is only called from trea client
    procedure RemoveFlagCode(pAccountID: Integer; pFlagCode: string);

    procedure AddMasterHst(pAccountID: Integer; pField, pOldValue, pNewValue: string);
    procedure ChangeMasterValue(pDataSet: TpidCdsProvider; pAccountID: Integer;
       pField, pNewValue: string);
    procedure SetCultCode; virtual;
    function AddEmploymentRec(pList: TStringList): String;
    function LookupSID(pIsAltID: Boolean; var pID:string): Boolean; virtual;
    procedure SetAltIDParams; virtual;

    // Events
    procedure GetEventDonationValues; virtual;

    // Vehicle
    procedure AttachVehicleToDonation(pAccountID: Integer);
    procedure DetachVehicleFromDonation();
    procedure ShowVehicles;

    // Soft Credit
    function DoSoftCreditsBalance(pCopyGiftProcessing: TpidCDSProvider): Boolean; virtual;  //04/28/2014 RRR D-04751 - Add parameter

    // Adjustments
    function FindAdjustmentBatches(pAdjustOrigDonationCds: TPidCdsProvider): Boolean;
//  function AdjustLinkedGiftAmt: TStringList; virtual;     //06/05/2014 RRR D-04831
    procedure Add2cdsDonationAdjustment(pAdjID, pBackOutID, pNewID: Integer);

    // Solicitor
    procedure GetSolicitor; virtual;
    procedure ShowSolicitor(); virtual;
    procedure SolicitorEvent(pSolicitorList: string); virtual;

    // Major Gift
    function GetMgfUpdateSql(pList: TStringList): String;
    function GetMgfDeleteSql(pList: TStringList): String;

    // Order IR
    procedure CloneIRContactCDS;  virtual;  //overidden by UNICEF

    // Split Gift/Donation
    // 12/30/2014 gms d-05250 removed pNewSplit; was not used
    procedure ShowSplitDonation;
    procedure ValidateSplitDonation(pDataSet: TpidCDSProvider; var pAnyErrors: Boolean);
    procedure ShowSplitGifts;
    procedure SetSplitGift; virtual;

    // Security
    function UserCanEditThisRecord: Boolean; virtual;
//    function UserCanAddFlags: Boolean; virtual;   //CARE Only  Deprecated April 2014 TWM
    function UserCanSeeThisBatch: Boolean; virtual;  //ACLU, IRC

    // **** UNSORTED ************************
    procedure SetInsertDonation(const pValue: Boolean);
    procedure SetEditDonationID(const pValue: Integer);
    procedure CheckDonationDeletes(aDeltaDS: TClientDataSet);
    function LastDonation(pAccountID: Integer; pBatchDate: TDateTime): Boolean;
    procedure RenewalRoutine(pDeltaDS: TClientDataSet); virtual;

    function GetPremiumPageName: string; virtual;
    procedure AddDonationData(pDonationID: string; pStringList: TStringList);
    procedure DonationDeleted(pDeltaDS: TClientDataSet); virtual;
    procedure SetChapter; virtual;
    function GetDonationCode: string; virtual;  //FAIR Only
    (* 10/31/2014 gms b-05053 DEPRECATED empty procedure and no client overrides
    procedure CalcDefaultDonationAmount(pTotalFees: Currency); virtual;
    *)
    procedure SetProgramFilter; virtual;   //LCV Only
    function DoGroupMembershipsBalance(pCopyGiftProcessing: TpidCDSProvider): Boolean; virtual;  //CCFA Only   //04/28/2014 RRR D-04751 - Add parameter
    procedure ShowSplitGroups(); virtual;
    procedure GetDonationCount(pAccountIDStr: string); virtual;    //Spinal Only
    procedure SetEditDonation(const pValue: Boolean); virtual;
    procedure ResetTaxValue; virtual;   //ACLU Only
    procedure DoProcessReadOnlyFormSetting; override;
    procedure LoadFormSettings(); override;
    procedure SaveFormSettings(); override;
    procedure DoCloseSplitter(); virtual;
    // 4/10/2014 gms d-04768 moved code from Account ID's column OnEditValueChanged so that it
    //   can be called from place where the account ID is not focused
    procedure DoAccountIDEditValueChanged(pAccountID: Integer); virtual;
  public
    FTempMoveDevExpressGridView: TPIDIDBTableView; // Used internally for navigating grid columns from thread.
    FTempMoveFieldName: string; // Used internally for navigating grid columns from thread.
    // Batch mode constructor
    constructor Create(AOwner: TComponent); overload; override;
    // Adjustment mode constructor
    constructor Create(AOwner: TComponent; pDataModuleMode: TpidiDataModuleMode); reintroduce; overload;
    destructor Destroy; override;
    procedure cdsGiftProcessingAfterScroll(DataSet: TDataSet);

    // Validate the status of the Batch
    function ValidateBatchStatus(pPerformAbort: Boolean): Boolean; virtual;
    function ValidateLowerGrids(): Boolean; virtual;
    function ApplyHostUpdate: Boolean; override;
    function GetFormDataState(): TpidiFormDataState; override;   //01/29/2014 RRR D-04330

    // Column navigation
    procedure MoveToNextField; virtual;
    procedure MoveToField(); overload; // Not virtual. Uses temp form properties with thread.
    procedure MoveToField(pDevExpressGridView: TPIDIDBTableView; pFieldName: string); overload; // Not virtual

    // Adjustments
    function AdjustThisDonation(pAdjustOrigDonationCds: TPidCdsProvider): Boolean;
    function EditThisDonation(pAdjustOrigDonationCds: TPidCdsProvider): Boolean;
    procedure LoadSingleDonation(pBDate: TDateTime; pBatch: string);
    property EditDonation: Boolean read FEditDonation write SetEditDonation;
    property InsertDonation: Boolean read FInsertDonation write SetInsertDonation;
    property EditDonationID: Integer read FEditDonationID write SetEditDonationID;
    property DmGiftProcessing: TdmGiftProcessingClient read FDmGiftProcessing write FDmGiftProcessing;

    // Auto Open Feature. Set values - FormShow opens.
    property AutoOpenBatchStr: string read FAutoOpenBatchStr write FAutoOpenBatchStr;
    property AutoOpenBatchDate: TDateTime read FAutoOpenBatchDate write FAutoOpenBatchDate;
    property AutoOpenBatch: Boolean read FAutoOpenBatch write FAutoOpenBatch;
  end;

  (* 6/19/2014 gms b-05611 no longer using threads to move field to field
  // For managing UI events out-of-process like keyboard events.
  TUIThread = class(TThread)
  private
  protected
    procedure Execute; override;
  public
    OwnerForm: TfrmBatchGiftProcessing;
    FDevExpressGridView: TPIDIDBTableView;
    FFieldName: string;
    constructor Create(CreateSuspended: Boolean) ;
  end;
  *)

implementation

{$R *.dfm}

uses
  pidiGlobals, pidiCore, pidiAstaServices, pidiConfigPoints, MasterViewClientFrm,
  MasterViewFrmFactory, EmployeeSearchFrm, RzErrDlg, DBCtrls, Global,
  PlaceOrderClientFrm, SplitGiftClientFrm, SplitDonationClientFrm, PrintBatchGalleySimple_unit,
  EventSplitGroupsClientFrm, BatchLogPickList, BatchLogAdjustPickListFrm,
  MailCodePickList, pidiSolicitorClientFrm, SolicitorDM, EventTicketPurchaseGridClientFrm,
  pidiCoreDB, GiftProcessingDM, BatchLogGiftProcessingFrm, BatchLogGiftProcessingClientFrm,
  DonationDm, BatchGiftProcessingOptionsFrm,

  // TABS
  TabGPImoIhoClientFrm,
  TabGPMatchingGiftClientFrm,
  TabGPGiftMembershipClientFrm,
  TabGPPremiumClientFrm,
  TabGPSoftCreditClientFrm,
  TabGPCreditCardClientFrm,
  TabGPEFTClientFrm,
  TabGPIROrdersClientFrm;

const
  StatusMsg = 'F2 - Account Search   F3 - Edit Account   F4 - Prospect Search   Space - Popup Code Editor';

(* 6/19/2014 gms b-05611 no longer using threads to move field to field
constructor TUIThread.Create(CreateSuspended: Boolean) ;
begin
  inherited Create(CreateSuspended);
  OwnerForm := nil;
  FDevExpressGridView := nil;
  FFieldName := '';
end;

procedure TUIThread.Execute;
begin
  FreeOnTerminate := True;
  if (OwnerForm <> nil) then begin
    Sleep(200);
    if (FDevExpressGridView = nil) then begin
      Synchronize(OwnerForm.MoveToNextField);
    end else begin
      OwnerForm.FTempMoveDevExpressGridView := FDevExpressGridView;
      OwnerForm.FTempMoveFieldName := FFieldName;
      Synchronize(OwnerForm.MoveToField);
    end;
  end;
end;
*)

// Batch Mode
constructor TfrmBatchGiftProcessing.Create(AOwner: TComponent);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.Create(Adjustment Mode)');
  try
    // Create the main datamodule.
    DmGiftProcessing := TdmGiftProcessingClient.Create(Self, dmmGiftProcessing);
    DmGiftProcessing.DmDonation.GiftProcessingAutoCommitDataEventCallBack := GiftProcessingAutoCommitDataEventCallBack;
    DmGiftProcessing.DmDonation.GiftProcessingBeforeInsertDataEventCallBack := GiftProcessingBeforeInsertDataEventCallBack;
    DmGiftProcessing.DmDonation.GiftProcessingAfterInsertDataEventCallBack := GiftProcessingAfterInsertDataEventCallBack;
    DmGiftProcessing.DmDonation.GiftProcessingAfterDeleteDataEventCallBack := GiftProcessingAfterDeleteDataEventCallBack;
    DmGiftProcessing.DmDonation.GiftProcessingAfterPostDataEventCallBack := GiftProcessingAfterPostDataEventCallBack;
    DmGiftProcessing.DmDonation.GiftProcessingOnPrgChangeDataEventCallBack := GiftProcessingOnPrgChangeDataEventCallBack;
    // Calls FormCreate
    inherited Create(AOwner);
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.Create(Adjustment Mode)');
  end;
end;

// Adjustment Mode
constructor TfrmBatchGiftProcessing.Create(AOwner: TComponent; pDataModuleMode: TpidiDataModuleMode);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.Create(Adjustment Mode)');
  try
    if ((pDataModuleMode <> dmmAdjBatch) and (pDataModuleMode <> dmmEditDonation)) then begin
      raise Exception.Create('BatchGiftProcessingForm.Create :: The Datamodule Mode Must be dmmAdjBatch or dmmEditDonation');
    end;
    // Create the main datamodule.
    DmGiftProcessing := TdmGiftProcessingClient.Create(Self, pDataModuleMode);
    DmGiftProcessing.DmDonation.GiftProcessingAutoCommitDataEventCallBack := GiftProcessingAutoCommitDataEventCallBack;
    DmGiftProcessing.DmDonation.GiftProcessingAfterInsertDataEventCallBack := GiftProcessingAfterInsertDataEventCallBack;
    DmGiftProcessing.DmDonation.GiftProcessingAfterDeleteDataEventCallBack := GiftProcessingAfterDeleteDataEventCallBack;
    DmGiftProcessing.DmDonation.GiftProcessingAfterPostDataEventCallBack := GiftProcessingAfterPostDataEventCallBack;
    DmGiftProcessing.DmDonation.GiftProcessingOnPrgChangeDataEventCallBack := GiftProcessingOnPrgChangeDataEventCallBack;

    // Calls FormCreate
    inherited Create(AOwner);
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.Create(Adjustment Mode)');
  end;
end;

destructor TfrmBatchGiftProcessing.Destroy;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.Destroy');
  try

    inherited;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.Destroy');
  end;
end;

procedure TfrmBatchGiftProcessing.FormCreate(Sender: TObject);
var
  aTmpField: TField;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormCreate');
  try
    inherited;

    // 2/12/2015 gms d-5329 assign unique form name
    Self.Name := GetUniqueName(Self.Name);

    // Defaults.
    FEventList := TStringList.Create;
    FRestrictedFieldList := TStringList.Create;

    // Hook up the main datamodule, created in on of the the constructors.
    dsGiftProcessing.DataSet := nil;
    dsDonType.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsDonType;
    dsAcctCode.DataSet := DmGiftProcessing.DmAccount.DmAccountCodes.cdsAcctCode;
    dsChapterCode.DataSet := dmPidiCoreClient.cdsChapterCode;
    dsFlagCode.DataSet := DmGiftProcessing.DmAccount.DmAccountCodes.cdsFlagCode;
    dsInterestCode.DataSet := DmGiftProcessing.DmAccount.DmAccountCodes.cdsInterestCode;
    dsSuppressCode.DataSet := DmGiftProcessing.DmAccount.DmAccountCodes.cdsSuppressCode;
    dsDepartment.DataSet := DmGiftProcessing.DmAccount.DmAccountCodes.cdsDepartment;
    dsEventDonationType.DataSet := DmGiftProcessing.DmEventCodes.cdsEventDonationType;
    dsEventDonationSubType.DataSet := DmGiftProcessing.DmEventCodes.cdsEventDonationSubType;

    dsProgram.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsProgramID;
    dsCategory.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsDonCategory;
    dsMatchingStatus.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsMatchingStatus;
    dsFundCode.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsFundCode;
    dsSustainerClass.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsSustainerClass;
    dsRecurrence.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsRecurrenceCode;
    dsRestrictionCode.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsDonRestrictCode;
    dsGivingLevel.DataSet := DmGiftProcessing.DmAccount.DmAccountCodes.cdsGivingLevel;
    dsGLStatus.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsGLStatusCode;  // 08/20/2013 RRR B-04715    Moved from Unicef

    dsPledgeDesc.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsSusPaymentType;
    dsPledgeFreqDesc.DataSet := DmGiftProcessing.DmDonation.DmDonationCodes.cdsPlgFreq;

    // Set the actions...
    DmGiftProcessing.ApplySaveActionToDataModules(SaveAction);

    PageControlInfo.NavBar := navMain;
    PageControlInfo.DmGiftProcessing := DmGiftProcessing;
    PageControlInfo.RecordId := -1;
    PageControlInfo.PageControl := pgcMain;
    PageControlInfo.SaveAction := SaveAction;

    // Don't activate the Print Button unless DMDonation has been created.
    // This will can prevent in inadvertent Access Violoation
    if DmGiftProcessing.DmDonation <> nil then begin
      PageControlInfo.PrintAction := PrintAction;
    end;

    PageControlInfo.GiftProcEditAccountRecord := DoGiftProcEditAccountRecord;

    gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction;

    DBNavigator := navMain;

    // Make all tabs invisible. A group box on the tab describes them now.
    // This gives the tab more space for records.
    TabImoIho.TabVisible := False;
    TabMatchingGift.TabVisible := False;
    TabGiftMembership.TabVisible := False;
    TabPremiums.TabVisible := False;
    TabSoftCredit.TabVisible := False;
    TabCreditCardInfo.TabVisible := False;
    TabEftInfo.TabVisible := False;
    TabSplitDonations.TabVisible := False;
    TabIROrders.TabVisible := False;

    // Reset the form to defaults.
    ResetForm();

    dsBatchLog := TpidDataSource.Create(Self);
    dsBatchLog.DataSet := DmGiftProcessing.DmDonation.cdsBatchLog;
    dsBatchLog.AutoEdit := False;

    DmGiftProcessing.DmAccount.cdsPhone.BeforePost := nil;
    DmGiftProcessing.DmAccount.cdsEMail.BeforePost := nil;

    CloneIRContactCDS;

    txtBatch.MaxLength := DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Batch').Size;

    SetProgramFilter;    //LCV Only
    DmGiftProcessing.DmDonation.cdsGiftProcessing.Close;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldDefs.Clear;
    aTmpField := AddNewField(DmGiftProcessing.DmDonation.cdsGiftProcessing, 'ProspectAdd', '', ftBoolean, 0, False);
    aTmpField.Origin := 'OMIT';
    aTmpField.Tag := -1;

    DmGiftProcessing.DmDonation.cdsGiftProcessing.CreateDataSet;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').DisplayWidth := 20;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormCreate');
  end;
end;

procedure TfrmBatchGiftProcessing.FormAfterCreate(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormAfterCreate');
  try
    inherited;
    // Nothing here

  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormAfterCreate');
  end;
end;

procedure TfrmBatchGiftProcessing.FormDestroy(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormDestroy');
  try
    // If opened as a floating windows, UnAssignButtons
    if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) or (DmGiftProcessing.DataModuleMode = dmmEditDonation) then begin
      UnAssignButtons();
    end;

    DmGiftProcessing.DmDonation.GiftProcessingAutoCommitDataEventCallBack := nil;
    DmGiftProcessing.DmDonation.GiftProcessingAfterInsertDataEventCallBack := nil;
    DmGiftProcessing.DmDonation.GiftProcessingAfterDeleteDataEventCallBack := nil;
    DmGiftProcessing.DmDonation.GiftProcessingAfterPostDataEventCallBack := nil;
    DmGiftProcessing.DmDonation.GiftProcessingOnPrgChangeDataEventCallBack := nil;
    DmGiftProcessing.Free();   //08/29/2014 RRR D-05069  This may be the cause of ASPCA adjustment problems

    FreeEventListObjects(FEventList);
    FEventList.Free();
    FRestrictedFieldList.Free();
    PageControlInfo.GiftProcEditAccountRecord := nil;
    PageControlInfo.PrintAction := nil;

    inherited;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormDestroy');
  end;
end;

procedure TfrmBatchGiftProcessing.FormShow(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormShow');
  try
    inherited;
    // These have to be here - not FormCreate or ResetForm
    grdMainTableView.Navigator.Visible := False; // Hide built-in navigator
    grdMainTableView.OptionsCustomize.ColumnsQuickCustomization := False; // Hide column selector
    grdMainTableView.OnFocusedItemChanged := grdMainTableViewFocusedItemChanged;  //06/19/2014 RRR B-05611
                                                                                  //Must connect at runtime, did not work when connected at design time
    if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) or (DmGiftProcessing.DataModuleMode = dmmEditDonation) then begin
      dsGiftProcessing.DataSet := DmGiftProcessing.DmDonation.cdsGiftProcessing;
    end;

    //  Add the ProspectAdd Boolean to the DmGiftProcessing.DmDonation.cdsGiftProcessing.
    FSearchMode := False;
    Self.TabStop := False;
    TDrawGrid(grdMain).Options := TDrawGrid(grdMain).Options - [goColMoving];

//10/28/2014 RRR D-05185  Moved this code to AfterShow
//Batch was not displaying correctly when Batch Search was called from FormShow
(*  if FInsertDonation then begin
      btnSearchClick(Self);
      if DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsBrowse then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Insert;
      end;
    end;

    if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
      // Do not save these after setting them. It is temporary.
      if (not DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_UPDATE_MASTER_INFO)) then begin
        DmGiftProcessing.DmDonation.GiftProcSelectedUserOptions.Add(OPTION_UPDATE_MASTER_INFO);
      end;
      if (not DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_ZIP_SURNAME_SEARCH)) then begin
        DmGiftProcessing.DmDonation.GiftProcSelectedUserOptions.Add(OPTION_ZIP_SURNAME_SEARCH);
      end;
    end;

    // Auto Open feature.
    if (FAutoOpenBatch = True) and
       (IsEmptyStr(FAutoOpenBatchStr) = False) and
       (FAutoOpenBatchDate > 0) then begin
      // Set search criteria.
      txtBatch.Text := FAutoOpenBatchStr;
      dtpBatchDate.Date := FAutoOpenBatchDate;
      // Perform the open.
      DoSearch();
    end else if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) or (DmGiftProcessing.DataModuleMode = dmmEditDonation) then begin
      btnSave.Enabled := False;
      if (grdMain.Showing) and (grdMain.CanFocus) and (grdMain.Focused = False) then begin
        grdMain.SetFocus;
      end;
       //txtbatch not visible on adjustments
      grdMainTableViewFocusedRecordChanged(nil, nil, nil, False);
    end else begin
      // 2/14/2013 gms txtBatch not showing for edit/adjust so must protect setfocus with test
      if (txtBatch.Showing) and (txtBatch.CanFocus) then begin
        txtBatch.SetFocus();
      end;
    end;          *)
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormShow');
  end;
end;

//10/28/2014 RRR D-05185 - Code was moved from FormShow
procedure TfrmBatchGiftProcessing.FormAfterShow(Sender: TObject);
begin
  inherited;
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormAfterShow');
  try
    inherited;

    if FInsertDonation then begin
      btnSearchClick(Self);
      if DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsBrowse then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Insert;
      end;
    end;

    if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
      // Do not save these after setting them. It is temporary.
      if (not DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_UPDATE_MASTER_INFO)) then begin
        DmGiftProcessing.DmDonation.GiftProcSelectedUserOptions.Add(OPTION_UPDATE_MASTER_INFO);
      end;
      if (not DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_ZIP_SURNAME_SEARCH)) then begin
        DmGiftProcessing.DmDonation.GiftProcSelectedUserOptions.Add(OPTION_ZIP_SURNAME_SEARCH);
      end;
    end;

    // Auto Open feature.
    if (FAutoOpenBatch = True) and
       (IsEmptyStr(FAutoOpenBatchStr) = False) and
       (FAutoOpenBatchDate > 0) then begin
      // Set search criteria.
      txtBatch.Text := FAutoOpenBatchStr;
      dtpBatchDate.Date := FAutoOpenBatchDate;
      // Perform the open.
      DoSearch();
    end else if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) or (DmGiftProcessing.DataModuleMode = dmmEditDonation) then begin
      btnSave.Enabled := False;
      if (grdMain.Showing) and (grdMain.CanFocus) and (grdMain.Focused = False) then begin
        grdMain.SetFocus;
      end;
       //txtbatch not visible on adjustments
      grdMainTableViewFocusedRecordChanged(nil, nil, nil, False);
    end else begin
      // 2/14/2013 gms txtBatch not showing for edit/adjust so must protect setfocus with test
      if (txtBatch.Showing) and (txtBatch.CanFocus) then begin
        txtBatch.SetFocus();
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormAfterShow');
  end;
end;

procedure TfrmBatchGiftProcessing.FormActivate(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormActivate');
  try
    inherited;

    DmGiftProcessing.DmDonation.SetBugReportData();
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormActivate');
  end;
end;

procedure TfrmBatchGiftProcessing.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
var
  aDataSetList: TList;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormCloseQuery');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.FormCloseQuery';
  try
    // 10/24/2014 gms d-05138 DEPRECATED no longer needed; LockBatch will check the lock status on the
    //   batch log record itself.
    // if FBatchIsLocked then begin

    // 10/29/2014 gms d-05138 move lock batch to end after verifying that we can close the form
    // LockBatch(False);
    // end;

    if FNoSave then begin
      CanClose := True;
      // Exit;
    end else begin
      aDataSetList := nil;
      try
        aDataSetList := TList.Create;
        aDataSetList.Add(DmGiftProcessing.DmDonation.cdsPledge);
        aDataSetList.Add(DmGiftProcessing.DmDonation.cdsGiftProcessing);
        aDataSetList.Add(DmGiftProcessing.DmAccount.cdsMaster);
        aDataSetList.Add(DmGiftProcessing.DmDonation.cdsDonatedVehicle);
        aDataSetList.Add(DmGiftProcessing.DmDonation.cdsSplitDonation);
        aDataSetList.Add(DmGiftProcessing.DmImoIho.cdsImoIho);
        aDataSetList.Add(DmGiftProcessing.DmDonation.cdsPremium);
        aDataSetList.Add(DmGiftProcessing.DmAccount.cdsPhone);
        aDataSetList.Add(DmGiftProcessing.DmAccount.cdsEMail);
        aDataSetList.Add(DmGiftProcessing.DmDonation.cdsSoftCredit);
        aDataSetList.Add(DmGiftProcessing.DmAccount.cdsDemographic);
        aDataSetList.Add(DmGiftProcessing.DmAccount.cdsFlag);
        aDataSetList.Add(DmGiftProcessing.DmAccount.cdsInterest);
        aDataSetList.Add(DmGiftProcessing.DmDonation.cdsMasterAccess);
        aDataSetList.Add(DmGiftProcessing.DmDonation.cdsDonationSolicitor);
        if GetConfigPointYesNoBoolean('ACCT', 'Suppression Active') = True then begin
          aDataSetList.Add(DmGiftProcessing.DmAccount.cdsSuppress);
        end;
        if GetConfigPointYesNoBoolean('ACCT', 'Activist Active') = True then begin
          aDataSetList.Add(DmGiftProcessing.DmAccount.cdsActivist);
        end;
        CanClose := DSCloseQuery('Cannot Close', aDataSetList, ApplyHostUpdate);
      finally
        aDataSetList.Free;
      end;
    end;
    if CanClose = True then begin
      LockBatch(False);
    end;
    inherited;
  finally
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.FormCloseQuery';
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormCloseQuery');
  end;
end;

procedure TfrmBatchGiftProcessing.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormClose');
  try
    // Can't free and get a modal result.
    // If we are in adjustment mode (suggesting a modal window), then free.
    //if ((DmGiftProcessing.DataModuleMode = dmmAdjBatch) or (DmGiftProcessing.DataModuleMode = dmmEditDonation)) then begin
    //  Action := caFree;
    //end;
    inherited;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FormClose');
  end;
end;

// Intended to reset the form to a default state. Use after the "Cancel" is
// clicked, for instance, or during create.
procedure TfrmBatchGiftProcessing.ResetForm();
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ResetForm');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.ResetForm';
  try
    inherited;
    // Reset the form to defaults.

    // Main UI
    // 10/27/2014 gms d-05138 ensure form is not read only when changing batches; can
    //   be reset to FormReadOnly true later
    Self.FormReadOnly := False;

    SaveAction.Enabled := False;
    btnSearch.Enabled := True;
    btnCancelBatch.Enabled := False;
    btnPickBatch.Enabled := True;
    btnOptionsTop.Enabled := True;
    btnOptionsLower.Visible := False;
    btnSave.Enabled := False;
    splMain.CloseSplitter;
    splMain.Visible := False;
    gPidiDDGlobal.MainFormStatusPane.Caption := '';
    txtBatch.Enabled := True;
    dtpBatchDate.Enabled := True;
    gbxDonations.Caption := '&Gifts';
    btnViewBatch.Enabled := False;
    btnViewRecord.Enabled := False;
    dsGiftProcessing.DataSet := nil;  //05/20/2014 RRR D-04846  Moved from below - Was enabling nav Bar
    grdMain.Enabled := False;
    navMain.Enabled := False;
//  dsGiftProcessing.DataSet := nil;     //05/20/2014 RRR D-04846
    PrintAction.Enabled := False;
    grdMain.OnEnter := grdMainEnter;
    grdMain.OnExit := grdMainExit;

    // More defaults.
    FAutoOpenBatchStr := '';
    FAutoOpenBatchDate := 0;
    FAutoOpenBatch := False;
    FRefreshTabs := False;
    FLastUpdatedBatch := '';
    FIsDMP := UpperCase(gPidiDDGlobal.ServerCom.UserPrimaryGroup) = 'DMP';
    FShowAltID := False;
    FAlwaysShowDonType := False;
    FAlwaysShowTaxDate := False;
    FAllowCreditCardEntry := False;  //CCFA Only - can enter CC iNFO on all CC Donations
    FWorkInProgress := False;
    FSkipValidation := False;
    FEditDonation := False;
    FInsertDonation := False;
    FSplitterChangedProcessed := False;
    FEditDonationID := -1;
    FLinkedGiftID := 0;
    FRestrictedFieldList.Clear;  //12/10/2013 RRR D-04530
    FIsBusyOutOfProcess := False;
    Self.Caption := 'Post Donations';
    FSuppLabel := 'Suppression';
    FChapter1Label := 'Chapter1:';
    FChapter2Label := 'Chapter2:';
    FTotalAmount := 0;
    FNextFlagID := 0;
    FNextInterestID := 0;
    FNextSuppID := 0;
    // 7/21/2014 gms d-04866 DEPRECATED no longer needed; was only used in OnCanFocusRecord
    //   no longer used there
    // FLastDonID := 0;   //07/14/2014 RRR D-04955

    pnlStatus.Caption := '';
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ResetForm');
  gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.ResetForm';
  end;
end;

procedure TfrmBatchGiftProcessing.LoadFormSettings();
var
  i, aWidth: Integer;
  aColumnName: string;
  aTmpStrList: TStringList;
  aGridColumn: TcxGridDBColumn;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LoadFormSettings');
  try
    spinAutoCommit.Value := GetIniInteger(gPidiDDGlobal.DonorDirectIniFileName, 'BatchGiftProcessing', 'AutoCommit', 0);

    grdMainTableView.FullINIFileName := gPidiDDGlobal.DonorDirectGridIniDir + 'frmBatchGiftProcessing_grdMain.ini';

    aTmpStrList := nil;
    try
      aTmpStrList := TStringList.Create();

      GetIniValueList(gPidiDDGlobal.DonorDirectGridIniDir + 'frmBatchGiftProcessing_grdMain.ini',
         'grdMainTableView', 'ColumnWidths', aTmpStrList);

      for i := 0 to aTmpStrList.Count - 1 do begin
        aColumnName := aTmpStrList.Names[i];
        aWidth := StrToInt(aTmpStrList.ValueFromIndex[i]);

        aGridColumn := TcxGridDBColumn(Self.FindComponent(aColumnName));
        if aGridColumn <> nil then begin
          aGridColumn.Width := aWidth;
        end;
      end;
    finally
      aTmpStrList.Free;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LoadFormSettings');
  end;
end;

procedure TfrmBatchGiftProcessing.SaveFormSettings();
var
  i: Integer;
  aTmpStrList: TStringList;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SaveFormSettings');
  try
    SetIniInteger(gPidiDDGlobal.DonorDirectIniFileName, 'BatchGiftProcessing', 'AutoCommit', spinAutoCommit.Value);

    aTmpStrList := nil;
    try
      aTmpStrList := TStringList.Create();
      for i := 0 to grdMainTableView.ColumnCount - 1 do begin
        aTmpStrList.Add(grdMainTableView.Columns[i].Name + '=' + IntToStr(grdMainTableView.Columns[i].Width));
      end;

      SetIniValueList(gPidiDDGlobal.DonorDirectGridIniDir + 'frmBatchGiftProcessing_grdMain.ini',
         'grdMainTableView', 'ColumnWidths', aTmpStrList);
    finally
      aTmpStrList.Free;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SaveFormSettings');
  end;
end;

procedure TfrmBatchGiftProcessing.DoProcessReadOnlyFormSetting;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoProcessReadOnlyFormSetting');
  try
    inherited;

    if Self.FormReadOnly = True then begin
      SetDevExpressGridDataAttr(grdMainTableView, dmReadOnly);
      mnuAttachTrackingRecord.Enabled := False;
      mnuAttachVehicle.Enabled := False;
      mnuDetachVehicle.Enabled := False;
      mnuReallocateSustainerExtraAmount.Enabled := False;
    end else begin
      SetDevExpressGridDataAttr(grdMainTableView, dmReadWrite);
      mnuAttachTrackingRecord.Enabled := True;
      mnuAttachVehicle.Enabled := True;
      mnuDetachVehicle.Enabled := True;
      mnuReallocateSustainerExtraAmount.Enabled := True;

      SetRestrictedEditingColumn;
    end;

    // 11/10/2014 gms d-05210 Set initial to disabled. Procedure puOptionsPopup will control Enabled
    mnuAttachPledge.Enabled := False;
    mnuDetachPledge.Enabled := False;
//  mnuWriteOff.Enabled := False;   //02/24/2015 RRR D-05313

// 08/20/2013 RRR B-04715
    FCanEditGLStatus := dmPidiCoreClient.cdsRestrictionAction.Locate('Form_Identifier; Component_Name; Properties',
         VarArrayOf(['NoForm', 'NoComp', 'CANEDITGLSTATUS']), [loCaseInsensitive]);
  finally
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoProcessReadOnlyFormSetting');
  end;
end;

procedure TfrmBatchGiftProcessing.ApplyCustomOptionsToGrid;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ApplyCustomOptionsToGrid');
  try
    // for use by client forms to add custom columns to grid
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ApplyCustomOptionsToGrid');
  end;
end;

procedure TfrmBatchGiftProcessing.ApplyOptionsToGrid(pTurnOffEvent: Boolean);
var
  aLcv: Integer;
  aIncludeTax, aSaveEnabled: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ApplyOptionsToGrid');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.ApplyOptionsToGrid';
  try
    aIncludeTax := False;
    // DataSet Events.
    // 3/12/2013 gms some callers already turn off event, in that case, don't turn off/on events
    if pTurnOffEvent then begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := True;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.DisableControls;
    end;
    aSaveEnabled := grdMain.Enabled;
    grdMain.Enabled := False;
    try
      // Hide all columns to start with.
      for aLcv := 0 to grdMainTableView.ColumnCount - 1 do begin
        if (grdMainTableView.Columns[aLcv].Visible = True) then begin
          grdMainTableView.Columns[aLcv].Visible := False;
        end;
      end;

      grdMainTableViewAccountId.Visible := True;

      if FShowAltID then begin
        grdMainTableViewAltID.Visible := True;
        grdMainTableViewAltID.Caption := FAltIDFieldName;
      end;

      grdMainTableViewFullName.Visible := True;

      if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_PROGRAM)) or
         (not IsEmptyStr(DmGiftProcessing.DmDonation.GiftProcOrigPrg)) then begin
        grdMainTableViewPrgDesc.Visible := True;
        grdMainTableViewPrg.Visible := True;
      end;

      grdMainTableViewMcd.Visible := True;
      grdMainTableViewMcd.Caption := DmGiftProcessing.DmDonation.GiftProcMcdCaption;

      grdMainTableViewAmount.Visible := True;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_FLAGS) then begin

        grdMainTableViewFlag_List.Visible := True;
        grdMainTableViewInterest_List.Visible := True;
        if GetConfigPointYesNoBoolean('ACCT', 'Suppression Active') = True then begin
          grdMainTableViewSuppress_List.Visible := True;
        end;
        if GetConfigPointYesNoBoolean('ACCT', 'Activist Active') = True then begin
          grdMainTableViewActivist_List.Visible := True;
        end;

        // Set ReadOnly / Visible based on security restriction

        // =============================== Set Restriction Flags  ==============================
        if dmPidiCoreClient.cdsRestrictionAction.Locate('Form_Identifier; Component_Name; Properties',
           VarArrayOf(['frmMasterViewClientFrm', 'TabFlag', 'H']), [loCaseInsensitive]) then begin
          grdMainTableViewFlag_List.Visible := False;
        end;
        if dmPidiCoreClient.cdsRestrictionAction.Locate('Form_Identifier; Component_Name; Properties',
           VarArrayOf(['frmTabFlagClient', 'NoComp', 'R']), [loCaseInsensitive]) then begin
          grdMainTableViewFlag_List.Properties.Buttons[0].Visible := False;
        end;

        // ============================== Set Restriction Interest ==============================
        if dmPidiCoreClient.cdsRestrictionAction.Locate('Form_Identifier; Component_Name; Properties',
           VarArrayOf(['frmMasterViewClientFrm', 'TabInterest', 'H']), [loCaseInsensitive]) then begin
          grdMainTableViewInterest_List.Visible := False;
        end;
        if dmPidiCoreClient.cdsRestrictionAction.Locate('Form_Identifier; Component_Name; Properties',
           VarArrayOf(['frmTabInterestClient', 'NoComp', 'R']), [loCaseInsensitive]) then begin
          grdMainTableViewInterest_List.Properties.Buttons[0].Visible := False;
        end;

        // ============================== Set Restriction Suppress ==============================
        if dmPidiCoreClient.cdsRestrictionAction.Locate('Form_Identifier; Component_Name; Properties',
           VarArrayOf(['frmMasterViewClientFrm', 'TabSuppress', 'H']), [loCaseInsensitive]) then begin
          grdMainTableViewSuppress_List.Visible := False;
        end;
        if dmPidiCoreClient.cdsRestrictionAction.Locate('Form_Identifier; Component_Name; Properties',
           VarArrayOf(['frmTabSuppressClient', 'NoComp', 'R']), [loCaseInsensitive]) then begin
          grdMainTableViewSuppress_List.Properties.Buttons[0].Visible := False;
        end;
        // ============================== Set Restriction Activist ==============================
        if dmPidiCoreClient.cdsRestrictionAction.Locate('Form_Identifier; Component_Name; Properties',
           VarArrayOf(['frmMasterViewClientFrm', 'TabActivist', 'H']), [loCaseInsensitive]) then begin
          grdMainTableViewActivist_List.Visible := False;
        end;
        if dmPidiCoreClient.cdsRestrictionAction.Locate('Form_Identifier; Component_Name; Properties',
           VarArrayOf(['frmTabActivistClient', 'NoComp', 'R']), [loCaseInsensitive]) then begin
          grdMainTableViewActivist_List.Properties.Buttons[0].Visible := False;
        end;

        dmPidiCoreClient.cdsRestrictionAction.Filtered := True;
      end;

      if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_DONATION_TYPE)) or
         (FAlwaysShowDonType = True) or (DmGiftProcessing.DmDonation.CreditCardBatch = True) or
         (DmGiftProcessing.DmDonation.EFTBatch = True) then begin
        grdMainTableViewDonType.Visible := True;
      end;

      // 03/29/2009 jmp DD-1143 New EFT functionality.
      if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_CC_EFT_INFO)) or
         DmGiftProcessing.DmDonation.CreditCardBatch or DmGiftProcessing.DmDonation.EFTBatch then begin
        grdMainTableViewCCInfo.Visible := True;
      end;

      if (gPidiEPSubSys.IsThirdPartyCCMode) and (DmGiftProcessing.DmDonation.CreditCardBatch) then begin
        grdMainTableViewCCLastApproval.Visible := True;
        grdMainTableViewCCLastApproval.Caption := 'CC Status';
      end;

      // 03/29/2009 jmp DD-1143 New EFT functionality.
      if (gPidiEPSubSys.IsThirdPartyEFTMode) and (DmGiftProcessing.DmDonation.EFTBatch) then begin
        grdMainTableViewCCLastApproval.Visible := True;
        grdMainTableViewCCLastApproval.Caption := 'EFT Status';
      end;

      if gPidiDDGlobal.ClientAcronym <> 'CARE' then begin
        if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_CHECK_NO)) then begin
          grdMainTableViewCheckNumber.Visible := True;
        end;

        if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_CHECK_DATE) then begin
          grdMainTableViewCheckDate.Visible := True;
        end;
      end;

      // 04/29/2010 jmp D-02002 New feature.
      mnuReallocateSustainerExtraAmount.Visible := False;

      // 10/31/2014 gms b-05053 only show vehicle menu items if client uses vehicle manager
      if (GetConfigPointYesNoBoolean('VDM', 'Active') = True) then begin
        mnuAttachVehicle.Visible := True;
        mnuDetachVehicle.Visible := True;
      end else begin
        mnuAttachVehicle.Visible := False;
        mnuDetachVehicle.Visible := False;
      end;


      // GiftProcessingOnPrgChangeDataEventCallBack(); DEPRECATED 10/14/2013 see below
      // 10/3/2013 gms d-04386 flag to indicate batch has sustainer donations
      //  in this procedure only set the column visibility, don't edit the fields
      if DmGiftProcessing.DmDonation.GiftProcAnySustainerDonations then begin
        ShowPledgeColumns;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_GIFT_TYPE) then begin
        grdMainTableViewCategoryDesc.Visible := True;
      end;

      if FEditDonation then begin
        grdMainTableViewFec.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_GIVING_LEVEL) then begin
        grdMainTableViewGivingLevel.Visible := True;
      end;

      // 7/15/10 pp-3580 SN Add restriction code to Quickpost
      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_RESTRICTION_CODE) then begin
        grdMainTableViewRestrictionDesc.Visible := True;
      end;

      // 6/6/2013 gms If the below config point is set to either tie account code to mail or fund code,
      //   always display the account code column when displaying the fund code column and vice versa
      if (GetConfigPointStr('DNTPRC', 'Default GL Account Code From') <> 'None') then begin
        if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_FUND_CODE)) or
           DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_ACCOUNT_CODE) then begin
          grdMainTableViewFundCode.Visible := True;
          grdMainTableViewAcctCode.Visible := True;
          if (not DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_FUND_CODE)) then begin
            DmGiftProcessing.DmDonation.GiftProcSelectedUserOptions.Add(OPTION_SHOW_FUND_CODE);
          end;
          if (not DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_ACCOUNT_CODE)) then begin
            DmGiftProcessing.DmDonation.GiftProcSelectedUserOptions.Add(OPTION_SHOW_ACCOUNT_CODE);
          end;
        end;
      end else begin
        if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_FUND_CODE)) then begin
          grdMainTableViewFundCode.Visible := True;
        end;
        if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_ACCOUNT_CODE)) then begin
          grdMainTableViewAcctCode.Visible := True;
        end;
      end;

      if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_CHAPTER_CODE)) then begin
        grdMainTableViewChapter.Visible := True;
      end;

      if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_CHAPTER_DESC)) then begin
        grdMainTableViewChapterDesc.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_ACK_FIELDS) then begin
        grdMainTableViewAckCode.Visible := True;
        grdMainTableViewAckDate.Visible := True;
        grdMainTableViewAckStatus.Visible := True;
        grdMainTableViewNoAck.Visible := True;
        grdMainTableViewNoCalc.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_IR_ORDER_OPTION) then begin
        grdMainTableViewOrderIr.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_MATCHING_STATUS) then begin
        grdMainTableViewMatchingStatusDesc.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_PHONE) then begin
        grdMainTableViewHomePhone.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_EMAIL) then begin
        grdMainTableViewEmailAddress.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_ITEM_DESCR) or
         FAnyVehicleDons then begin
        grdMainTableViewItemDesc.Visible := True;
        // 11/4/2014 gms b-05053 after making column visible, add option to selected list if not already chosen
        if (not DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_ITEM_DESCR)) then begin
          DmGiftProcessing.DmDonation.GiftProcSelectedUserOptions.Add(OPTION_SHOW_ITEM_DESCR);
        end;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_TAX_INFO) then begin
        grdMainTableViewTickerSymbol.Visible := True;
        grdMainTableViewNumberShares.Visible := True;
        grdMainTableViewTaxDate.Visible := True;
        grdMainTableViewLowValue.Visible := True;
        grdMainTableViewHighValue.Visible := True;
        aIncludeTax := True;
      end else if FAlwaysShowTaxDate then begin
        grdMainTableViewTaxDate.Visible := True;
      end;

      if aIncludeTax = True then begin
        grdMainTableViewTaxValue.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_VENDOR_ID) then begin
        grdMainTableViewVendorId.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_PREMIUMS) then begin
        grdMainTableViewPremium_List.Visible := True;
        (* 3/13/2014 gms d-04707 premium column always read only but focusable to show the lower grid
        if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Premium')) = True then begin
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPremium, False);
        end else begin
        *)
        grdMainTableViewPremium_List.Options.Editing := False;
        grdMainTableViewPremium_List.Options.Focusing := True;
        // end;
      end;

      // 6/10/2013 gms show Split Gifts column if the batch or donation has records in split_donation table
      //   this allows access to batches with split gifts even if configuration point does not allow split gifts
      //   thus, user can access old batches with split gifts
      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_SPLIT_GIFT) or
        (DmGiftProcessing.DmDonation.cdsSplitDonation.Active and (DmGiftProcessing.DmDonation.cdsSplitDonation.IsEmpty = False)) then begin
        grdMainTableViewSplitGift.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_SOFT_CREDIT) then begin
        grdMainTableViewSoftCredit.Visible := True;
      end;

      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_SPLIT_DONATION) then begin
        grdMainTableViewSplitGift2.Visible := True;
      end;

      // 06/20/08 jmp For new Event Group Functionality.
      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_EVENTS) then begin
        if (gPidiDDGlobal.ClientAcronym = 'CCFA') or (gPidiDDGlobal.ClientAcronym = 'DEMO') then begin
          grdMainTableViewEvent_Name.Visible := True;
          grdMainTableViewEvent_PurchaserName.Visible := True;
          grdMainTableViewEvent_GuestName.Visible := True;
          grdMainTableViewEvent_DonationType.Visible := True;
          grdMainTableViewEvent_DonationSubType.Visible := True;
        end else begin
          grdMainTableViewGroupDonations.Visible := True;
        end;
      end;

      // added 10/24/08 gms dd-439 new Notes functionality
      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_NOTES) then begin
        grdMainTableViewNotes.Visible := True;
      end;

      // 01/12/2009 jmp DD-773 new Solicitor functionality.
      // 02/02/2009 jmp DD-931. Use pick dialog.
      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_SOLICITOR) then begin
        grdMainTableViewSolicitorList.Visible := True;
      end;

      //08/20/2013 RRR B-04715    Moved from UNICEF
      if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_GL_STATUS)) then begin
        grdMainTableViewGLStatus.Visible := True;
      end;

      // For Adjustment Mode
      if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
        grdMainTableViewAdjCode.Visible := True;
      end;

      // Allow clients to add custom columns
      ApplyCustomOptionsToGrid;
    finally
      // DataSet Events.
      // 3/12/2013 gms some callers already turn off event, in that case, don't turn off/on events
      if pTurnOffEvent then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := False;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.EnableControls;
      end;
      grdMain.Enabled := aSaveEnabled;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ApplyOptionsToGrid');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.ApplyOptionsToGrid';
  end;
end;

procedure TfrmBatchGiftProcessing.SetRestrictedEditingColumn();
(******************************************************************************
  1/2/2015 gms d-05250 any changes made to this procedure may also need to be
     made to SetRestrictedEditingColumn in SplitDonationFrm and SplitGiftFrm
*******************************************************************************)
var
  i: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetRestrictedEditingColumn');
  try
    if (DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes = []) then begin
      // ALL EDITABLE
      // Make all the fields ReadOnly = False
      // NOTE: SOME COLUMNS ARE SUPPOSED TO STAY READONLY. ADD THEM TO THE "OR" CLAUSE
      // 2/22/2013 gms added Amount column to exceptions below.  Read only status of amount
      //    column is set in ApplyOptionsToGrid
      for i := 0 to grdMainTableView.ColumnCount - 1 do begin
        if not((grdMainTableView.Columns[i] = grdMainTableViewFullName) or
           (grdMainTableView.Columns[i] = grdMainTableViewPrg) or
           (grdMainTableView.Columns[i] = grdMainTableViewCCInfo) or
           (grdMainTableView.Columns[i] = grdMainTableViewDonType) or
           (grdMainTableView.Columns[i] = grdMainTableViewAmount)) then begin
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.Columns[i], False);
        end;
      end;

      // 9/20/2013 gms tk-12639 set properties.readonly to True for flags, etc list so
      //   user can't type in column.  But clicking ellipses still works
      grdMainTableViewFlag_List.Properties.ReadOnly := True;
      grdMainTableViewInterest_List.Properties.ReadOnly := True;
      grdMainTableViewSuppress_List.Properties.ReadOnly := True;
      grdMainTableViewActivist_List.Properties.ReadOnly := True;
      // 12/23/2013 gms d-04331 The solicitor list column itself is read only; must use
      //   ellipses to set solicitors
      grdMainTableViewSolicitorList.Properties.ReadOnly := True;

      if not FCanEditGLStatus then begin    // 08/20/2013 RRR B-04715    Moved from Unicef
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewGLStatus, True);
      end;

      if (DmGiftProcessing.DmDonation.CreditCardBatch or DmGiftProcessing.DmDonation.EFTBatch) then begin
//      grdMainTableViewDonType.Options.Editing := False;  //07/31/2014 RRR D-05009
        // Need to be able to click this column. grdMainTableViewDonType.Options.Editing := False;
        grdMainTableViewDonType.Options.Focusing := True;
        // Amount column is read only for CC or EFT batch and third party cc or eft, amount set in lower grid
        if ((DmGiftProcessing.DmDonation.CreditCardBatch) and (gPidiEPSubSys.IsThirdPartyCCMode) and
           (gPidiEPSubSys.CreditCardProcessingMode <> 'PAYPAL')) or
           ((DmGiftProcessing.DmDonation.EFTBatch) and (gPidiEPSubSys.IsThirdPartyEFTMode) and
           (gPidiEPSubSys.EFTProcessingMode <> 'PAYPAL')) then begin
          grdMainTableViewDonType.Options.Editing := False;    //07/31/2014 RRR D-05009
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, True);
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewExtraAmount, True);
        end else begin
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewDonType, False);  //07/31/2014 RRR D-05009
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, False);
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewExtraAmount, False);
        end;
      end else begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewDonType, False);
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, False);
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewExtraAmount, False);
      end;

    end else if DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremAccountPeriodClosed,
       gpremPostedToGlClosed, gpremBatchMngClosed] <> [] then begin
      // GL CLOSED


//03/28/2014 RRR D-04748  Make sure columns set to Read Only conform with columns
//                        listed in message in TdmDonation.cdsGiftProcessingBeforeEdit
//---------------------------------------------------------------------------------------
{     for i := 0 to grdMainTableView.ColumnCount - 1 do begin
        if not((grdMainTableView.Columns[i] = grdMainTableViewSoftCredit) or
           (grdMainTableView.Columns[i] = grdMainTableViewCategoryDesc) or
           (grdMainTableView.Columns[i] = grdMainTableViewSplitGift) or
           (grdMainTableView.Columns[i] = grdMainTableViewSplitGift2) or
           (grdMainTableView.Columns[i] = grdMainTableViewMatchingStatusDesc)) then begin
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.Columns[i], True);
        end;
      end;   }


      for i := 0 to grdMainTableView.ColumnCount - 1 do begin
        if (grdMainTableView.Columns[i] = grdMainTableViewAccountID) or
           (grdMainTableView.Columns[i] = grdMainTableViewPrg) or
           (grdMainTableView.Columns[i] = grdMainTableViewPrgDesc) or
           (grdMainTableView.Columns[i] = grdMainTableViewMcd) or
           (grdMainTableView.Columns[i] = grdMainTableViewDonType) or
           (grdMainTableView.Columns[i] = grdMainTableViewAmount) or
           (grdMainTableView.Columns[i] = grdMainTableViewChapter) or
           (grdMainTableView.Columns[i] = grdMainTableViewFundCode) or
           (grdMainTableView.Columns[i] = grdMainTableViewAcctCode) or
           (grdMainTableView.Columns[i] = grdMainTableViewDepartment) or
           (grdMainTableView.Columns[i] = grdMainTableViewTaxValue) then begin
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.Columns[i], True);
        end;
      end;
      // Need to be able to focus the column to change lower grids, but not change the value
      grdMainTableViewCategoryDesc.Options.ShowEditButtons := isebNever;
    end else if DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremCCEFTClosed] <> [] then begin
      // CC BATCH CLOSED


 {   for i := 0 to grdMainTableView.ColumnCount - 1 do begin
        if not((grdMainTableView.Columns[i] = grdMainTableViewSoftCredit) or
           (grdMainTableView.Columns[i] = grdMainTableViewCategoryDesc) or
           (grdMainTableView.Columns[i] = grdMainTableViewMatchingStatusDesc) or
           (grdMainTableView.Columns[i] = grdMainTableViewMcd) or
           (grdMainTableView.Columns[i] = grdMainTableViewFundCode) or
           (grdMainTableView.Columns[i] = grdMainTableViewAcctCode) or
           (grdMainTableView.Columns[i] = grdMainTableViewChapter) or
           (grdMainTableView.Columns[i] = grdMainTableViewChapterDesc) or
           (grdMainTableView.Columns[i] = grdMainTableViewSplitGift) or
           (grdMainTableView.Columns[i] = grdMainTableViewSplitGift2) or
           (grdMainTableView.Columns[i] = grdMainTableViewDepartment)) then begin
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.Columns[i], True);
        end;
      end;         }


      for i := 0 to grdMainTableView.ColumnCount - 1 do begin
        if (grdMainTableView.Columns[i] = grdMainTableViewAccountID) or
           (grdMainTableView.Columns[i] = grdMainTableViewPrg) or
           (grdMainTableView.Columns[i] = grdMainTableViewPrgDesc) or
           (grdMainTableView.Columns[i] = grdMainTableViewAmount) then begin
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.Columns[i], True);
        end;
      end;
//-------------------------------------------------------------------------------------------------
      
      // Need to be able to focus the column to change lower grids, but not change the value
      grdMainTableViewCategoryDesc.Options.ShowEditButtons := isebNever;
    end else if (DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes <=
       [gpremAccountPeriodClosed, gpremPostedToGlClosed, gpremBatchMngClosed, gpremCCEFTClosed]) = False then begin
      // GiftProcRestrictedEditingModes contains a new mode not in the below set on right side, then error
      gPidiDDGlobal.ErrorHandler.Reset;
      gPidiDDGlobal.ErrorHandler.Add('GiftProcRestrictedEditingMode not supported. Please contact Blackbaud technical support.', etValidation);
      gPidiDDGlobal.ErrorHandler.HandleErrors;
    end;

//  Build a list of Read Only Fields
    FRestrictedFieldList.Clear;
    for i := 0 to grdMainTableView.ColumnCount - 1 do begin
      if grdMainTableView.Columns[i].Options.Editing = False then begin
        FRestrictedFieldList.AddObject(grdMainTableView.Columns[i].DataBinding.FieldName, grdMainTableView.Columns[i]);
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetRestrictedEditingColumn');
  end;
end;

procedure TfrmBatchGiftProcessing.DoSearch();
var
  aSaveCursor: TCursor;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoSearch');
  try
    inherited;

    aSaveCursor := Screen.Cursor;
    Screen.Cursor := crHourGlass;
    LockWindowUpdate(Self.Handle);
    try
      FWorkInProgress := True;
      FIsBusyOutOfProcess := True;
      // D-04295 TWM 09/12/2013 turn off and on menus
      if (DmGiftProcessing.DataModuleMode = dmmGiftProcessing) and (gPidiDDGlobal.MainMenuButtonClose <> nil) then begin
        gPidiDDGlobal.MainMenuButtonClose.Enabled := False;
      end;
      if (DmGiftProcessing.DataModuleMode = dmmGiftProcessing) and (gPidiDDGlobal.MainFormCloseTabMenuItem <> nil) then begin
        gPidiDDGlobal.MainFormCloseTabMenuItem.Enabled := False;
      end;
      SetUpperLevelMenuEnabled(gPidiDDGlobal.MainMenu, False);

      ValidateBatchStatus(False);   //02/20/2014 RRR D-04700

      // Perform the search.
      dsGiftProcessing.DataSet := DmGiftProcessing.DmDonation.cdsGiftProcessing;
      DoBatchSearch();

      // Check the response.
      if (GoodResp = False) then begin
        Exit;
      end else begin
        // Disable search buttons.
        btnSearch.Enabled := False;
        btnCancelBatch.Enabled := True;
        btnOptionsTop.Enabled := True; // Always true
        btnOptionsLower.Visible := False;
        btnPickBatch.Enabled := False;
        txtBatch.Enabled := False;
        dtpBatchDate.Enabled := False;
        gbxDonations.Caption := '&Gifts';
        btnViewBatch.Enabled := True;
        btnViewRecord.Enabled := True;
        grdMain.Enabled := True;
        navMain.Enabled := True;
 //  moved above,  doing it here was wiping out combo box properites
//      dsGiftProcessing.DataSet := DmGiftProcessing.DmDonation.cdsGiftProcessing;

        // Set batch type.
        SetBatchLabel();

        // Do auto-insert gift, or auto cancel.
        if Self.FormReadOnly = False then begin
          if (DmGiftProcessing.DmDonation.cdsGiftProcessing.RecordCount = 0) and
             (DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremAccountPeriodClosed,
             gpremPostedToGlClosed, gpremBatchMngClosed, gpremCCEFTClosed] = []) then begin
            // 7/2/2014 gms d-04952 end busy phase so that account search can be initiated on insert
            //   if the option is so set
            FIsBusyOutOfProcess := False;
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Insert;
          end else if DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsEdit then begin  //for some unknown reason, the Response CDS is sometimes put in edit State
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Cancel; //put back in browse State      RR
          end;
        end;

        // Focus the right column.
        if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsBrowse) then begin
          grdMainTableViewAccountId.Focused := True;
        end else begin
          // Set field position.
          // 6/19/2014 gms b-05611 not needed; if insert afterinsertcallback calls this
          //  ThreadedMoveToNextField;
        end;
      end;
    finally
      FWorkInProgress := False;
      FIsBusyOutOfProcess := False;

      if (DmGiftProcessing.DataModuleMode = dmmGiftProcessing) and (gPidiDDGlobal.MainMenuButtonClose <> nil) then begin
        gPidiDDGlobal.MainMenuButtonClose.Enabled := True;
      end;
      if (DmGiftProcessing.DataModuleMode = dmmGiftProcessing) and (gPidiDDGlobal.MainFormCloseTabMenuItem <> nil) then begin
        gPidiDDGlobal.MainFormCloseTabMenuItem.Enabled := True;
      end;
      SetUpperLevelMenuEnabled(gPidiDDGlobal.MainMenu, True);

      // Call here to set some readonly values.
      grdMainTableViewFocusedRecordChanged(nil, nil, nil, False);

      LockWindowUpdate(0);
      Screen.Cursor := aSaveCursor;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoSearch');
  end;
end;

procedure TfrmBatchGiftProcessing.DoBatchSearch();
var
  aTmpStr: string;
  aSaveDonorDonIDMatchingGiftChange: TFieldNotifyEvent;
  aSaveDonorAcctIDMatchingGiftChange: TFieldNotifyEvent;
  aSaveCorpDonIDMatchingGiftChange: TFieldNotifyEvent;
  aSaveCorpAcctIDMatchingGiftChange: TFieldNotifyEvent;

//02/24/2014 RRR D-04705 TK-13724 ----------------------
  aSaveDonorDonIDMatchedGiftChange: TFieldNotifyEvent;
  aSaveDonorAcctIDMatchedGiftChange: TFieldNotifyEvent;
  aSaveCorpDonIDMatchedGiftChange: TFieldNotifyEvent;
  aSaveCorpAcctIDMatchedGiftChange: TFieldNotifyEvent;
///-----------------------------------------------------

begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoBatchSearch');
  try
    FNoSave := False;
    // 10/24/2014 gms d-05138 DEPRECATED no longer needed; LockBatch will check the lock status on the
    //   batch log record itself.
    // FBatchIsLocked := False;
    FAnySplitDonations := False;

    // Trim the fields.
    txtBatch.Text := SysUtils.Trim(txtBatch.Text);

    // Validate the batch.
    if IsEmptyStr(txtBatch.Text) then begin
      gPidiDDGlobal.ErrorHandler.Reset;
      gPidiDDGlobal.ErrorHandler.Add('Please enter a Batch Number.', etValidation);
      gPidiDDGlobal.ErrorHandler.HandleErrors;
      GoodResp := False;
      if (txtBatch.Showing) and (txtBatch.CanFocus) then begin
        txtBatch.SetFocus;
      end;
      Exit;
    end;

    // Validate the batch date.
    if IsEmptyStr(dtpBatchDate.Text) then begin
      gPidiDDGlobal.ErrorHandler.Reset;
      gPidiDDGlobal.ErrorHandler.Add('Please enter a Batch Date.', etValidation);
      gPidiDDGlobal.ErrorHandler.HandleErrors;
      GoodResp := False;
      if (txtBatch.Showing) and (txtBatch.CanFocus) then begin
        dtpBatchDate.SetFocus;
      end;
      Exit;
    end;

    if not IsValidDate(FormatDateTime('yyyymmdd', dtpBatchDate.Date)) then begin
      gPidiDDGlobal.ErrorHandler.Reset;
      gPidiDDGlobal.ErrorHandler.Add('Please enter a valid date.', etValidation);
      gPidiDDGlobal.ErrorHandler.HandleErrors;
      GoodResp := False;
      if (txtBatch.Showing) and (txtBatch.CanFocus) then begin
        dtpBatchDate.SetFocus;
      end;
      Exit;
    end;

    // Check To See If the Batch Exists
    if DmGiftProcessing.DmDonation.DonationUtils.IsValidBatch(txtBatch.Text, dtpBatchDate.Date) = False then begin
      gPidiDDGlobal.ErrorHandler.Reset;
      gPidiDDGlobal.ErrorHandler.Add('Batch does not exist. Unable to continue.', etValidation);
      gPidiDDGlobal.ErrorHandler.HandleErrors;
      GoodResp := False;
      Exit;
    end;

    FSkipValidation := True;
    if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert,dsEdit] then begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Cancel;
    end;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.IndexName := 'MainIndex';

    FBatchDateStr := FormatDateTime('yyyymmdd', dtpBatchDate.Date);
    aTmpStr := txtBatch.Text + '^' + FBatchDateStr;
    // 01/05/2009 jmp Added new LinkedGiftID  - This tells the middle tier to send down all splits
    if FEditDonation then begin
      aTmpStr := aTmpStr + '^' + IntToStr(FEditDonationID) + '^' + IntToStr(FLinkedGiftID);
    end;

    DmGiftProcessing.DmAccount.cdsMaster.ValidateWithMask := False;    //skip ZIP edit

    DmGiftProcessing.DmDonation.GiftProcKeyViolationBatch := txtBatch.Text;
    DmGiftProcessing.DmDonation.GiftProcKeyViolationBDate := dtpBatchDate.Date;



    dmGiftProcessing.LoadBatch(aTmpStr);

    // Reset in case of partial population of data.
    if (DmGiftProcessing.DmDonation.GiftProcDisplayKeyViolation = True) and (GoodResp = False) then begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Close;
      Self.ResetForm();
      DmGiftProcessing.CancelAll();
      DmGiftProcessing.ResetAllDataSets();
//    DmGiftProcessing.DmDonation.cdsGiftProcessing.CreateDataSet();  //01/15/2014 RRR D-04575 - Already called by ResetAllDataSets
      Exit;
    end;

    // Validate user has security to see this batch.
    if (GoodResp = True) and (UserCanSeeThisBatch = False) then begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Close;
      gPidiDDGlobal.ErrorHandler.Reset;
      gPidiDDGlobal.ErrorHandler.Add('User is not Authorized to view this Batch. Unable to Continue.', etValidation);
      gPidiDDGlobal.ErrorHandler.HandleErrors;

      GoodResp := False;
      if (txtBatch.Showing) and (txtBatch.CanFocus) then begin
        txtBatch.SetFocus;
      end;
      Exit;
    end;

    // Validate there was a good response.
    if GoodResp = False then begin
      if (txtBatch.Showing) and (txtBatch.CanFocus) then begin
        txtBatch.SetFocus;
      end;
      Exit;
    end;

    DmGiftProcessing.DmAccount.cdsMaster.ValidateWithMask := True;

    try
      // do we really need to turn off events or just set a mode
      // 9/5/2013 gms d-04321 TurnOff/TurnOn not needed here.  The only place we might need it
      //  is inside FillDonationGrid.  FillDonationGrid is already turning off events and we
      //  not need it there either.
      // TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
      FBatchDate := DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('bdate').AsDateTime;

      // 10/24/2014 gms d-05138 LockBatch will check batch's lock status;
      //   if already locked, form will be opened in read only mode
      LockBatch(True);
      SetAltIDParams;

      // *** REFACTOR ME PLEASE *****
      DmGiftProcessing.DmDonation.InitializeBatchSettings;

      // 6/18/2010 gms pp-3592 append soft credit matching records to matching gift DataSet
     //   must append before filldonationgrid so that donation line field is added properly
      aSaveDonorDonIDMatchingGiftChange := DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Donor_DonID').OnChange;
      aSaveDonorAcctIDMatchingGiftChange := DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Donor_AcctID').OnChange;
      aSaveCorpDonIDMatchingGiftChange := DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Corp_DonID').OnChange;
      aSaveCorpAcctIDMatchingGiftChange := DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Corp_AcctID').OnChange;
      DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Donor_DonID').OnChange := nil;
      DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Donor_AcctID').OnChange := nil;
      DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Corp_DonID').OnChange := nil;
      DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Corp_AcctID').OnChange := nil;
      TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsMatchingGift);

      //02/24/2014 RRR D-04705 TK-13724 ----------------------
      aSaveDonorDonIDMatchedGiftChange := DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Donor_DonID').OnChange;
      aSaveDonorAcctIDMatchedGiftChange := DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Donor_AcctID').OnChange;
      aSaveCorpDonIDMatchedGiftChange := DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Corp_DonID').OnChange;
      aSaveCorpAcctIDMatchedGiftChange := DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Corp_AcctID').OnChange;
      DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Donor_DonID').OnChange := nil;
      DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Donor_AcctID').OnChange := nil;
      DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Corp_DonID').OnChange := nil;
      DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Corp_AcctID').OnChange := nil;
      TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsMatchedGift);
      //----------------------------------------------------------------
      try
//02/24/2014 RRR D-04705 TK-13724  -  This line moved from TdmGiftProcessing.LoadBatch
        DmGiftProcessing.DmDonation.GiftProcFillMgfDonLine;
        AppendDataSet(DmGiftProcessing.DmDonation.cdsSCMatchingGift, DmGiftProcessing.DmDonation.cdsMatchingGift);
      finally
        DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Donor_DonID').OnChange := aSaveDonorDonIDMatchingGiftChange;
        DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Donor_AcctID').OnChange := aSaveDonorAcctIDMatchingGiftChange;
        DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Corp_DonID').OnChange := aSaveCorpDonIDMatchingGiftChange;
        DmGiftProcessing.DmDonation.cdsMatchingGift.FieldByName('Corp_AcctID').OnChange := aSaveCorpAcctIDMatchingGiftChange;
        TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsMatchingGift);

      //02/24/2014 RRR D-04705 TK-13724 ----------------------
        DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Donor_DonID').OnChange := aSaveDonorDonIDMatchedGiftChange;
        DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Donor_AcctID').OnChange := aSaveDonorAcctIDMatchedGiftChange;
        DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Corp_DonID').OnChange := aSaveCorpDonIDMatchedGiftChange;
        DmGiftProcessing.DmDonation.cdsMatchedGift.FieldByName('Corp_AcctID').OnChange := aSaveCorpAcctIDMatchedGiftChange;
        TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsMatchedGift);
      //------------------------------------------------------
      end;

      // *** REFACTOR ME PLEASE (ASTA SQL, VIEW, ETC - BIG DEAL) *****
      FillDonationGrid;

      //  This has been refactored to just display not Calc
      DmGiftProcessing.DmDonation.GiftProcCalcTotals();
      DisplayQtys;

      FSkipValidation := False;

//******************************************************************************
//     Set Edit Restriction based on statu of batch
//******************************************************************************
      DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes := [];

      if (DmGiftProcessing.DmDonation.cdsBatchLog.RecordCount > 0) then begin
        if IsEmptyField(DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Posted_To_GL')) = False then begin
          DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes :=
             DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes + [gpremPostedToGlClosed];
        end;
        if DmGiftProcessing.DmDonation.IsBatchSoftClosed() = True then begin
          DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes :=
             DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes + [gpremBatchMngClosed];
        end;
        if DmGiftProcessing.DmDonation.IsAccountPeriodClosed(DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Accounting_Date').AsDateTime) = True then begin
          DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes :=
             DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes + [gpremAccountPeriodClosed];
        end;
        if DmGiftProcessing.DmDonation.IsCCEFTClosed() = True then begin
          DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes :=
             DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes + [gpremCCEFTClosed];
        end;
      end;

      // 5/12/2014 gms b-05022 FAdjustThirdPartyBatch only used in DonationDM
      // DmGiftProcessing.DmDonation.FAdjustThirdPartyBatch := False;
      if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
        // need events turned back on for adjust initialization
        // 9/5/2013 gms d-04321 TurnOn not needed here because we didn't turn off events
        //  at start of procedure
        // TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
        DmGiftProcessing.DmDonation.GiftProcAdjustInitialization;
      end;

      // Don't activate the Print Button unless DMDonation has been created.
      // This will can prevent in inadvertent Access Violoation
      if DmGiftProcessing.DmDonation <> nil then begin
        PrintAction.Enabled := True;
      end;

      // After a previous exception, may get stuck in DisabledControls mode
      while dsGiftProcessing.DataSet.ControlsDisabled = True do begin
        dsGiftProcessing.DataSet.EnableControls;
      end;

      ApplyOptionsToGrid(False);
      SetRestrictedEditingColumn();
      if (grdMain.Showing) and (grdMain.CanFocus) and (grdMain.Focused = False) then begin
        grdMain.SetFocus;
      end;
    finally
      // 9/5/2013 gms d-04321 TurnOff/TurnOn not needed here.  The only place we might need it
      //  is inside FillDonationGrid.  FillDonationGrid is already turning off events and we
      //  not need it there either.
      // TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
    end;

    if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Last;   //Move Focus to last record on adjustments
    end else begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.First;   //Move Focus to first record  - 07/24/2013 RRR D-04168
    end;

  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoBatchSearch');
  end;
end;

procedure TfrmBatchGiftProcessing.DoCancel(pMessageToDisplay: Integer);
var
  aMsg: string;
  aDoReset: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoCancel');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.DoCancel';
  try
    inherited;

    aDoReset := True;

    gPidiBugReport.SIInfo := 'TfrmBatchGiftProcessing.DoCancel: Show warning message';
    if (DmGiftProcessing.DmDonation.cdsGiftProcessing.ChangeCount > 0) or
       (DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
      if (pMessageToDisplay = 1) then begin
        aMsg := 'Cancel All Changes and Search for a Different Batch?';
      end else begin
        aMsg := 'Cancel All Changes?';
      end;

      aDoReset := MessageDlg(aMsg, mtConfirmation, [mbYes, mbNo], 0) = mrYes;
    end;

    if aDoReset = True  then begin
      gPidiBugReport.SIInfo := 'TfrmBatchGiftProcessing.DoCancel: aDoReset = True';
      // Cancel changes and reset the form.
      // 10/24/2014 gms d-05138 DEPRECATED no longer needed; LockBatch will check the lock status on the
      //   batch log record itself.
      // if FBatchIsLocked then begin
      LockBatch(False);
      // end;

      // Now reset the form to defaults.
      gPidiBugReport.SIInfo := 'TfrmBatchGiftProcessing.DoCancel: ResetForm';
      ResetForm(); // BEFORE CancelAll()

      // Cancel all updates and empty all datasets.
      gPidiBugReport.SIInfo := 'TfrmBatchGiftProcessing.DoCancel: CancelAll';
      DmGiftProcessing.CancelAll(); // AFTER ResetForm();
      gPidiBugReport.SIInfo := 'TfrmBatchGiftProcessing.DoCancel: ResetAllDataSets';
      DmGiftProcessing.ResetAllDataSets(); // AFTER ResetForm();

      // Turn off the Save button. Even through ResetForm does this, do it again.
      SaveAction.Enabled := False;

      gPidiBugReport.SIInfo := 'TfrmBatchGiftProcessing.DoCancel: SetFocus';
      // Focus the batch number.
      if (txtBatch.Showing) and (txtBatch.CanFocus) then begin
        txtBatch.SetFocus;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoCancel');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.DoCancel';
  end;
end;

procedure TfrmBatchGiftProcessing.DoCloseSplitter;
// 3/20/2014 gms d-04568 Conolidated code here to close splitter; focus main grid;
//    and on exception to refocus the lower grid after ParentIsHidingForm
//    attempts to post dataset and throws validation error.
var
  aTabSheetFrm: TfrmTabSheet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoCloseSplitter');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.DoCloseSplitter';
  try
     DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen := False;  //07/14/2014 RRR D-04955
    // If the splitter is already closed why close it a second time.
    // Close it only when is visible.
    if splMain.Visible = True then begin
      try
        aTabSheetFrm := TfrmTabSheet(PageControlInfo.GetFormForTab(pgcMain.ActivePage));
        if aTabSheetFrm <> nil then begin
          // call lower tab procedure to post the dataset if necessary
          aTabSheetFrm.ParentIsHidingForm();
        end;
        // Close the splitter
        splMain.CloseSplitter;
        splMain.Visible := False;
        if (grdMain.Showing) and (grdMain.CanFocus) and (grdMain.Focused = False) then begin
          grdMain.SetFocus;
        end;
      except
        on EBusinessRuleError do begin      //Keep focus on grid if Validation Error
          if aTabSheetFrm <> nil then begin
            DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen := True;  //07/14/2014 RRR D-04955
            aTabSheetFrm.ReFocusForm;
          end;
          // 7/22/2014 gms don't reraise exception here; need to continue logic in callers
          //   such as OnCanFocusRecord
        end;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoCloseSplitter');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.DoCloseSplitter';
  end;
end;

procedure TfrmBatchGiftProcessing.DoAccountSearch();
var
  aMailCode: string;
  aFrmAccountSearch: TfrmAccountSearchClient;
  aMainPcActiveTabSheet: TRzTabSheet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoAccountSearch');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.DoAccountSearch';
  try
    inherited;

    if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit] then begin

      if FIsBusyOutOfProcess = False then begin

        FIsBusyOutOfProcess := True;
        try
          aMainPcActiveTabSheet := gPidiDDGlobal.MainPageControl.ActivePage;
          aFrmAccountSearch := TfrmAccountSearchClient.Create(Self, False); // Will release itself

          // Remember the mail code for prospect searching
          if IsEmptyStr(gPidiActiveData.MailCode) = False then begin
            aMailCode := gPidiActiveData.MailCode;
          end;
          ResetPidiActiveData();

          if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_PROSPECT_FINDER) = True then begin
            FProspectSearch := True;
          end;

          //  Let's try and fill in the Prospect and Mail Code, but always fill in the rest of the data.
          try
            if FProspectSearch then begin
              if IsEmptyStr(aMailCode) then begin
                gPidiActiveData.MailCode := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('MCD').AsString;
              end else begin
                gPidiActiveData.MailCode := aMailCode;
              end;

              if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_MINIMUM_EDIT) then begin
                aFrmAccountSearch.Execute(asmProspect, aamMinEdit, True);
              end else begin
                aFrmAccountSearch.Execute(asmProspect, aamMasterView, True); // Sets gPidiActiveData.AccountId
              end;

              // Make sure still editing
              if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
                DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
              end;

              if (IsEmptyStr(gPidiActiveData.ProspectIdStr) = False) then begin
                DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('ProspectAdd').AsBoolean := True;
                DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prospect_ID').AsString := gPidiActiveData.ProspectIdStr;

                if gPidiDDGlobal.ClientAcronym = 'CARE' then begin
                  DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Trans_No').AsString :=
                     gPidiActiveData.ProspectIdStr;
                end;
              end;

              if IsEmptyStr(gPidiActiveData.MailCode) = False then begin
                DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('MCD').AsString := gPidiActiveData.MailCode;
              end;
            end else begin
              // Make sure still editing
              if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
                DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
              end;

              DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('ProspectAdd').AsBoolean := False;
              DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prospect_ID').Clear;

              if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_MINIMUM_EDIT) then begin
                aFrmAccountSearch.Execute(asmSearchPickMinEdit, aamMinEdit, True);
              end else begin
                aFrmAccountSearch.Execute(asmSearchPick, aamMasterView, True); // Sets gPidiActiveData.AccountId
              end;
            end;
          finally
            // 4/10/2014 d-04768 set accountID and fullname whether in min add or not
            if (gPidiActiveData.AccountId >= 1) then begin
              // Make sure still editing
              if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
                DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
              end;

              DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger :=
                 gPidiActiveData.AccountId;
              DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('FullName').AsString :=
                 gPidiActiveData.FullName;
              if gPidiActiveData.AcctIDAssignedOnAdd = True then begin
                PageControlInfo.DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('AcctIDAssignedOnAdd').AsBoolean := True;
              end;
            end;
            if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_MINIMUM_EDIT)) and
               (gPidiActiveData.AccountSearchResultMode = asrmAdd) then begin
              // 2/5/2015 gms d-05298 converted procedure to boolean function so as to detect
              //   user clicking cancel on form. If canceled, we don't want to run GiftProcSetAccountData
              if DoMinAdd() = True then begin
                // 4/10/2014 d-04768 set rest of gift processing data from master; don't want to
                //   to call DoAccountIDEditValueChanged because MinEdit already displayed
                if (DmGiftProcessing.DmDonation.GiftProcIsValidAccountId(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger,
                   gpvaDonation) = True) then begin
                  DmGiftProcessing.DmDonation.GiftProcSetAccountData();
                  // D-04852 TWM - If valid account, move to the next field after Amount
                  // 6/19/2014 gms b-05611 no longer using threading to move to a different field
                  // ThreadedMoveToField(grdMainTableView, 'Amount');
                  MoveToField(grdMainTableView, 'Amount');
                end;
              end;
            end else if (gPidiActiveData.AccountId >= 1) then begin
              // Let's give focus / control back to the Gift Processing screen
              gPidiDDGlobal.MainPageControl.ActivePage := aMainPcActiveTabSheet;

              (* 4/10/2014 d-04768 Removed here because EditValueChanged also has this code, called below
              if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_UPDATE_MASTER_INFO) then begin
                DoGiftProcEditAccountRecord(gpmeDonation,
                   DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger, False);
              end;
              *)
              // 4/10/2014 d-04768 Load master data for account
              DoAccountIDEditValueChanged(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger);
              // 7/2/2014 gms d-04952 move to Prg field when clicking on search ellipses or F key
              // 7/2/2014 gms d-04952 Added test for options selected; If we just came out of
              //   min edit; the focus was shifted to amount; so only focus on program
              //   if we did not edit or did not use min edit. 
              if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_UPDATE_MASTER_INFO) = False) or
                 (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(DonationDM.OPTION_MINIMUM_EDIT) = False) then begin
                grdMainTableViewPrg.FocusWithSelection;
              end;
            end;
          end;
        finally
          FIsBusyOutOfProcess := False;
        end;
      end;
    end;

    FProspectSearch := False;
    gPidiDDGlobal.MainFormStatusPane.Caption := StatusMsg;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoAccountSearch'); 
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.DoAccountSearch';
  end;
end;

procedure TfrmBatchGiftProcessing.SetBatchLabel();
var
  aAccountId: string;
  aName: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetBatchLabel');
  try
    inherited;
    // Indicate to the user if the batch is a CC or EFT or not.
    if (DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('batch_type').AsString = 'C') then begin
      gbxDonations.Caption := '&Gifts: Credit Card Batch';
    end else if (DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('batch_type').AsString = 'E') then begin
      gbxDonations.Caption := '&Gifts: EFT / Check Batch';
    end else if (DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('batch_type').AsString = 'A') then begin
      gbxDonations.Caption := '&Gifts: Adjustment Batch';
    end else begin
      gbxDonations.Caption := '&Gifts: Donation Batch';
    end;
    // Add the current record info if there is some.
    if (DmGiftProcessing.DmDonation.cdsGiftProcessing.RecordCount > 0) then begin
      aAccountId := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsString;
      aName := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('FullName').AsString;
      gbxDonations.Caption := gbxDonations.Caption + '  ( ID:  ' + aAccountId + '   Name:  ' + aName + ' )';
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetBatchLabel');
  end;
end;

procedure TfrmBatchGiftProcessing.btnOptionsTopClick(Sender: TObject);
var
  aNewForm: TfrmBatchGiftProcessingOptions;
begin
  inherited;
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnOptionsClick');
  try
    try
      btnOptionsTop.Enabled := False; // D-04855 TWM 2014.05.20

      inherited;
      // 3/25/2014 gms d-04662 don't allow options dialog if account ID is focused; causes
      //   problems on return.
      if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsEdit, dsInsert]) and
         (grdMainTableViewAccountId.Focused = True) then begin
        StopMsg('Please complete entry of account ID');
      end else begin
        // Display the Options dialog
        aNewForm := nil;
        try
          aNewForm := TfrmBatchGiftProcessingOptions.Create(Self, DmGiftProcessing.DmDonation);
          aNewForm.ShowModal();
          // Now apply the options.
          ApplyOptionsToGrid(True);
          SetRestrictedEditingColumn();
        finally
          aNewForm.Free();
          // 5/29/2013 gms need to call grid enter method to ensure DBNavigator's DataSource is set correctly
          // 3/21/2014 gms d-04568 don't focus main grid is lower grid is open
          if PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = False then begin
            grdMainEnter(grdMain);
          end;
        end;
      end;
    finally
      btnOptionsTop.Enabled := True;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnOptionsClick');
  end;
end;

procedure TfrmBatchGiftProcessing.btnSearchClick(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnSearchClick');
  try
    inherited;
    // Do the search.
    if FIsBusyOutOfProcess = False then begin
      try
        FIsBusyOutOfProcess := True;    //DoSearch was intermittently firing the BatchDateKeyUp Event, Test inside event
        
        DoSearch();
        FProspectSearch := False;
      finally
        FIsBusyOutOfProcess := False;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnSearchClick');
  end;
end;

procedure TfrmBatchGiftProcessing.btnCancelBatchClick(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnCancelBatchClick');
  try
    inherited;
    // Cancel changes and reset the form.
    DoCancel(1);
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnCancelBatchClick');
  end;
end;

procedure TfrmBatchGiftProcessing.LockBatch(pLockBatch: Boolean);
var
  aTmpList: TList;
  aChangeLock, aAdjustOriginalBatchLocked: Boolean;
  aAdjustOriginalLockedBy: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LockBatch');
  try
    aChangeLock := False;
    // 10/29/2014 gms d-05138 added test for dataset empty because if first click cancel
    //   dataset is empty; then if click close we should not try to unlock (already unlocked)
    if DmGiftProcessing.DmDonation.cdsBatchLog.IsEmpty = False then begin
      if (pLockBatch = False) then begin
        // 10/24/2014 gms d-05138 unlock batch if locked and locked by the current user
        if (IsEmptyField(DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_By')) = False) and
           (DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_By').AsString = gPidiDDGlobal.UserName) then begin
          aChangeLock := True;
        end;
      end else if (pLockBatch = True) then begin
        gPidiDDGlobal.ErrorHandler.Reset;
        aAdjustOriginalBatchLocked := False;
        // 11/5/2014 gms d-05138 for adjustment batches, check to see if batch of original
        //   donation is locked; if so, cannot adjust and form will be read only
        if (DmGiftProcessing.DmDonation.DataModuleMode = dmmAdjBatch) then begin
          aAdjustOriginalBatchLocked := DmGiftProcessing.DmDonation.GiftProcAdjustOriginalBatchLocked(aAdjustOriginalLockedBy);
          if aAdjustOriginalBatchLocked = True then begin
            gPidiDDGlobal.ErrorHandler.Add('The batch of the original donation has been locked by ' +
               aAdjustOriginalLockedBy + '. The adjustment batch will be opened in read only mode', etValidation);
          end;
        end;
        // 10/24/2014 gms d-05138 if batch already locked, display message and make
        //   form read only
        if (IsEmptyField(DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_By')) = False) then begin
          // 10/24/2014 gms d-05138 can lock batch if lock on batch is more than 4 hours old
          //   or locked by the current user; need to use string version of locked_on from
          //   middle tier  to_char(locked_on, 'mm/dd/yyyy hh24:mi:ss) as Locked_On_Str
          //   because AsDateTime only gets integer part of date
          if StrToDateTime(DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_On_Str').AsString) < (Now() - 0.1667) then begin
            aChangeLock := True;
          end else if (DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_By').AsString = gPidiDDGlobal.UserName) then begin
            aChangeLock := True;
          end else begin
            // 11/5/2014 gms d-05138 added slightly different error message when adjustment
            //   batch is locked
            if (DmGiftProcessing.DmDonation.DataModuleMode = dmmAdjBatch) then begin
              gPidiDDGlobal.ErrorHandler.Add('This adjustment batch has been locked by ' +
                 DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_By').AsString +
               '. The adjustment batch will be opened in read only mode.', etValidation);
            end else begin
              gPidiDDGlobal.ErrorHandler.Add('This batch has been locked by ' +
                 DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_By').AsString +
               '. The batch will be opened in read only mode.', etValidation);
            end;
          end;
        end else begin // always change unlocked batch
          aChangeLock := True;
        end;
        // 11/5/2014 gms d-05138 if any of the above errors were raised, set the form to read only
        if gPidiDDGlobal.ErrorHandler.HandleErrors = True then begin
          Self.FormReadOnly := True;
        end;
      end;
    end;

    // 10/24/2014 gms d-05138 DEPRECATED no longer needed; LockBatch is checking the lock status on the
    //   batch log record itself.
    // FBatchIsLocked := pLockBatch;

    if aChangeLock = True then begin

      DmGiftProcessing.DmDonation.cdsBatchLog.LoadingData := True;
      DmGiftProcessing.DmDonation.cdsBatchLog.Edit;
      (* 10/24/2014 gms d-05138 no need to change the batch and bdate fields; the batchlog
          dataset was already loaded with this batch
      DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Batch').AsString := txtBatch.Text;
      DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('BDate').AsString := FmtYmd(FBatchDateStr);
      *)

      if pLockBatch then begin
        DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_By').AsString := gPidiDDGlobal.UserName;
        DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_On').AsDateTime := Now();
        DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_On_Str').AsString := FormatDateTime('mm/dd/yyyy hh:nn:ss',
           DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_On').AsDateTime);
      end else begin
        DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_By').Clear;
        DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_On').Clear;
        DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Locked_On_Str').Clear;
      end;

      DmGiftProcessing.DmDonation.cdsBatchLog.Post;
      DmGiftProcessing.DmDonation.cdsBatchLog.LoadingData := False;

      // save the lock status to the database immediately
      aTmpList := nil;
      try
        aTmpList := TList.Create;
        AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsBatchLog);
        UpdateSqlDataSetList(aTmpList);
      finally
        FreeSqlUpdate(aTmpList);
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LockBatch');
  end;
end;

procedure TfrmBatchGiftProcessing.SetAltIDParams;
var
  aTmpField: TField;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetAltIDParams');
  try
    FShowAltID := False;

    aTmpField := DmGiftProcessing.DmDonation.cdsBatchLog.FindField('Alt_IDS_Code');
    if aTmpField <> nil then begin
      FAltIDFieldName := aTmpField.AsString;
      if IsEmptyStr(FAltIDFieldName) = False then begin
        FShowAltID := True;
      end;
    end;

  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetAltIDParams');
  end;
end;

procedure TfrmBatchGiftProcessing.txtDateEraseMeKeyPress(Sender: TObject; var Key: Char);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.txtDateEraseMeKeyPress');
  try
    if FIsBusyOutOfProcess = False then begin
      if Key = Chr(13) then begin
      // Enter/Return pressed
        btnSearchClick(Self);
        Key := #0;
      end else if Key = Chr(32) then begin
      // Space pressed
        if Sender is TsDateEdit then begin
          TsDateEdit(Sender).Date := Date();
        end;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.txtDateEraseMeKeyPress');
  end;
end;

// Fire data event for auto-commit feature in UI.
procedure TfrmBatchGiftProcessing.GiftProcessingAutoCommitDataEventCallBack;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingAutoCommitDataEventCallBack');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.GiftProcessingAutoCommitDataEventCallBack';
  try
    // 8/26/2014 gms b-05845 don't auto commit in edit or adjust modes; user must click Save
    if (not (DmGiftProcessing.DmDonation.DataModuleMode in [dmmEditDonation, dmmAdjBatch])) then begin
      // Does the ChangeCount match the counter?
      if (spinAutoCommit.Value > 0) and
         (DmGiftProcessing.DmDonation.cdsGiftProcessing.ChangeCount >= spinAutoCommit.Value) then begin
        if (ApplyHostUpdate = True) then begin
          gPidiDDGlobal.MainMenuButtonSave.Enabled := False;
        end;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingAutoCommitDataEventCallBack'); 
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.GiftProcessingAutoCommitDataEventCallBack';
  end;
end;

procedure TfrmBatchGiftProcessing.GiftProcessingBeforeInsertDataEventCallBack;
// 6/5/2014 gms d-04897 Add Before Insert callback to prevent dataset going into edit mode
//   when clicking insert while the bottom panel is open; code will focus on grid and
//   account column; then close the splitter if open;  DONT CALL SHOWTAB instead of DoCloseSplitter
//   ShowTab calls SetCheckedColumns which will put dataset in edit mode while still inserting a record
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingBeforeInsertDataEventCallBack');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.GiftProcessingBeforeInsertDataEventCallBack';
  try
    if (grdMain.Showing) and (grdMain.CanFocus) and (grdMain.Focused = False) then begin
      grdMain.SetFocus;
    end;
    grdMainTableViewAccountId.Focused := True;
    if (splMain.State <> ssClosed) then begin
      DoCloseSplitter();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingBeforeInsertDataEventCallBack');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.GiftProcessingBeforeInsertDataEventCallBack';
  end;
end;

// Fire data event for AfterInsert feature in UI.
procedure TfrmBatchGiftProcessing.GiftProcessingAfterInsertDataEventCallBack;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingAfterInsertDataEventCallBack');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.GiftProcessingAfterInsertDataEventCallBack';
  try
    // If inserting, and option set, perform search.
    if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_ZIP_SURNAME_SEARCH)) then begin
      DoAccountSearch();
    end else begin
      // 6/19/2014 gms b-05611 no longer using threading to move to a different field
      // ThreadedMoveToNextField;
      // 7/2/2014 gms d-04952 always focus on account ID after insert.
      // MoveToNextField;
      grdMainTableViewAccountId.Focused := True;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingAfterInsertDataEventCallBack');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.GiftProcessingAfterInsertDataEventCallBack';
  end;
end;

// Fire data event for AfterDelete feature in UI.
procedure TfrmBatchGiftProcessing.GiftProcessingAfterDeleteDataEventCallBack;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingAfterDeleteDataEventCallBack');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.GiftProcessingAfterDeleteDataEventCallBack';
  try
    // If Deleteing, Update display labels.
    DisplayQtys;
    // 4/26/2013 gms Enable the Modal dialog's Save button when in Adjustment after a delete.
    if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
      SaveAction.Enabled := True;
      btnSave.Enabled := True;
    end else begin
      // Ensure the save button lights up every time.
      gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction;
      SaveAction.Enabled := True;
      gPidiDDGlobal.MainMenuButtonSave.Enabled := True;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingAfterDeleteDataEventCallBack');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.GiftProcessingAfterDeleteDataEventCallBack';
  end;
end;

// Fire data event when program changes.
procedure TfrmBatchGiftProcessing.GiftProcessingOnPrgChangeDataEventCallBack;
var
  aAccountID: string;
  aResponseSusClassID: integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingOnPrgChangeDataEventCallBack');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.GiftProcessingOnPrgChangeDataEventCallBack';
  try
    if DmGiftProcessing.DmDonation.DmDonationCodes.IsSusProgram(
       DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsInteger) then begin
      aResponseSusClassID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Sustainer_Class').AsInteger;
      aAccountID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsString;

      //09/24/2014 RRR D-05099  Do not load Current pledge if Sustainer Classes are used
      //Current Pledge will be loaded by the Mail Code Change event, which will always be called
      //Calling here will result in duplicate messages
      if not DmGiftProcessing.DmDonation.GiftProcIsSustainerClassActive then begin
        DmGiftProcessing.DmDonation.GiftProcLoadCurrentPledgeID(aAccountID, aResponseSusClassID);
      end;

      // 10/3/2013 gms d-04386 flag to indicate batch has sustainer donations
      DmGiftProcessing.DmDonation.GiftProcAnySustainerDonations := True;

      ShowPledgeColumns;

      EnablePledgeFields;

    end else begin
      DisablePledgeFields;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingOnPrgChangeDataEventCallBack'); 
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.GiftProcessingOnPrgChangeDataEventCallBack';
  end;
end;

// Fire data event for AfterPost feature in UI.
procedure TfrmBatchGiftProcessing.GiftProcessingAfterPostDataEventCallBack;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingAfterPostDataEventCallBack');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.GiftProcessingAfterPostDataEventCallBack';
  try
    // If Posting, Update display labels.
    DisplayQtys;

    // Ensure the save button lights up every time.
    gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction;
    SaveAction.Enabled := True;
    gPidiDDGlobal.MainMenuButtonSave.Enabled := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GiftProcessingAfterPostDataEventCallBack');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.GiftProcessingAfterPostDataEventCallBack';
  end;
end;

//07/14/2014 RRR D-04955  moved from ApplyHostUpdate
function TfrmBatchGiftProcessing.ValidateLowerGrids(): Boolean;
var
  aTabSheetFrm: TfrmTabSheet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ValidateLowerGrids');
  try
    Result := True;
    try
      // 3/20/2104 gms d-04568 get active page of lower grids and check to see if dataset
      //   needs posting.  Not calling DoCloseSplitter here because that procedure
      //   focuses the main grid which we don't want to do here.
      aTabSheetFrm := TfrmTabSheet(PageControlInfo.GetFormForTab(pgcMain.ActivePage));
      if aTabSheetFrm <> nil then begin
        // call lower tab procedure to post the dataset if necessary
        aTabSheetFrm.ParentIsHidingForm();
      end;
      splMain.CloseSplitter;
      splMain.Visible := False;
      grdMain.Enabled := False;
    except
      on EBusinessRuleError do begin      //Keep focus on grid if Validation Error
        if aTabSheetFrm <> nil then begin
          aTabSheetFrm.ReFocusForm;
          Result := False;
        end;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ValidateLowerGrids');
  end;
end;

function TfrmBatchGiftProcessing.ValidateBatchStatus(pPerformAbort: Boolean): Boolean;

  //============================  Sub Procedures  ============================ //

  function HasChanges(DataSet: TpidCdsProvider): Boolean;
  var
    aDeltaDS: TClientDataSet;
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ValidateBatchStatus: HasChanges');
    try
      Result := False;
      if DataSet.ChangeCount > 0 then begin
        aDeltaDS := TClientDataSet.Create(nil);
        aDeltaDS.Data := DataSet.Delta;
        try
          if aDeltaDS.IsEmpty = False then begin
            aDeltaDS.First;
            while not aDeltaDS.EOF do begin
              if (aDeltaDS.UpdateStatus = usInserted) or
                 (aDeltaDS.UpdateStatus = usDeleted) then begin
                Result := True;
              end;
              aDeltaDS.Next;
            end;
          end;
        finally
          aDeltaDS.Free;
        end;
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ValidateBatchStatus: HasChanges');
    end;
  end;

  //=========================== End Sub Procedures  =========================== //

var
  aSql: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ValidateBatchStatus');
  try
    Result := True;
    // 2/10/2015 gms d-05304 call DoEmptyDataSet to avoid error in case dataset is closed;
    //   DoEmptyDataSet will call dataset cancel if in edit/insert mode
    // DmGiftProcessing.DmDonation.cdsValidateBatchLog.EmptyDataSet;
    pidiCoreDB.DoEmptyDataSet(DmGiftProcessing.DmDonation.cdsValidateBatchLog);
    aSql := 'select * from batch_log where batch = '+ QuotedStr( txtBatch.Text  )
       + ' and BDate = to_date(' + QuotedStr( dtpBatchDate.Text ) + ', ''MM/DD/YYYY'')';
    LoadAstaData_PidCDSProvider(aSql, DmGiftProcessing.DmDonation.cdsValidateBatchLog, True, True, False);
    if ((DmGiftProcessing.DmDonation.cdsValidateBatchLog.FieldByName('Batch_Type').AsString = 'C') and
       (DmGiftProcessing.DmDonation.cdsValidateBatchLog.FieldByName('BATCH_STATUS').AsString <> 'CC-PENDING')) or
       ((DmGiftProcessing.DmDonation.cdsValidateBatchLog.FieldByName('Batch_Type').AsString = 'E') and
       (DmGiftProcessing.DmDonation.cdsValidateBatchLog.FieldByName('BATCH_STATUS').AsString <> 'EFT-PEND')) then begin
      gPidiDDGlobal.ErrorHandler.Reset;
      gPidiDDGlobal.ErrorHandler.Add('This batch has been processed by the CC Billing Interface... ' +
         'Donations cannot be added to this batch. Please create a new batch or generate from errors.'
         + #13#10 + ' ' + #13#10, etValidation);

      // Use Delta looping from sub procedure in 6.3
      if HasChanges(DmGiftProcessing.DmDonation.cdsGiftProcessing) or (FWorkInProgress = True) then begin   //02/20/2014 RRR D-04700
        if gPidiDDGlobal.ErrorHandler.HandleErrors then begin                                               //Print warning msg if loading batch
          if ( pPerformAbort ) then begin
            Result := False;
            BusinessRuleAbort;
          end;
        end;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ValidateBatchStatus');
  end;
end;

//01/29/2014 RRR D-04330
function TfrmBatchGiftProcessing.GetFormDataState(): TpidiFormDataState;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetFormDataState');
  try
    // 5/30/2014 gms d-04827 set result if form is busy doing something; takes care of
    //   use case of attempting to close donor direct when loading a batch
    if FIsBusyOutOfProcess = True then begin
      Result := fdsBusy;
    end else begin
      Result := DmGiftProcessing.GetDmDataState();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetFormDataState');
  end;
end;

// Central SAVE method.
function TfrmBatchGiftProcessing.ApplyHostUpdate: Boolean;

  //============================  Sub Procedures  ============================ //

  function ApplyHostUpdate4Adjustments(pCopyGiftProcessing: TpidCDSProvider): Boolean;  //04/28/2014 RRR D-04751 - Add parameter
  var
    aAhu_BackOutList, aAhu_OrigList, aAhu_AdjList: array of Integer;
    aAhu_LoopCnt, aAhu_BO, aAhu_Adj, aAhu_Link, aAhu_BackOutID: Integer;
    aAhu_Seq, aAhu_LinkedRec: Integer;
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ApplyHostUpdate: ApplyHostUpdate4Adjustments');
    gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.ApplyHostUpdate: ApplyHostUpdate4Adjustments';
    Result := True;
    try
      if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
        // Get a Count of Linked Records, Backed Out Records and Adjusted Records
        aAhu_BO:= 0;
        aAhu_Adj := 0;
        aAhu_LinkedRec := 1;
        aAhu_BackOutID := 0;

        //04/28/2014 RRR D-04751 - Replaced cdsGiftProcessing with pCopyGiftProcessing
        //------------------------------------------------------------------------------
        pCopyGiftProcessing.First;
        while not pCopyGiftProcessing.Eof do begin
          if not IsEmptyField(pCopyGiftProcessing.FieldByName('Linked_Gift_Seq')) then begin
            if pCopyGiftProcessing.FieldByName('Linked_Gift_Seq').AsInteger > aAhu_LinkedRec then begin
              aAhu_LinkedRec := pCopyGiftProcessing.FieldByName('Linked_Gift_Seq').AsInteger;
            end;
          end;
          if pCopyGiftProcessing.FieldByName('Adj_Code').AsString = 'B' then begin
            aAhu_BackOutID := pCopyGiftProcessing.FieldByName('Donation_ID').AsInteger;
            Inc(aAhu_BO);
          end else if pCopyGiftProcessing.FieldByName('Adj_Code').AsString = 'D' then begin
            Inc(aAhu_Adj);
          end;
          pCopyGiftProcessing.Next;
        end;
        //------------------------------------------------------------------------------

        // Initialize Records Pointers
        SetLength(aAhu_AdjList, aAhu_LinkedRec);
        SetLength(aAhu_BackOutList, aAhu_LinkedRec);
        SetLength(aAhu_OrigList, aAhu_LinkedRec);
        for aAhu_LoopCnt := 1 to aAhu_LinkedRec do begin
          aAhu_BackOutList[aAhu_LoopCnt - 1] := aAhu_BackOutID;
          aAhu_OrigList[aAhu_LoopCnt - 1] := DmGiftProcessing.DmDonation.AdjustDonationID;
          aAhu_AdjList[aAhu_LoopCnt - 1] := 0;
        end;

        // fill in record pointers for Donation_Adjustment table
        // if split, there will be multiple records in each group
        //04/28/2014 RRR D-04751 - Replaced cdsGiftProcessing with pCopyGiftProcessing
        //------------------------------------------------------------------------------
        pCopyGiftProcessing.First;
        while not pCopyGiftProcessing.Eof do begin
          aAhu_Seq := 0;
          if IsEmptyField(pCopyGiftProcessing.FieldByName('Linked_Gift_Seq')) = False then begin
            aAhu_Seq := pCopyGiftProcessing.FieldByName('Linked_Gift_Seq').AsInteger;
          end;

          if (aAhu_LinkedRec = 1) or (aAhu_Seq = 0) then begin
            aAhu_Link := 1   //no Links
          end else begin
            aAhu_Link := aAhu_Seq;
          end;

          if pCopyGiftProcessing.FieldByName('Adj_Code').AsString = 'B' then begin
            aAhu_BackOutList[aAhu_Link-1] := pCopyGiftProcessing.FieldByName('Donation_ID').AsInteger;
          end else if (pCopyGiftProcessing.FieldByName('Adj_Code').AsString = 'A') or
             (pCopyGiftProcessing.FieldByName('Adj_Code').AsString = 'E') then begin
            aAhu_OrigList[aAhu_Link-1] := pCopyGiftProcessing.FieldByName('Donation_ID').AsInteger;
          end else if pCopyGiftProcessing.FieldByName('Adj_Code').AsString = 'D' then begin
            aAhu_AdjList[aAhu_Link-1] := pCopyGiftProcessing.FieldByName('Donation_ID').AsInteger;
          end;

          pCopyGiftProcessing.Next;
        end;
        //------------------------------------------------------------------------------

        // create the donation_adjustment records
        if not DmGiftProcessing.DmDonation.cdsDonationAdjustment.Active then begin
          DmGiftProcessing.DmDonation.cdsDonationAdjustment.CreateDataSet;
        end;
        // 2/10/2015 gms d-05304 call DoEmptyDataSet to avoid error in case dataset is closed;
        //   DoEmptyDataSet will call dataset cancel if in edit/insert mode
        // DmGiftProcessing.DmDonation.cdsDonationAdjustment.EmptyDataSet;
        pidiCoreDB.DoEmptyDataSet(DmGiftProcessing.DmDonation.cdsDonationAdjustment);
        for aAhu_LoopCnt := 1 to aAhu_LinkedRec do begin
          Add2cdsDonationAdjustment(aAhu_OrigList[aAhu_LoopCnt - 1], aAhu_backOutList[aAhu_LoopCnt - 1],
             aAhu_AdjList[aAhu_LoopCnt - 1]);
        end;

        ResetPidiActiveData();
        gPidiActiveData.DonationId := aAhu_AdjList[aAhu_Link-1];    //save new don id for displaying TabDonations
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ApplyHostUpdate: ApplyHostUpdate4Adjustments');
      gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.ApplyHostUpdate: ApplyHostUpdate4Adjustments';
    end;
  end;

  //=========================== End Sub Procedures  =========================== //

var
  aCursor: TCursor;
  aDonationId: Integer;
  aDelogSql: TStringList;
  aCopyGiftProcessing: TpidCDSProvider;  //04/28/2014 RRR D-04751
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ApplyHostUpdate');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.ApplyHostUpdate';
  try
    Result := False;

    //07/14/2014 RRR D-04955
    //Check to see if the batch has been processed by the Credit Card Billing Interface
    //Also check the status of the Lower grids to see if they pass validation
    //If there are problems, issue a Business Rule Abort
    if ValidateBatchStatus(True) = False then begin
      Exit;
    end;

    if PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin  //09/08/2014 RRR D-05043  Don't validate lower grid if splitter closed
      if ValidateLowerGrids() = False then begin  //07/14/2014 RRR D-04955
        Exit;
      end;
    end;

    //07/14/2014 RRR D-04955  Batch Passed Validation, Saving of batch may proceed

    // 4/14/2014 gms d--04752 moved Post to before the setfocus to avoid the focus posting the dataset
    //    to avoid a dataset not in edit or insert mode when posting
    if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit] then begin
      gPidiBugReport.OtherInfo := 'BatchGiftProcessingFrm.ApplyHostUpdate - Posting cdsGiftProcessing';
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
      if (grdMain.Showing) and (grdMain.CanFocus)  and (grdMain.Focused = False) then begin
        grdMain.SetFocus;
      end;
    end;

    aCursor := Self.Cursor;
    Self.Cursor := crHourGlass;
    aCopyGiftProcessing := nil;
    try
      // DataSet Events.
      FWorkInProgress := True; // Suppress RecordChanged events.
      TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
      SetUpperLevelMenuEnabled(gPidiDDGlobal.MainMenu, False);
      DmGiftProcessing.DmDonation.cdsGiftProcessing.DisableControls;
      aDonationId := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('donation_id').AsInteger;

      //04/28/2014 RRR D-04751
      //Make a copy of cdsGiftProcessing to avoid iterating on cdsGiftProcessing
      //Iterating on cdsGiftProcessing is the probable cause of some Access Violations
      //Iterate on copy instead
      aCopyGiftProcessing := TpidCDSProvider.Create(nil);
      CopyCDSAssign(aCopyGiftProcessing, DmGiftProcessing.DmDonation.cdsGiftProcessing,
         DmGiftProcessing.DmDonation.cdsGiftProcessing.Name + '_copy', True, False);
      aCopyGiftProcessing.Data := DmGiftProcessing.DmDonation.cdsGiftProcessing.Data;   
      Self.Cursor := crHourGlass;

//   //07/14/2014 RRR D-04955  moved into ValidateLowerGrids
(*    try
        // 3/20/2104 gms d-04568 get active page of lower grids and check to see if dataset
        //   needs posting.  Not calling DoCloseSplitter here because that procedure
        //   focuses the main grid which we don't want to do here.
        aTabSheetFrm := TfrmTabSheet(PageControlInfo.GetFormForTab(pgcMain.ActivePage));
        if aTabSheetFrm <> nil then begin
          // call lower tab procedure to post the dataset if necessary
          aTabSheetFrm.ParentIsHidingForm();
        end;
        splMain.CloseSplitter;
        splMain.Visible := False;
        grdMain.Enabled := False;
      except
        on EBusinessRuleError do begin      //Keep focus on grid if Validation Error
          if aTabSheetFrm <> nil then begin
            aTabSheetFrm.ReFocusForm;
          end;
        end;
      end;        *)

      FNoSave := False;

      // If this is an adjustment batch, perform pre-save logic.
      if (DoSoftCreditsBalance(aCopyGiftProcessing) = True) then begin   //04/28/2014 RRR D-04751 - Add parameter

        if (DoGroupMembershipsBalance(aCopyGiftProcessing) = True) then begin    //CCFA Only  //04/28/2014 RRR D-04751 - Add Parameter
          // This method sets various default values including flags, interests,
          // mail codes, and creates journaled pledges depending on donation data.
          gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.ApplyHostUpdate: PreUpdateRoutine';  
          Self.Cursor := crHourGlass;
          PreUpdateRoutine();     //Don't use aCopyGiftProcessing, may need to add Journaled Pledge

          // For DELOG records.
          gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.ApplyHostUpdate: GenerateDataEntryLogSql';
          aDelogSql := TStringList.Create; // DO NOT FREE, will be freed in FreeSqlUpdate
          GenerateDataEntryLogSql(aDelogSql, aCopyGiftProcessing);  //04/28/2014 RRR D-04751 - Add Parameter 
          Self.Cursor := crHourGlass;

          if (ApplyHostUpdate4Adjustments(aCopyGiftProcessing) = False) then begin   //04/28/2014 RRR D-04751 - Add Parameter
            Result := False;
            btnCancelAndClose.Click;
            Exit;
          end;

          // Performs the actual ASTA Updates.
          gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.ApplyHostUpdate: UpdateTheDatabase';
          if (UpdateTheDatabase(aDelogSql, aCopyGiftProcessing) = True) then begin    //04/28/2014 RRR D-04751 - Add Parameter

            Self.Cursor := crHourGlass;
            if DmGiftProcessing.DmDonation.cdsMatchedGift.ChangeCount > 0 then begin
              DmGiftProcessing.DmDonation.cdsMatchedGift.MergeChangeLog;
            end;
            
            Self.Cursor := crHourGlass;
            if DmGiftProcessing.DmDonation.cdsMatchingGift.ChangeCount > 0 then begin
              DmGiftProcessing.DmDonation.cdsMatchingGift.MergeChangeLog;
            end;
             
            Self.Cursor := crHourGlass;
            if DmGiftProcessing.DmDonation.cdsGiftMembership.ChangeCount > 0 then begin
              DmGiftProcessing.DmDonation.cdsGiftMembership.MergeChangeLog;
            end;

            // 02/18/2014 RRR D-04663
            // Selected field may have changed, cancel to prevent SAVE button from lighting
            
            Self.Cursor := crHourGlass;
            if DmGiftProcessing.DmContactTickler.cdsTracking.ChangeCount > 0 then begin
              DmGiftProcessing.DmContactTickler.cdsTracking.CancelUpdates;
            end;
            
            Self.Cursor := crHourGlass;

            Result := True;
          end;
        end; // Group Memberships Balance
      end; // Soft Credits Balance
      // Relocate
      gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.ApplyHostUpdate: Relocate';
      if not DmGiftProcessing.DmDonation.cdsGiftProcessing.Locate('donation_id', VarArrayOf([aDonationId]), []) then begin
        // Couldn't find the donation.
        // Let's go to the top. Why? Dunno.
        DmGiftProcessing.DmDonation.cdsGiftProcessing.First;
      end;
    finally
      aCopyGiftProcessing.Free;  //04/28/2014 RRR D-04751
      SetUpperLevelMenuEnabled(gPidiDDGlobal.MainMenu, True);
      // DataSet Events.
      TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
      DmGiftProcessing.DmDonation.cdsGiftProcessing.EnableControls;
      grdMain.Enabled := True;
      // Must check for visible status in the case the user clicked the close button.
      if (grdMain.Showing) and (grdMain.CanFocus)  and (grdMain.Focused = False) then begin
        gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.ApplyHostUpdate: Finally - SetFocus';
        grdMain.SetFocus;
      end;
      FWorkInProgress := False; // Suppress RecordChanged events.
      Self.Cursor := aCursor;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ApplyHostUpdate');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.ApplyHostUpdate';
  end;
end;

procedure TfrmBatchGiftProcessing.SaveRoutine;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SaveRoutine');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.SaveRoutine';
  try
    inherited;
    // This would mean the save button was clicked in modal mode.
    if ((DmGiftProcessing.DataModuleMode = dmmAdjBatch) or
       (DmGiftProcessing.DataModuleMode = dmmEditDonation)) then begin
      FNoSave := True;
      Self.ModalResult := mrOK;
    end;
  finally
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.SaveRoutine';
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SaveRoutine');
  end;
end;

// This method sets various default values including flags, interests,
// mail codes, and creates journaled pledges depending on donation data.
//Iterate on cdsGiftProcessing, May need to add a Journaled Pledge //04/29/2014 RRR
procedure TfrmBatchGiftProcessing.PreUpdateRoutine();
var
  aDeltaDS: TClientDataSet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.PreUpdateRoutine');
  try
    if DmGiftProcessing.DmDonation.cdsGiftProcessing.ChangeCount = 0 then begin
      Exit;
    end;

    DmGiftProcessing.DmDonation.cdsGiftProcessing.First;
    aDeltaDS := TClientDataSet.Create(Self);
    aDeltaDS.Data := DmGiftProcessing.DmDonation.cdsGiftProcessing.Delta;
    CheckDonationDeletes(aDeltaDS);
    try
      while not DmGiftProcessing.DmDonation.cdsGiftProcessing.Eof do begin
        if RecordHasChanged(aDeltaDS, 'Donation_ID', DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger) then begin
          RenewalRoutine(aDeltaDS);
          CheckJournaledPledge();
        end;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Next;
      end;
    finally
      aDeltaDS.Free;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.PreUpdateRoutine');
  end;
end;

// This is the place we set the expire date or assign any
// flags or interest codes depending on the donation data.
procedure TfrmBatchGiftProcessing.RenewalRoutine(pDeltaDS: TClientDataSet);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.RenewalRoutine');
  try
    // Available for Override
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.RenewalRoutine');
  end;
end;

// This routine goes thru the donations and checks to see if the user selected
// a Donation type of 'P'.  If so, then this pledge will be journaled and we
// need to write a pledge record with the Journaled flag set to 'Y'.
procedure TfrmBatchGiftProcessing.CheckJournaledPledge();
var
  aPledgeID, aTrackingID: Integer;
  aAdj, aType: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CheckJournaledPledge');
  try
    aAdj := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_Code').AsString;
    if (aAdj = 'A') or (aAdj = 'B') or (aAdj = 'E') then begin
      Exit;
    end;

    aType := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').AsString;
    aPledgeID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Pledge_ID').AsInteger;
    aTrackingID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Tracking_ID').AsInteger;
    if aType = 'P' then begin
      if aPledgeID = 0 then begin
        AddJournaledPledge();
      end;

      // 10/21/2013 RRR D-04371  Create the Tracking Record Pledge record if it does not exist
      if (aTrackingID > 0) and (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Pledge_ID').AsInteger > 0) then begin
        AddTrackingRecordPledge;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CheckJournaledPledge');
  end;
end;

function TfrmBatchGiftProcessing.UpdateTheDatabase(pDelogSql: TStringList; pCopyGiftProcessing: TpidCDSProvider): Boolean;
var
  aCancelUpdates: Boolean;
  aTmpList: TList;
  aTmpStringList: TStringList;
  aRevisedDonationCount: Integer;

  //============================  Sub Procedures  ============================ //

  procedure CountRevisedDonations();
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: CountRevisedDonations');
    try
      aRevisedDonationCount := 0;
      //04/28/2014 RRR D-04751 - Replaced cdsGiftProcessing with pCopyGiftProcessing
      //------------------------------------------------------------------------------
      pCopyGiftProcessing.First;
      while not pCopyGiftProcessing.Eof do begin
        if (pCopyGiftProcessing.FieldByName('Adj_Code').AsString = 'D') then begin
          Inc(aRevisedDonationCount);
        end;
        pCopyGiftProcessing.Next;
      end;
      //------------------------------------------------------------------------------
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: CountRevisedDonations');
    end;
  end;

  // Matching Gifts
//Deprecated  06/05/2014 RRR D-04831  - Already done when building Adj Records
(*procedure MatchingGiftLogic();
  var
    aStringList: TStringList; // DO NOT FREE - FREED IN FreeSqlUpdate BELOW
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: MatchingGiftLogic');
    try
      if (DmGiftProcessing.DmDonation.GetMatchingGiftCount(DmGiftProcessing.DmDonation.AdjustDonationID) > 0) then begin
        if MessageDlg('This Donation has a Matching Gift' + #13#10 +
           'Keep Revised Donation Linked to Matching Gift?', mtWarning, [mbYes, mbNo], 0) = mrYes then begin
          aStringList := TStringList.Create;
          aStringList.Add(' ');
          aStringList.Add('Update Donation set matched_don_id = NULL, matching_status = NULL ' +
             ' where donation_id = ' + IntToStr(DmGiftProcessing.DmDonation.AdjustDonationID) + ';');
          AddSQLUpdate(aTmpList, aStringList);
        end else begin
          aCancelUpdates := True;
        end;
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: MatchingGiftLogic');
    end;
  end;                       *)

  // Matched Gifts
  procedure MatchedGiftLogic();
  var
    aStringList: TStringList; // DO NOT FREE - FREED IN FreeSqlUpdate BELOW
    FDeleteMGs, FRelinkMGs: Boolean;
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: MatchedGiftLogic');
    try
      // 12/28/2012 gms separated test of GetMatchGiftCount and aRevisedDonationCount.  If
      //   GetMatchedGiftCount = 0, should immediately exit procedure.
      if (DmGiftProcessing.DmDonation.GetMatchedGiftCount(DmGiftProcessing.DmDonation.AdjustDonationID) > 0) then begin
        if (aRevisedDonationCount > 1) then begin
          ShowMessage('This Donation has Matched Gifts, but there are Multiple Revision Records' + #13#10 +
             'Adjustment will be Cancelled');
          aCancelUpdates := True;
        end else begin
          FDeleteMGs := False;
          FRelinkMGS := False;
          if (aRevisedDonationCount = 0) then begin
            if MessageDlg('This Donation has Matched Gifts' + #13#10 +
               'Continue with Adjustment?', mtWarning, [mbYes, mbNo], 0) = mrYes then begin
              FDeleteMGs := True;
            end else begin
              aCancelUpdates := True;
            end;
          end else begin
            if MessageDlg('This Donation has Matched Gifts' + #13#10 +
               'Relink Matched Gifts to Revised Donation?', mtWarning, [mbYes, mbNo], 0) = mrYes then begin
              FRelinkMGs := True;
            end else begin
              FDeleteMGs := True;
            end;
          end;
          // Perform update
          if ((FDeleteMGs = True) or (FRelinkMGs = True)) then begin
            aStringList := TStringList.Create;
            aStringList.Add(' ');
            aStringList.Add('Update Donation set matched_don_id = ' +
               IntToStr(DmGiftProcessing.DmDonation.AdjustNewDonationID));
            if FDeleteMGs then begin
              aStringList.Add(', matching_status = NULL ');
            end;
            aStringList.Add(' where donation_id in ' +
               '  (select d.donation_id from Donation d, Donation d2 ' +
               ' where (d.matched_don_id > 0) and (d.matched_don_id = d2.donation_ID) and ' +
               ' (d2.Donation_ID = ' + IntToStr(DmGiftProcessing.DmDonation.AdjustDonationID) + '));');
            AddSQLUpdate(aTmpList, aStringList);
          end;
        end;
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: MatchedGiftLogic');
    end;
  end;

  // Split Gifts
//Deprecated  06/05/2014 RRR D-04831  - Already done when building Adj Records
(*procedure SplitGiftLogic;
  var
    aStringList: TStringList; // DO NOT FREE - FREED IN FreeSqlUpdate BELOW
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: SplitGiftLogic');
    try
      if ((DmGiftProcessing.DmDonation.GetSplitGiftCount(DmGiftProcessing.DmDonation.AdjustDonationID) > 0) and
         (aRevisedDonationCount = 0)) then begin
        if MessageDlg('Donation was Backed Out' + #13#10 +
           'Split Gifts must be Deleted to Continue Adjustment' + #13#10 +
           'Delete Split Gifts?', mtWarning, [mbYes, mbNo], 0) = mrYes then begin
          aStringList := TStringList.Create;
          // 12/11/2013 gms d-04561 Update SQL to use correct field name
          //    Linked_Gift_Amt -> LINKED_FULL_AMT
          aStringList.Add('Update Donation set Linked_Gift_ID = NULL, Linked_Gift_Seq = NULL, LINKED_FULL_AMT = NULL ' +
             ' where Donation_id = ' + IntToStr(DmGiftProcessing.DmDonation.AdjustDonationID) + ';');
          AddSQLUpdate(aTmpList, aStringList);
        end else begin
          aCancelUpdates := True;
        end;
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: SplitGiftLogic');
    end;
  end;

  // Split Donations
  procedure SplitDonationLogic();
  var
    aStringList1: TStringList; // DO NOT FREE - FREED IN FreeSqlUpdate BELOW
    aStringList2: TStringList; // DO NOT FREE - FREED IN FreeSqlUpdate BELOW
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: SplitDonationLogic');
    try
      if (DmGiftProcessing.DmDonation.GetSplitDonationCount(DmGiftProcessing.DmDonation.AdjustDonationID) > 0) then begin
        // Unlink
        aStringList1 := TStringList.Create;
        aStringList1.Add(' ');
        // 12/11/2013 gms d-04561 Update SQL to use correct field name
        //    Linked_Gift_Amt -> LINKED_FULL_AMT
        aStringList1.Add('Update Donation set Linked_Gift_ID = NULL, Linked_Gift_Seq = NULL, LINKED_FULL_AMT = NULL ' +
           '  where Donation_id = ' + IntToStr(DmGiftProcessing.DmDonation.AdjustDonationID) + ';');
        AddSQLUpdate(aTmpList, aStringList1);
        // Relink
        aStringList2 := TStringList.Create;
        aStringList2.Add(' ');
        aStringList2.Add('Update Donation set linked_Gift_ID = ' +
           IntToStr(DmGiftProcessing.DmDonation.AdjustNewDonationID) +
           ' where Linked_Gift_ID = ' + IntToStr(DmGiftProcessing.DmDonation.AdjustDonationID) + ';');
        aStringList2.Add('Update Donation set batch = ' + QuotedStr(DmGiftProcessing.DmDonation.AdjustBatchNo) +
           ', bdate = to_date(' + QuotedStr(FormatDateTime('yyyymmdd', DmGiftProcessing.DmDonation.AdjustBatchDate)) + ',''yyyymmdd'')' +
           ' where Linked_Gift_ID = ' + IntToStr(DmGiftProcessing.DmDonation.AdjustNewDonationID) + ' and (adj_code = ''N'');');
        AddSQLUpdate(aTmpList, aStringList2);
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: SplitDonationLogic');
    end;
  end;      *)

  // Get Major Gifts Updates
  function GetMgfUpdates(aGmuMatching: Boolean): TStringList;
  var
    aGmuCount: Integer;
    aGmuDataSet, aGmuDeltaDS: TpidCdsProvider;
    aGmuOldList, aGmuNewList: TStringList;
    aGmuName: string;

    procedure MgfFieldsChanged(aMfcOldList, aMfcNewList, aMfcSqlList: TStringList; aMfcUpdStatus: TUpdateStatus);
    var
      aMfcTmpStr: string;
    begin
      SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: GetMgfUpdates:MgfFieldsChanged');
      try
        FillNewListFromOld(aMfcOldList, aMfcNewList);
        if aMfcUpdStatus = usInserted then begin
          aMfcTmpStr := GetMgfUpdateSql(aMfcNewList);
          if IsEmptyStr(aMfcTmpStr) = False then begin
            aMfcSqlList.Add(aMfcTmpStr);
          end;
          aMfcTmpStr := AddEmploymentRec(aMfcNewList);
          if IsEmptyStr(aMfcTmpStr) = False then begin
            aMfcSqlList.Add(aMfcTmpStr);
          end;
        end else if aMfcUpdStatus = usModified then begin
          aMfcTmpStr := GetMgfUpdateSql(aMfcOldList);
          if IsEmptyStr(aMfcTmpStr) = False then begin
            aMfcSqlList.Add(aMfcTmpStr);
          end;
          aMfcTmpStr := AddEmploymentRec(aMfcOldList);
          if IsEmptyStr(aMfcTmpStr) = False then begin
            aMfcSqlList.Add(aMfcTmpStr);
          end;
        end else if aMfcUpdStatus = usDeleted then begin
          aMfcSqlList.Add(GetMgfDeleteSql(aMfcOldList));
        end;
      finally
        SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: GetMgfUpdates:MgfFieldsChanged');
      end;
    end;

  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: GetMgfUpdates');
    try
      Result := TStringList.Create;
      if aGmuMatching then begin
        aGmuDataSet := DmGiftProcessing.DmDonation.cdsMatchingGift;
      end else begin
        aGmuDataSet := DmGiftProcessing.DmDonation.cdsMatchedGift;
      end;
      aGmuDataSet.Filtered := False;

      aGmuDeltaDS := nil;
      aGmuOldList := nil;
      aGmuNewList := nil;
      try
        aGmuDeltaDS := TpidCdsProvider.Create(nil);
        aGmuOldList := TStringList.Create;
        aGmuNewList := TStringList.Create;
        aGmuDeltaDS.Data := aGmuDataSet.Delta;
        aGmuDeltaDS.First;
        while not aGmuDeltaDS.Eof do begin
          if aGmuDeltaDS.UpdateStatus = usDeleted then begin
            aGmuOldList.Clear;
            aGmuNewList.Clear;
            for aGmuCount := 0 to aGmuDeltaDS.FieldCount - 1 do begin
              aGmuName := aGmuDeltaDS.Fields[aGmuCount].FieldName;
              aGmuOldList.Add(aGmuName + '=' + VarToStr(aGmuDeltaDS.Fields[aGmuCount].NewValue));
            end;
            MgfFieldsChanged(aGmuOldList, aGmuNewList, Result, aGmuDeltaDS.UpdateStatus);
          end;

          if (aGmuDeltaDS.UpdateStatus = usUnmodified) then begin
            aGmuOldList.Clear;
            aGmuNewList.Clear;
            for aGmuCount := 0 to aGmuDeltaDS.FieldCount - 1 do begin
              aGmuName := aGmuDeltaDS.Fields[aGmuCount].FieldName;
              aGmuOldList.Add(aGmuName + '=' + VarToStr(aGmuDeltaDS.Fields[aGmuCount].NewValue));
            end;
            Next;
            for aGmuCount := 0 to aGmuDeltaDS.FieldCount - 1 do begin
              aGmuName := aGmuDeltaDS.Fields[aGmuCount].FieldName;
              aGmuNewList.Add(aGmuName + '=' + VarToStr(aGmuDeltaDS.Fields[aGmuCount].NewValue));
            end;
            MgfFieldsChanged(aGmuOldList, aGmuNewList, Result, aGmuDeltaDS.UpdateStatus);
          end;

          if (aGmuDeltaDS.UpdateStatus = usInserted) then begin
            aGmuNewList.Clear;
            for aGmuCount := 0 to aGmuDeltaDS.FieldCount - 1 do begin
              aGmuName := aGmuDeltaDS.Fields[aGmuCount].FieldName;
              aGmuNewList.Add(aGmuName + '=' + VarToStr(aGmuDeltaDS.Fields[aGmuCount].NewValue));
            end;
            MgfFieldsChanged(aGmuOldList, aGmuNewList, Result, aGmuDeltaDS.UpdateStatus);
          end;

          aGmuDeltaDS.Next;
        end;
      finally
        aGmuDeltaDS.Free;
        aGmuOldList.Free;
        aGmuNewList.Free;
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: GetMgfUpdates');
    end;
  end;

  // GetGiftUpdates
  function GetGiftUpdates: TStringList;
  var
    aGguIndex, aGguCount: Integer;
    aGguDataSet, aGguDeltaDS: TpidCdsProvider;
    aGguOldList, aGguNewList: TStringList;
    aGguName, aGguValue: String;

    procedure GiftFieldsChanged(aGfcOldList, aGfcNewList, aGfcSqlList: TStringList; aGfcUpdStatus: TUpdateStatus);
    begin
      SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: GetGiftUpdates:GiftFieldsChanged');
      try
        FillNewListFromOld(aGfcOldList, aGfcNewList);
        if aGfcUpdStatus <> usDeleted then begin
          AddDonationData(aGfcNewList.Values['Donor_DonID'], aGfcNewList);
        end;

        if aGfcUpdStatus = usInserted then begin
          aGfcSqlList.Add(FormatSqlCommand(DmGiftProcessing.DmDonation.cdsGiftMembership.SqlInsert, aGfcNewList))
        end else if aGfcUpdStatus = usModified then begin
          aGfcSqlList.Add(FormatSqlCommand(DmGiftProcessing.DmDonation.cdsGiftMembership.SqlUpdate, aGfcNewList))
        end else if aGfcUpdStatus = usDeleted then begin
          aGfcSqlList.Add(FormatSqlCommand(DmGiftProcessing.DmDonation.cdsGiftMembership.SqlDelete, aGfcOldList))
        end;
      finally
        SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: GetGiftUpdates:GiftFieldsChanged');
      end;
    end;
    
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: GetGiftUpdates');
    try
      Result := TStringList.Create;
      Result.Add(' ');
      aGguDataSet := DmGiftProcessing.DmDonation.cdsGiftMembership;
      aGguDataSet.Filtered := False;
      aGguDeltaDS := nil;
      aGguOldList := nil;
      aGguNewList := nil;
      try
        aGguDeltaDS := TpidCdsProvider.Create(nil);
        aGguOldList := TStringList.Create;
        aGguNewList := TStringList.Create;
        aGguDeltaDS.Data := aGguDataSet.Delta;
        aGguDeltaDS.First;
        while not aGguDeltaDS.Eof do begin
          if (aGguDeltaDS.UpdateStatus = usDeleted) then begin
            aGguOldList.Clear;
            aGguNewList.Clear;
            for aGguCount := 0 to aGguDeltaDS.FieldCount - 1 do begin
              aGguName := aGguDeltaDS.Fields[aGguCount].FieldName;
              aGguOldList.AddObject(aGguName + '=' + VarToStr(aGguDeltaDS.Fields[aGguCount].NewValue),
                 aGguDeltaDS.Fields[aGguCount]);
            end;
            GiftFieldsChanged(aGguOldList, aGguNewList, Result, aGguDeltaDS.UpdateStatus);
          end;
          if (aGguDeltaDS.UpdateStatus = usUnmodified) then begin
            aGguOldList.Clear;
            aGguNewList.Clear;
            for aGguCount := 0 to aGguDeltaDS.FieldCount - 1 do begin
              aGguName := aGguDeltaDS.Fields[aGguCount].FieldName;
              aGguOldList.AddObject(aGguName + '=' + VarToStr(aGguDeltaDS.Fields[aGguCount].NewValue),
                 aGguDeltaDS.Fields[aGguCount]);
            end;
            aGguDeltaDS.Next;
            for aGguCount := 0 to aGguDeltaDS.FieldCount - 1 do begin
              aGguName := aGguDeltaDS.Fields[aGguCount].FieldName;
              aGguValue := VarToStr(aGguDeltaDS.Fields[aGguCount].NewValue);
              aGguNewList.AddObject(aGguName + '=' + aGguValue, aGguDeltaDS.Fields[aGguCount]);
              if (IsEmptyStr(aGguValue)) and (not aGguDeltaDS.Fields[aGguCount].IsNull) then begin
                aGguIndex := aGguOldList.IndexOfName(aGguName);
                if aGguIndex >= 0 then aGguOldList.Delete(aGguIndex);
              end;
            end;
            GiftFieldsChanged(aGguOldList, aGguNewList, Result, aGguDeltaDS.UpdateStatus);
          end;
          if (aGguDeltaDS.UpdateStatus = usInserted) then begin
            aGguNewList.Clear;
            for aGguCount := 0 to aGguDeltaDS.FieldCount -1 do begin
              aGguName := aGguDeltaDS.Fields[aGguCount].FieldName;
              aGguNewList.AddObject(aGguName + '=' + VarToStr(aGguDeltaDS.Fields[aGguCount].NewValue),
                 aGguDeltaDS.Fields[aGguCount]);
            end;
            GiftFieldsChanged(aGguOldList, aGguNewList, Result, aGguDeltaDS.UpdateStatus);
          end;
          aGguDeltaDS.Next;
        end;
      finally
        aGguDeltaDS.Free;
        aGguOldList.Free;
        aGguNewList.Free;
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: GetGiftUpdates');
    end;
  end;

  // Update the Batch EDate
  function UpdateBatchEDate: TStringList;
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: UpdateBatchEDate');
    try
      Result := TStringList.Create;
      Result.Add(' ');
      Result.Add('UPDATE batch_log SET edate = TRUNC(SYSDATE) WHERE batch = ^' +
         txtBatch.Text + '^ AND bdate = ^' + FBatchDateStr + '^;');
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase: UpdateBatchEDate');
    end;
  end;

//=========================== End Sub Procedures  =========================== //

begin // UpdateTheDatabase
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase');
  try
    Result := False;
    aCancelUpdates := False;
    // aTmpStringList := nil; // It in the aTmpList and is freed in FreeSqlUpdate.
    // aTmpList := nil;  // It in the aTmpList and is freed in FreeSqlUpdate.
    try
      aTmpList := TList.Create;
      aTmpStringList := TStringList.Create;

      // !!!!!!! THESE ARE ORDER-SPECIFIC !!!!!!!
      AddSqlUpdate(aTmpList, DeferConstraintsSQL);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsMaster);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsDemographic);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsFlag);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsInterest);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsSuppress);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsActivist);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsMasterAccess);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsComments);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsSuppress);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsPhone);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsEMail);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsPledge);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmContactTickler.cdsAvailPledges);   //Tracking Record Pledge   10/21/2013 RRR D-04371
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
      if ((DmGiftProcessing.DmDonation.cdsDonationAdjustment.Active) and
         (DmGiftProcessing.DmDonation.cdsDonationAdjustment.RecordCount > 0)) then begin
        AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsDonationAdjustment);
      end;
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsDonatedVehicle);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.DmHistory.cdsDonationHst);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmImoIho.cdsImoIho);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsGiftDonation);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmAccount.cdsIRContactTickler);  // Ir Order Form
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsPremium);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsSoftCredit);
      AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsSplitDonation);

      if (gPidiDDGlobal.ClientAcronym = 'CCFA') or (gPidiDDGlobal.ClientAcronym = 'DEMO') then begin
        AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsEventDonation);
      end;

      if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
        CountRevisedDonations();

        //Need to run this query to link Matching DOnor Gift to Company Gift
        MatchedGiftLogic();
        if (aCancelUpdates = True) then begin
          Exit;
        end;

//Deprecated  06/05/2014 RRR D-04831  - Already done when building Adj Records
   (*   MatchingGiftLogic();
        if (aCancelUpdates = True) then begin
          Exit;
        end;
        SplitGiftLogic();
        if (aCancelUpdates = True) then begin
          Exit;
        end;
        SplitDonationLogic();
        if (aCancelUpdates = True) then begin
          Exit;
        end;   *)

        // Update the batch totals.
        FDmGiftProcessing.DmDonation.UpdateAdjBatchTotals(DmGiftProcessing.DmDonation.AdjustBatchNo,
           DmGiftProcessing.DmDonation.AdjustBatchDate, aTmpStringList);
        AddSqlUpdate(aTmpList, aTmpStringList);
      end else begin
        FDmGiftProcessing.DmDonation.UpdateBatchLog(txtBatch.Text, dtpBatchDate.Date, aTmpStringList);
        AddSqlUpdate(aTmpList, aTmpStringList);
      end;

      if DmGiftProcessing.DmDonation.cdsDonationSolicitor.ChangeCount > 0 then begin
        AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsDonationSolicitor);
      end;

      if DmGiftProcessing.DmDonation.cdsSoftCreditSolicitor.ChangeCount > 0 then begin
        AddSqlUpdate(aTmpList, DmGiftProcessing.DmDonation.cdsSoftCreditSolicitor);
      end;

      if DmGiftProcessing.DmDonation.cdsMatchingGift.ChangeCount > 0 then begin
        AddSqlUpdate(aTmpList, GetMgfUpdates(True));
      end;

      if DmGiftProcessing.DmDonation.cdsMatchedGift.ChangeCount > 0 then begin
        AddSqlUpdate(aTmpList, GetMgfUpdates(False));
      end;

      if DmGiftProcessing.DmDonation.cdsGiftMembership.ChangeCount > 0 then begin
        AddSqlUpdate(aTmpList, GetGiftUpdates());
      end;

      if HasInserts(DmGiftProcessing.DmDonation.cdsGiftProcessing) or (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
        AddSqlUpdate(aTmpList, UpdateBatchEDate());
      end;

//Deprecated  06/05/2014 RRR D-04831  - Not necessary, Linked Gift Amount is already computed correctly
(*    if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
        aAdjSqlList := AdjustLinkedGiftAmt;
        if aAdjSqlList <> nil then begin
          if aAdjSqlList.Count > 0 then begin
            AddSqlUpdate(aTmpList, aAdjSqlList);
          end;
        end;
      end;     *)

      // Add in the Delog SQL here.
      AddSqlUpdate(aTmpList, pDelogSql);

      // Hook for more datasets.
      AddAdditionalUpdateTheDatabaseDataSets(aTmpList);

      // Perform the Update via ASTA
      WaitForAsta;
      UpdateSqlDataSetList(aTmpList);

      // Refresh tracking records.
      DmGiftProcessing.DmContactTickler.RefreshTRDonations();

      Result := True;
    finally
      //aTmpStringList.Free; // Do not free. It in the aTmpList and is freed in FreeSqlUpdate.
      FreeSqlUpdate(aTmpList);
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UpdateTheDatabase');
  end;
end;

procedure TfrmBatchGiftProcessing.AddAdditionalUpdateTheDatabaseDataSets(pList: TList);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddAdditionalUpdateTheDatabaseDataSets');
  try
    // For override.
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddAdditionalUpdateTheDatabaseDataSets');
  end;
end;

function TfrmBatchGiftProcessing.DoSoftCreditsBalance(pCopyGiftProcessing: TpidCDSProvider): Boolean;
var
  aMsg: string;
  aIsWarning: Boolean;
  aOrigDonationID: Integer;
  aAnyWarningMessages: Boolean;    //09/08/2014 RRR D-05043
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoSoftCreditsBalance');
  try
    Result := True;
    // 8/6/2013 gms save original donation ID; in loop below will reset donation filters
    //   so that SoftCreditOK has the correct set of soft credit records;  at end of loop
    //   will reset donation filters to this original donation ID

    //04/28/2014 RRR D-04751 - Replaced cdsGiftProcessing with pCopyGiftProcessing
    //------------------------------------------------------------------------------
    aOrigDonationID := pCopyGiftProcessing.FieldByName('Donation_ID').AsInteger;
    try
      //Added 01/31/2013 RRR tk-10873
      //Need to Validate Soft Credit Totals on SAVE
      aAnyWarningMessages := False;    //09/08/2014 RRR D-05043
      pCopyGiftProcessing.First;
      while not pCopyGiftProcessing.Eof do begin
        DmGiftProcessing.DmDonation.GiftProcSetFilterOnDonationDatasets(
           pCopyGiftProcessing.FieldByName('Donation_ID').AsInteger);
        if not DmGiftProcessing.DmDonation.SoftCreditOK(pCopyGiftProcessing, aMsg, aIsWarning) then begin

          //09/08/2014 RRR D-05043 - Validation Errors will already have been caught
          aAnyWarningMessages := True;
          Break;
//        if not aIsWarning then begin
//          gPidiDDGlobal.ErrorHandler.Reset;
//          gPidiDDGlobal.ErrorHandler.Add(aMsg, etValidation);
//          gPidiDDGlobal.ErrorHandler.HandleErrors;
//          Result := False;
//          Exit;
//        end;
        end;
        pCopyGiftProcessing.Next;
      end;

      //09/08/2014 RRR D-05043
      if aAnyWarningMessages = True then begin
        gPidiDDGlobal.ErrorHandler.Reset;
        gPidiDDGlobal.ErrorHandler.Add('Warning - One or More Donations has Soft Credit Amount Restriction Overridden', etWarning);
        gPidiDDGlobal.ErrorHandler.HandleErrors;
        if gPidiDDGlobal.ErrorHandler.UserResponse <> mrProceed then begin
          Result := False;
          Exit;
        end;
      end;

    //------------------------------------------------------------------------------
    finally
      DmGiftProcessing.DmDonation.GiftProcSetFilterOnDonationDatasets(aOrigDonationID);
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoSoftCreditsBalance');
  end;
end;

procedure TfrmBatchGiftProcessing.dtpBatchDateKeyUp(Sender: TObject;
  var Key: Word; Shift: TShiftState);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.dtpBatchDateKeyUp');
  try
    inherited;

    if FIsBusyOutOfProcess = False then begin
      if (Key = VK_RETURN) then begin
        Key := 0;
        btnSearchClick(nil);
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.dtpBatchDateKeyUp');
  end;
end;

procedure TfrmBatchGiftProcessing.txtBatchKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.txtBatchKeyUp');
  try
    inherited;

    if FIsBusyOutOfProcess = False then begin
      if (Key = VK_RETURN) then begin
        Key := 0;
        btnSearchClick(nil);
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.txtBatchKeyUp');
  end;
end;

procedure TfrmBatchGiftProcessing.DoGetEventTicketPurchaserGuest;
var
  aEventTicketPurchaseGridFrm: TfrmEventTicketPurchaseGridClient;
  aReturnCode: word;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoGetEventTicketPurchaserGuest');
  try
    inherited;
    if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_ID) then begin
      ShowMessage('Please choose an Event');
    end else begin
      aEventTicketPurchaseGridFrm := TfrmEventTicketPurchaseGridClient.Create(Self, nil, nil,
         DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_ID.AsInteger);
      aEventTicketPurchaseGridFrm.SetInitialValues(DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_ReceiptID.AsInteger,
         DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_TicketNumber.AsInteger);
      try
        aReturnCode := aEventTicketPurchaseGridFrm.ShowModal;
        if aReturnCode = mrOK then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_ReceiptID.AsInteger := aEventTicketPurchaseGridFrm.Receipt_ID;
          DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_PurchaserName.AsString := aEventTicketPurchaseGridFrm.PurchaserName;
          DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_TicketNumber.AsInteger := aEventTicketPurchaseGridFrm.TicketNumber;
          DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_GuestName.AsString := aEventTicketPurchaseGridFrm.GuestName;
        end else if aReturnCode = mrNo then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_ReceiptID.Clear;
          DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_PurchaserName.Clear;
          DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_TicketNumber.Clear;
          DmGiftProcessing.DmDonation.cdsGiftProcessingEvent_GuestName.Clear;
        end;
      finally
        aEventTicketPurchaseGridFrm.Free;
        gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction;
        SaveAction.Enabled := True;
        gPidiDDGlobal.MainMenuButtonSave.Enabled := True;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoGetEventTicketPurchaserGuest');
  end;
end;

function TfrmBatchGiftProcessing.DoGroupMembershipsBalance(pCopyGiftProcessing: TpidCDSProvider): Boolean;   //CCFA Only
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoGroupMembershipsBalance');
  try
    Result := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoGroupMembershipsBalance');
  end;
end;

procedure TfrmBatchGiftProcessing.DisplayQtys;
var
  aOldWIP: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DisplayQtys');
  try
    if not (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
      try
        aOldWIP := FWorkInProgress;
        FWorkInProgress := True;

        pnlStatus.Caption := 'Batch Count = ' + DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Num').AsString + '   ' +
           'Batch Amount = ' +  Format('%m', [DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Amount').AsCurrency])+ '   ';

        pnlStatus.Caption := pnlStatus.Caption  +
           '           Donation Count = ' + IntToStr(DmGiftProcessing.DmDonation.GiftProcDonationCount);
        if DmGiftProcessing.DmDonation.GiftProcItemCount > 0 then begin
          pnlStatus.Caption := pnlStatus.Caption  +
             '           Record Count = ' + IntToStr(DmGiftProcessing.DmDonation.GiftProcItemCount);
        end;
        pnlStatus.Caption := pnlStatus.Caption  +
           '    Amount = ' + Format('%m', [DmGiftProcessing.DmDonation.GiftProcAmount]);

        if (gPidiEPSubSys.IsThirdPartyCCMode) and (DmGiftProcessing.DmDonation.CreditCardBatch)then begin
          pnlStatus.Caption := pnlStatus.Caption + '     CC-Hold Total = ' +
             Format('%m', [DmGiftProcessing.DmDonation.GiftProcHoldAmount]);
        end;

        if (gPidiEPSubSys.IsThirdPartyEFTMode) and (DmGiftProcessing.DmDonation.EFTBatch) then begin
          pnlStatus.Caption := pnlStatus.Caption + '     EFT-Hold Total = ' +
             Format('%m', [DmGiftProcessing.DmDonation.GiftProcHoldAmount]);
        end;

      finally
        FWorkInProgress := aOldWIP;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DisplayQtys');
  end;
end;

procedure TfrmBatchGiftProcessing.SetCheckedColumns(pFromFillDonationGridMethod: Boolean);
var
  aRepost: Boolean;
  aOldWIP: Boolean;
  aCat: string;
  aHasImo: Boolean;
  aHasGiftMem: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetCheckedColumns');
  try
    try
      aOldWIP := FWorkInProgress;
      FWorkInProgress := True;
      aRepost := False;

//    06/26/2104 RRR D-04893  aRepost not set correctly, Moved below after aRepost is set.
//    if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
//      DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
//    end;

      // This method can be entered from FillDonationGrid() which already
      // performs these tasks, or ShowTab()/grdMainEnter() which does not. This logic
      // controls the posting of the dataset in either case, as needed.
      if (pFromFillDonationGridMethod = False) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := True;
        // 9/11/2013 gms d-04321 DEPRECATED TurnOff/TurnOn not needed; setting dataset.LoadingData to
        //   True will bypass all relevant event methods.
        // TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
        aRepost := DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsBrowse;

     //06/26/2014 RRR D-04893  Not needed, will be set below
     // if (aRepost = True) then begin
     //   DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
     ///end;
      end;

      //06/26/2014 RRR D-04893 - Moved from above
      if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
      end;

      // Order IR Column
      if (DmGiftProcessing.DmAccount.cdsIRContactTickler.State = dsBrowse) then begin
        if DmGiftProcessing.DmAccount.cdsIRContactTickler.Locate('LinkID',
           VarArrayOf([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]), []) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('order_ir').AsBoolean := True;
        end else begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('order_ir').AsBoolean := False;
        end;
      end;

      // First, clear the category field; below code will set it based on auxiliary data
      if (DmGiftProcessing.DmImoIho.cdsImoIho.State = dsBrowse) and   //07/14/2014 RRR D-04955
         (DmGiftProcessing.DmDonation.cdsGiftMembership.State = dsBrowse) and
         (DmGiftProcessing.DmDonation.cdsMatchingGift.State = dsBrowse) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').Clear;
      end;

      // 12/26/2012 gms only set Category field if empty (when batch opens)
        // IMO/IHO
      aHasImo := False;
      if (DmGiftProcessing.DmImoIho.cdsImoIho.State = dsBrowse) then begin
        if DmGiftProcessing.DmImoIho.cdsImoIho.Locate('Donation_ID',
           VarArrayOf([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]), []) then begin
          // Should be 'I' or 'H' - could have multiples
          aCat := DmGiftProcessing.DmImoIho.cdsImoIho.FieldByName('Type').AsString;
          if aCat = 'M' then begin
            // IMO type value of M (In Memory Of) equals donation category value of I
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').AsString := 'I';
          end else begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').AsString := 'H';
          end;
          aHasImo := True;
//      end else begin           //07/14/2014 RRR D-04955
//        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').Clear;
        end;
      end;

      // Gift Membership
      aHasGiftMem := False;
      if DmGiftProcessing.DmDonation.cdsGiftMembership.State = dsBrowse then begin
        if aHasImo = False then begin
          if DmGiftProcessing.DmDonation.cdsGiftMembership.Locate('Donor_DonID',
             VarArrayOf([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]), []) then begin
            // Should be 'G'
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').AsString := 'G';
            aHasGiftMem := True;
//        end else begin              //07/14/2014 RRR D-04955
//          if (aHasImo = False) then begin
//            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').Clear;
//          end;
          end;
        end;
      end;

      // Matching Gifts
      if DmGiftProcessing.DmDonation.cdsMatchingGift.State = dsBrowse then begin
        if (aHasGiftMem = False) and (aHasImo = False) then begin
          if DmGiftProcessing.DmDonation.cdsMatchingGift.Locate('Corp_DonID',
             VarArrayOf([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]), []) then begin
            // Should be 'M'
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').AsString := 'M';
//        end else begin      //07/14/2014 RRR D-04955
//          if ((aHasGiftMem = False) and (aHasImo = False)) then begin
//            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').Clear;
//          end;
          end;
        end;
      end;
//    end;   //01/15/2014 RRR D-04378


//DEPRECATED  02/24/2014 RRR D-04705 TK-13725   The Matching Status field sent down from the Middle Tier.
//                                              Code is wiping out correct value
//       Matched Gifts
//    if (DmGiftProcessing.DmDonation.cdsMatchedGift.State = dsBrowse) then begin
//      DmGiftProcessing.DmDonation.cdsMatchedGift.Filtered := False;   //Not needed  07/24/2013 RRR D-04168
//        if DmGiftProcessing.DmDonation.cdsMatchedGift.FindKey([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]) then begin
//      if DmGiftProcessing.DmDonation.cdsMatchedGift.Locate('Donor_DonID',
//         VarArrayOf([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]), []) then begin
//           Should be '1'
//        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Matching_Status').AsString := '1';
//      end else begin
//        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Matching_Status').Clear;
//      end;
//    end;
//------------------------------------------------------------------------
      // 7/9/2014 gms b-05704 added below code when returning to top grid from matching status
      //   when no records are added to clear the matching status column.
      // Matched Gifts
      if (DmGiftProcessing.DmDonation.cdsMatchedGift.State = dsBrowse) then begin
        if (DmGiftProcessing.DmDonation.cdsMatchedGift.Locate('Donor_DonID',
           VarArrayOf([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]), []) = False) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Matching_Status').Clear;
        end;
      end;

      // Soft Credit Column
      if (DmGiftProcessing.DmDonation.cdsSoftCredit.State = dsBrowse) then begin
        if DmGiftProcessing.DmDonation.cdsSoftCredit.Locate('Donation_ID',
           VarArrayOf([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]), []) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SoftCredit').AsBoolean := True;
        end else begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SoftCredit').AsBoolean := False;
        end;
      end;

(*     Not needed as being loaded by the middle tier SQL
      // Premium Column
      if (DmGiftProcessing.DmDonation.cdsPremium.State = dsBrowse) then begin
        if DmGiftProcessing.DmDonation.cdsPremium.Locate('Donation_ID',
           VarArrayOf([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]), []) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Premium_List').AsString :=
             DmGiftProcessing.DmDonation.GetGiftPremiumString;
          //   DmGiftProcessing.DmDonation.cdsPremium.FieldByName('Premium_Code').AsString;
        end else begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Premium_List').Clear;
        end;
      end; *)

      // Split Gift Column
      if (DmGiftProcessing.DmDonation.cdsSplitDonation.State = dsBrowse) then begin
        if DmGiftProcessing.DmDonation.cdsSplitDonation.Locate('Donation_ID',
           VarArrayOf([DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger]), []) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift').AsBoolean := True;
        end else begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift').AsBoolean := False;
        end;
      end;

      // Split Gift 2 Column
      if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Linked_Gift_Seq')) = False then begin
        FAnySplitDonations := True;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift2').AsBoolean := True;
      end else begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift2').AsBoolean := False;
      end;

      // 7/8/2014 gms d-04915 custom columns - for now only ACLU to fill email_address
      SetCustomCheckedColumns(pFromFillDonationGridMethod);
    finally
      if (pFromFillDonationGridMethod = False) then begin
        if (aRepost = True) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
        end;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := False;
        // 9/11/2013 gms d-04321 DEPRECATED TurnOff/TurnOn not needed; setting dataset.LoadingData to
        //   True will bypass all relevant event methods.
        // TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
      end;
      FWorkInProgress := aOldWIP;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetCheckedColumns');
  end;
end;

procedure TfrmBatchGiftProcessing.SetCustomCheckedColumns(pFromFillDonationGridMethod: Boolean);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetCustomCheckedColumns');
  try
    // nothing in base; currently used in ACLU for email address
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetCustomCheckedColumns');
  end;
end;

procedure TfrmBatchGiftProcessing.FillDonationGrid;
var
  aBookMark: TBookMark;
  aMcd, aPrg, aLine: string;
  aTmpList: TStrings;
  aSaveCursor: TCursor;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FillDonationGrid');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.FillDonationGrid';
  try
    FCursorLocSet := False;
    FAnyVehicleDons := False;
    FAnyNewVehicles := False;
    DmGiftProcessing.DmDonation.GiftProcDonationGridSequence := 0;
    DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen := False;  //01/15/2014 RRR D-04378
    FTotalAmount := 0.00;
    aLine := '';
    aMcd := '';
    aTmpList := nil;
    aBookMark := nil;
    aSavecursor := Screen.Cursor;
    Screen.Cursor := crHourGlass;

    // 10/3/2013 gms d-04386 flag to indicate batch has sustainer donations
    //  set to false initially if no default program
    //  always true if batch's default program is sustainer
    if IsEmptyField(DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Default_Prg')) = True then begin
      DmGiftProcessing.DmDonation.GiftProcAnySustainerDonations := False;
    end else begin
      DmGiftProcessing.DmDonation.GiftProcAnySustainerDonations :=
        DmGiftProcessing.DmDonation.DmDonationCodes.IsSusProgram(DmGiftProcessing.DmDonation.cdsBatchLog.FieldByName('Default_Prg').AsInteger);
    end;

    grdMain.Enabled := False;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.DisableControls;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := True;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.LogChanges := False; 
    // 9/5/2013 gms d-04321 DEPRECATED TurnOff/TurnOn not needed; setting dataset.LoadingData to
    //   True will bypass all relevant event methods.
    // TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
    try
      aTmpList := TStringList.Create;

      aBookMark := DmGiftProcessing.DmDonation.cdsGiftProcessing.GetBookmark;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.First;

      // Process each donation
      gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.FillDonationGrid: Process each donation';
      while not DmGiftProcessing.DmDonation.cdsGiftProcessing.Eof do begin
        FTotalAmount := FTotalAmount + DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').AsCurrency +
           DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Extra_Amount').AsCurrency;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
        DmGiftProcessing.DmDonation.GiftProcDonationGridSequence :=
          DmGiftProcessing.DmDonation.GiftProcDonationGridSequence + 1;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('DonID').AsInteger :=
           DmGiftProcessing.DmDonation.GiftProcDonationGridSequence;

        DmGiftProcessing.DmDonation.GiftProcSetApplyPrefix(False);

        // ** REFACTOR ** (ASTA/SQL/VIEW) Denormalize the CC-Info column
        DmGiftProcessing.DmDonation.RefreshCCInfoColumn(DmGiftProcessing.DmDonation.cdsGiftProcessing);

        // ** REFACTOR ** (ASTA/SQL/VIEW) Check and set the Checked Columns
        SetCheckedColumns(True);

        // 10/3/2013 gms d-04386 flag to indicate batch has sustainer donations
        if DmGiftProcessing.DmDonation.DmDonationCodes.IsSusProgram(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsInteger) then begin
          DmGiftProcessing.DmDonation.GiftProcAnySustainerDonations := True;
        end;

        // Vehicles
        if Pos('Vehicle', DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('DonTypeDesc').AsString) > 0 then begin
          FAnyVehicleDons := True;
        end;

//02/20/2014 RRR D-04700   Uncomment, We need this here, to set the SusPledgeID for the donations
        DmGiftProcessing.DmDonation.GiftProcLoadCurrentPledgeID(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsString,
           DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Sustainer_Class').AsInteger);

        // ** REFACTOR ** (ASTA/SQL/VIEW)
        // Build a MailCode SQL String
        aMcd := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Mcd').AsString;
        aPrg := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsString;

        // Add event donation fields to DmGiftProcessing.DmDonation.cdsGiftProcessing, ccfa and demo only for now
        GetEventDonationValues;

        DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Next;
      end; // while
      gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.FillDonationGrid: Finished Process each donation';

      if (not EditDonation) and (not (DmGiftProcessing.DataModuleMode = dmmAdjBatch)) then begin
        //DmGiftProcessing.DmDonation.cdsGiftProcessing.IndexName := '_TempIndex';  //10/09/2013 TWM D-04412
        SetIndex(DmGiftProcessing.DmDonation.cdsGiftProcessing, 'DonID', '_TempIndex', []);
      end;

      DmGiftProcessing.DmImoIho.LoadNOKEntityTypes;

      FillInSCFields; // ACLU

      //********************************************************
      //   Custom Code for Care to set the FMV (Fair Market Value) and Ticket Price from
      //   the values in the BlueBook table.  Fields are informational only and will not be saved to DB
      if gPidiDDGlobal.ClientAcronym = 'CARE' then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.First;
        // Process each donation to possibly update FMV, ticket_price
        while not DmGiftProcessing.DmDonation.cdsGiftProcessing.Eof do begin
          if DmGiftProcessing.DmDonation.cdsMailCode.FindKey([aMcd, aPrg]) then begin
            DmGiftProcessing.DmDonation.GiftProcCheckFMV;
          end;
          if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsEdit, dsInsert]) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
          end;
          DmGiftProcessing.DmDonation.cdsGiftProcessing.Next;
        end; // while
      end;

    finally
      aTmpList.Free;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.GotoBookmark(aBookMark);
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FreeBookmark(aBookMark);
      DmGiftProcessing.DmDonation.cdsGiftProcessing.EnableControls;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := False;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.LogChanges := True;
      grdMain.Enabled := True;
      Screen.Cursor := aSaveCursor;

      // 9/5/2013 gms d-04321 DEPRECATED TurnOff/TurnOn not needed; setting dataset.LoadingData to
      //   True will bypass all relevant event methods.
      // TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FillDonationGrid'); 
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.FillDonationGrid';
  end;
end;

procedure TfrmBatchGiftProcessing.FillInSCFields;  //ACLU Only
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FillInSCFields');
  try
    // Available for Override
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FillInSCFields');
  end;
end;

procedure TfrmBatchGiftProcessing.GetEventDonationValues;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetChapter');
  try
    // Available for Override
    // See ccfa and demo quickpostclient; will be base at later date
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetChapter');
  end;
end;

procedure TfrmBatchGiftProcessing.CloneIRContactCDS;  //overidden by UNICEF
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CloneIRContactCDS');
  try
    DmGiftProcessing.DmAccount.cdsIRContactTickler.ApplyAction := SaveAction;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CloneIRContactCDS');
  end;
end;

procedure TfrmBatchGiftProcessing.SetProgramFilter;    //LCV Only
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetProgramFilter');
  try
    // Available for Override
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetProgramFilter');
  end;
end;

procedure TfrmBatchGiftProcessing.DoGiftProcEditAccountRecord(pMinEditMode: TGiftProcMinEditMode;
   pAccountId: Integer; pLoop: Boolean);
var
  aOrigProgram: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoGiftProcEditAccountRecord');
  try
    if pAccountId > 0 then begin
      if dmPidiCoreClient.UserHasAccountAccess(pAccountId) then begin
        ResetPidiActiveData();
        if (DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(DonationDM.OPTION_MINIMUM_EDIT)) or
           (pMinEditMode = gpmeCodeMaintenance) then begin
          aOrigProgram := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsInteger;

          DoMinEdit(pMinEditMode, pAccountId, pLoop);

          if aOrigProgram <> DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsInteger then begin  //D-02302 Show Pledge Fields if needed
            // 10/3/2013 gms d-04386 Don't need to set GiftProcAnySustainerDonations. If the program is changed
            //  to sustainer, the Prg field On Change will set the flag and show the columns.
            ApplyOptionsToGrid(True);
            SetRestrictedEditingColumn();
          end;
          // D-04852 TWM - If not in Loop Mode, move to the next field after Amount
          if pLoop = False then begin
            // 6/19/2014 gms b-05611 no longer using threading to move to a different field
            // ThreadedMoveToField(grdMainTableView, 'Amount');
            MoveToField(grdMainTableView, 'Amount');
          end;
        end else begin
          if pLoop = True then begin
            MasterViewFrms.OpenMasterViewFrm(mvmEditLoopMode, txtBatch.Text,
               dtpBatchDate.Date, DmGiftProcessing.DmDonation.cdsGiftProcessing);
          end else begin
            ResetPidiActiveData();
            gPidiActiveData.AccountId := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger;
            gPidiActiveData.FullName := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('FullName').AsString;
            MasterViewFrms.OpenMasterViewFrm(mvmEdit, pAccountId);
            if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('FullName').AsString <>
               gPidiActiveData.FullName then begin
              if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
                DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
              end;
              DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('FullName').AsString :=
                 gPidiActiveData.FullName;
            end;
          end;
        end;
      end;
      if (pMinEditMode <> gpmeNonDonation) and (grdMain.Showing) and (grdMain.CanFocus) and (grdMain.Focused = False) then begin
        grdMain.SetFocus;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoGiftProcEditAccountRecord');
  end;
end;

function TfrmBatchGiftProcessing.DoMinAdd: Boolean;
var
  aNewForm: TfrmAccountMinEditClient;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoMinAdd');
  try
    // 2/5/2015 gms d-05298 converted procedure to boolean function so as to detect
    //   user clicking cancel on form
    Result := False;
    DmGiftProcessing.DmAccount.cdsMaster.Insert;
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Prefix').AsString := ProperCase(gPidiActiveData.NamePrefix);
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('First_Name').AsString := ProperCase(gPidiActiveData.FirstName);
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Middle_Name').AsString := ProperCase(gPidiActiveData.MiddleName);
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Last_Name').AsString := ProperCase(gPidiActiveData.LastName);
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Suffix').AsString := ProperCase(gPidiActiveData.NameSuffix);
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Company').AsString := ProperCase(gPidiActiveData.Company);
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Address1').AsString := ProperCase(gPidiActiveData.Address1);
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Address2').AsString := ProperCase(gPidiActiveData.Address2);
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Address3').AsString := ProperCase(gPidiActiveData.Address3);
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('City').AsString := gPidiActiveData.City;
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('State').AsString := gPidiActiveData.State;
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Zip').AsString := gPidiActiveData.Zip;
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Country').AsString := gPidiActiveData.Country;
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Country_Zip').AsString := gPidiActiveData.CountryZip;
    DmGiftProcessing.DmAccount.cdsMaster.FieldByName('FullName').AsString :=
       DmGiftProcessing.DmAccount.AccountUtils.FormatName(
       ProperCase(gPidiActiveData.NamePrefix), ProperCase(gPidiActiveData.FirstName),
       ProperCase(gPidiActiveData.MiddleName), ProperCase(gPidiActiveData.LastName),
       ProperCase(gPidiActiveData.NameSuffix), '', ProperCase(gPidiActiveData.Company));


    if IsEmptyField(DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Zip')) = False then begin
      if dmPidiCoreClient.cdsZipMast.FindKey([DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Zip').AsString]) then begin
        if IsEmptyField(dmPidiCoreClient.cdsZipMast.FieldByName('City')) = False then begin
          DmGiftProcessing.DmAccount.cdsMaster.FieldByName('City').AsString :=
             dmPidiCoreClient.cdsZipMast.FieldByName('City').AsString;
        end;
        if IsEmptyField(dmPidiCoreClient.cdsZipMast.FieldByName('State')) = False then begin
          DmGiftProcessing.DmAccount.cdsMaster.FieldByName('State').AsString :=
             dmPidiCoreClient.cdsZipMast.FieldByName('State').AsString;
        end;
        if IsEmptyField(dmPidiCoreClient.cdsZipMast.FieldByName('Chapter1')) = False then begin
          DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Chapter1').AsString :=
             dmPidiCoreClient.cdsZipMast.FieldByName('Chapter1').AsString;
        end;
      end;
    end;
    
    if IsEmptyStr(gPidiActiveData.Flag1) = False then begin
      DmGiftProcessing.DmAccount.cdsFlag.Insert;
      DmGiftProcessing.DmAccount.cdsFlag.FieldByName('Code').AsString := gPidiActiveData.Flag1;
      DmGiftProcessing.DmAccount.cdsFlag.Post;
    end;
    if IsEmptyStr(gPidiActiveData.Flag2) = False then begin
      DmGiftProcessing.DmAccount.cdsFlag.Insert;
      DmGiftProcessing.DmAccount.cdsFlag.FieldByName('Code').AsString := gPidiActiveData.Flag2;
      DmGiftProcessing.DmAccount.cdsFlag.Post;
    end;
    if IsEmptyStr(gPidiActiveData.Flag3) = False then begin
      DmGiftProcessing.DmAccount.cdsFlag.Insert;
      DmGiftProcessing.DmAccount.cdsFlag.FieldByName('Code').AsString := gPidiActiveData.Flag3;
      DmGiftProcessing.DmAccount.cdsFlag.Post;
    end;

    aNewForm := TfrmAccountMinEditClient.Create(Self, DmGiftProcessing, gpmeDonation,
       DmGiftProcessing.DmAccount.CurrentAccountId, Self.FormReadOnly,
       False, DmGiftProcessing.DmDonation.GiftProcMcdCaption);

    FitCenterForm(aNewForm);
    // 2/5/2015 gms d-05298 set result of function based on modal result
    Result := aNewForm.ShowModal = mrOK;
    gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction;
    SaveAction.Enabled := (DmGiftProcessing.DmDonation.cdsGiftProcessing.ChangeCount > 0) or
       (DmGiftProcessing.GetDMDataState in [fdsEdit, fdsInsert, fdsModified]);
    // Need to SetFocus back to the grid
    if (grdMain.Showing) and (grdMain.CanFocus) and (grdMain.Focused = False) then begin
      grdMain.SetFocus;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoMinAdd');
  end;
end;

procedure TfrmBatchGiftProcessing.DoMinEdit(pMinEditMode: TGiftProcMinEditMode;
   pAccountId: Integer; pLoop: Boolean);
var
  aNewForm: TfrmAccountMinEditClient;
//  aBatchClosed: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoMinEdit');
  try
    if pAccountId >= 1 then begin
      if dmPidiCoreClient.UserHasAccountAccess(pAccountId) then begin
       (* aBatchClosed := DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes *   Deprecated Aug 2014, moved to MinEdit
           [gpremAccountPeriodClosed, gpremPostedToGlClosed, gpremBatchMngClosed] <> []; *)

        aNewForm := TfrmAccountMinEditClient.Create(Self, DmGiftProcessing, pMinEditMode,
           pAccountId, Self.FormReadOnly, pLoop, DmGiftProcessing.DmDonation.GiftProcMcdCaption);

        FitCenterForm(aNewForm);
        aNewForm.ShowModal;
        gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction;
        SaveAction.Enabled := (DmGiftProcessing.DmDonation.cdsGiftProcessing.ChangeCount > 0) or
           (DmGiftProcessing.GetDMDataState in [fdsEdit, fdsInsert, fdsModified]);
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoMinEdit');
  end;
end;

procedure TfrmBatchGiftProcessing.RemoveFlagCode(pAccountID: Integer; pFlagCode: string);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.RemoveFlagCode');
  try
    if IsEmptyStr(pFlagCode) then begin
      Exit;
    end;
    DmGiftProcessing.DmAccount.cdsFlag.Delete;
    FNextFlagID := FNextFlagID + -1;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.RemoveFlagCode');
  end;
end;

procedure TfrmBatchGiftProcessing.btnViewBatchClick(Sender: TObject); var
  aNewForm: TfrmBatchLogGiftProcessingClient;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnViewBatchClick');
  try
    inherited;

    aNewForm := TfrmBatchLogGiftProcessingClient.Create(Self, blmHeaderViewOnlyMode,
       nil, DmGiftProcessing.DmDonation);
    aNewForm.ShowModal;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnViewBatchClick');
  end;
end;

procedure TfrmBatchGiftProcessing.txtBatchKeyPress(Sender: TObject; var Key: Char);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.txtBatchKeyPress');
  try
    inherited;

    if FIsBusyOutOfProcess = False then begin
      if Key = Chr(13) then begin
        if (dtpBatchDate.Showing) and (dtpBatchDate.CanFocus) then begin
          dtpBatchDate.SetFocus;
        end;
        Key := #0;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.txtBatchKeyPress');
  end;
end;

procedure TfrmBatchGiftProcessing.ShowVehicles;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowVehicles');
  try
    // 10/31/2014 gms b-05053 only load vehicles if account not found in dataset
    if (DmGiftProcessing.DmDonation.cdsDonatedVehicle.Locate('Account_ID',
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger, []) = False) then begin
      DmGiftProcessing.DmDonation.GiftProcLoadVehicles(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger);
    end;
    if DmGiftProcessing.DmDonation.cdsDonatedVehicle.RecordCount = 0 then begin
      gPidiDDGlobal.ErrorHandler.Clear;
      gPidiDDGlobal.ErrorHandler.Add('No Donated Vehicles for the Account', etValidation);
      gPidiDDGlobal.ErrorHandler.HandleErrors;

      if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
      end;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donated_Vehicle_ID').Clear;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').Clear;
    end else begin
      AttachVehicleToDonation(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger);
    end;
  finally
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowVehicles');
  end;
end;

(* 10/31/2014 gms b-05053 DEPRECATED empty procedure and no client overrides
procedure TfrmBatchGiftProcessing.CalcDefaultDonationAmount(pTotalFees: Currency);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CalcDefaultDonationAmount');
  try
    // Available for Override
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CalcDefaultDonationAmount');
  end;
end;
*)

procedure TfrmBatchGiftProcessing.AttachVehicleToDonation(pAccountID: Integer);
var
  aModelResult: Integer;
  aTotalFees: Currency;
  aPickVehicleFrm: TfrmPickVehicle;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AttachVehicleToDonation');
  try
    aPickVehicleFrm := nil;
    // DataSet Events.
    // 9/5/2013 gms d-04321 Set LoadingData to True to bypass dataset events instead of turning off events
    DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := True;
    // TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
    try
      aPickVehicleFrm := TfrmPickVehicle.Create(Self, DmGiftProcessing.DmDonation.cdsDonatedVehicle);
      aPickVehicleFrm.Caption := 'Select Vehicle to Attach to this Donation:';
      aModelResult := aPickVehicleFrm.ShowModal;

      if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
      end;
      if (aModelResult = mrOK) and (DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes *
         [gpremAccountPeriodClosed, gpremPostedToGlClosed, gpremBatchMngClosed, gpremCCEFTClosed] = []) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donated_Vehicle_ID').AsInteger := aPickVehicleFrm.VehicleID;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Item_Desc').AsString := aPickVehicleFrm.VehicleDesc;
        aTotalFees := 0.0;
        if not IsEmptyField(DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Associated_Fee1')) then begin
          aTotalFees := aTotalFees + DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Associated_Fee1').AsCurrency;
        end;
        if not IsEmptyField(DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Associated_Fee2')) then begin
          aTotalFees := aTotalFees + DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Associated_Fee2').AsCurrency;
        end;
        if not IsEmptyField(DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Associated_Fee3')) then begin
          aTotalFees := aTotalFees + DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Associated_Fee3').AsCurrency;
        end;
        if not IsEmptyField(DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Associated_Fee4')) then begin
          aTotalFees := aTotalFees + DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Associated_Fee4').AsCurrency;
        end;

        // 10/31/2014 gms b-05053 DEPRECATED empty procedure and no client overrides
        // CalcDefaultDonationAmount(aTotalFees);

        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Tax_Value').AsCurrency :=
           DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').AsCurrency - aTotalFees;
        if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Tax_Value').AsCurrency < 0.00 then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Tax_Value').AsCurrency := 0.00;
        end;
        if not DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_ITEM_DESCR) and
           (not FAnyVehicleDons) then begin
          grdMainTableViewItemDesc.Visible := True;
          // 11/4/2014 gms b-05053 after making column visible, add option to selected list if not already chosen
          if (not DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_SHOW_ITEM_DESCR)) then begin
            DmGiftProcessing.DmDonation.GiftProcSelectedUserOptions.Add(OPTION_SHOW_ITEM_DESCR);
          end;
        end;

        DmGiftProcessing.DmDonation.cdsDonatedVehicle.Edit;
        DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Donation_ID').AsInteger :=
           DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger;
        DmGiftProcessing.DmDonation.cdsDonatedVehicle.Post;
        FAnyVehicleDons := True;
        // 10/31/2014 gms b-05053  vehicle has been attached, change menu items
        mnuDetachVehicle.Enabled := True;
        mnuAttachVehicle.Enabled := False;
      end else begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donated_Vehicle_ID').Clear;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').Clear;
      end;
    finally
      aPickVehicleFrm.Free;
      // DataSet Events.
      // 9/5/2013 gms d-04321 Set LoadingData to True to bypass dataset events instead of turning off/on events
      // TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
      DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := False;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AttachVehicleToDonation');
  end;
end;

procedure TfrmBatchGiftProcessing.DetachVehicleFromDonation;
// 10/31/2014 gms b-05053 detach vehicle by clearing donation fields, donated_vehicle_id,
//   item_desc, and tax_value previously set in AttachVehicleToDonation.  Also, clear
//   the donation ID field in the Donated Vehicle dataset
var
  aVehicleID: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DetachVehicleFromDonation');
  try
    if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
    end;
    aVehicleID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donated_Vehicle_ID').AsInteger;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donated_Vehicle_ID').Clear;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Item_Desc').Clear;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Tax_Value').Clear;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').Clear;

    // if account not found in donated vehicle dataset, load vehicle records for account
    if (DmGiftProcessing.DmDonation.cdsDonatedVehicle.Locate('Account_ID',
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger, []) = False) then begin
      DmGiftProcessing.DmDonation.GiftProcLoadVehicles(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger);
    end;
    if DmGiftProcessing.DmDonation.cdsDonatedVehicle.Locate('Vehicle_ID', aVehicleID, []) then begin
      if not(DmGiftProcessing.DmDonation.cdsDonatedVehicle.State in [dsInsert, dsEdit]) then begin
        DmGiftProcessing.DmDonation.cdsDonatedVehicle.Edit;
        DmGiftProcessing.DmDonation.cdsDonatedVehicle.FieldByName('Donation_ID').Clear;
        DmGiftProcessing.DmDonation.cdsDonatedVehicle.Post;
      end;
    end;
    // vehicle has been detached, change menu items
    mnuDetachVehicle.Enabled := False;
    mnuAttachVehicle.Enabled := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DetachVehicleFromDonation');
  end;
end;

procedure TfrmBatchGiftProcessing.mnuDetachPledgeOnClick(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuDetachPledgeOnClick');
  try
    if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
    end;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Pledge_ID').Clear;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Fec').Clear;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuDetachPledgeOnClick');
  end;
end;

procedure TfrmBatchGiftProcessing.mnuAttachPledgeOnClick(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuAttachPledgeOnClick');
  try
    DmGiftProcessing.DmDonation.GiftProcAttachToPledge(False,
       DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger,
       DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsString);
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuAttachPledgeOnClick');
  end;
end;

procedure TfrmBatchGiftProcessing.puOptionsPopup(Sender: TObject);
var
  aHasPledge: Boolean;
  aAdjCode: string;
  aAccountID: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.puOptionsPopup');
  try
    inherited;

    aHasPledge := False;
    if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Pledge_ID')) = False then begin
      aHasPledge := (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Pledge_ID').AsInteger > 0);
    end;

    (* 11/10/2014 gms d-05210 DEPRECATED menu items now exist at design time
    aMenuItemDetach := nil;
    for i := 1 to puOptions.Items.Count do begin
      if Pos('Detach Pledge', puOptions.Items[i-1].Caption) > 0 then begin
        aMenuItemDetach := puOptions.Items[i-1];
        Break;
      end;
    end;
    aMenuItemAttach := puOptions.Items.Find('Attach Pledge');
    *)

    aAdjCode := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_Code').AsString;
    aAccountID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger;
    // 11/10/2014 gms d-05210 disable menu items for journaled pledges and
    //   adjustment original or backout records
    if (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').AsString = 'P') or
       (aAdjCode = 'A') or (aAdjCode = 'B') or (aAdjCode = 'E') then begin
      mnuAttachPledge.Enabled := False;
      mnuDetachPledge.Enabled := False;
      (* 11/10/2014 gms d-05210 DEPRECATED menu items now exist at design time and should not be freed
      if aMenuItemDetach <> nil then begin
        aMenuItemDetach.Free;
      end;
      if aMenuItemAttach <> nil then begin
        aMenuItemAttach.Free;
      end;
      exit;
      *)
    // 11/10/2014 gms d-05210 removed exit and just used else

    end else if aHasPledge then begin
      mnuDetachPledge.Enabled := (Self.FormReadOnly = False);
      mnuAttachPledge.Enabled := False;
    end else begin
      mnuDetachPledge.Enabled := False;
      if (DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremAccountPeriodClosed,
         gpremPostedToGlClosed, gpremBatchMngClosed] = []) and (aAccountID > 0) then begin
        mnuAttachPledge.Enabled := (Self.FormReadOnly = False);
      end else begin
        mnuAttachPledge.Enabled := False;
      end;
    end;

     //02/24/2015 RRR D-05313 The Writeoff Feature was removed.  User can now edit the donation in the grid
    //01/02/2015 RRR  D-05249
    //Enable Pledge Writeoffs for Split Journaled Pledges
(*  mnuWriteOff.Enabled := False;
    if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert,dsEdit] then begin
      mnuWriteOff.Enabled := False;
    end else if (aAdjCode = 'A') or (aAdjCode = 'B') or (aAdjCode = 'E') then begin
      mnuWriteOff.Enabled := False;
    end else if (Self.FormReadOnly = False) and
       (DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremAccountPeriodClosed,
          gpremPostedToGlClosed, gpremBatchMngClosed] = []) and
       (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').AsString = 'P') and
       (IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Linked_Gift_ID')) = False) then begin
      mnuWriteOff.Enabled := True;
    end;    *)

      // 11/10/2014 gms d-05210 aSponsoredName is DEPRECATED because it was only used by FOTO no longer a client
      (* 11/10/2014 gms d-05210 DEPRECATED menu items now exist at design time and should not be created
      if aMenuItemDetach <> nil then begin
        if not aHasPledge then begin
          puOptions.Items.Delete(aMenuItemDetach.MenuIndex);
          aMenuItemDetach.Free;
        end else if IsEmptyStr(aSponsoredName) = False then begin
          aMenuItemDetach.Caption := 'Detach Pledge from ' + aSponsoredName;
        end;
      end else if aHasPledge then begin
        aMenuItemDetach := TMenuItem.Create(Self);
        aMenuItemDetach.Name := 'mnuDetachPledge';
        aMenuItemDetach.Caption := 'Detach Pledge';
        if IsEmptyStr(aSponsoredName) = False then begin
          aMenuItemDetach.Caption := aMenuItemDetach.Caption + ' from ' + aSponsoredName;
        end;
        aMenuItemDetach.OnClick := mnuDetachPledgeOnClick;
        puOptions.items.add(aMenuItemDetach)
      end;

      if aMenuItemAttach <> nil then begin
        if aHasPledge or (aAdjCode = 'A') or (aAdjCode = 'B') or (aAdjCode = 'E') or (aAccountID < 0) then begin
          puOptions.Items.Delete(aMenuItemAttach.MenuIndex);
          aMenuItemAttach.Free;
        end;
      end else if (DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremAccountPeriodClosed,
                      gpremPostedToGlClosed, gpremBatchMngClosed] = []) and
                 (not aHasPledge) and (aAccountID > 0) then begin
        aMenuItemAttach := TMenuItem.Create(Self);
        aMenuItemAttach.Name := 'mnuAttachPledge';
        aMenuItemAttach.Caption := 'Attach Pledge';
        aMenuItemAttach.OnClick := mnuAttachPledgeOnClick;
        puOptions.Items.Add(aMenuItemAttach);
      end;
    end;
    *)
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.puOptionsPopup');
  end;
end;

function TfrmBatchGiftProcessing.HasChanges(pDataSet: TpidCdsProvider; pAccountID: Integer): Boolean;
var
  aDeltaDS: TClientDataSet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.HasChanges');
  try
    Result := False;
    if pDataSet.ChangeCount = 0 then begin
      Exit;
    end;

    aDeltaDS := nil;
    try
      aDeltaDS := TClientDataSet.Create(nil);
      aDeltaDS.Data := pDataSet.Delta;

      aDeltaDS.First;
      while not aDeltaDS.Eof do begin
        if aDeltaDS.FieldByName('Account_ID').AsInteger = pAccountID then begin
          if (aDeltaDS.UpdateStatus = usInserted) or (aDeltaDS.UpdateStatus = usDeleted) then begin
            Result := True;
          end else if aDeltaDS.UpdateStatus = usUnModified then begin
            aDeltaDS.Next;
            Result := aDeltaDS.UpdateStatus = usModified;
          end;
          Break;
        end;
        aDeltaDS.Next;
      end;
    finally
      aDeltaDS.Free;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.HasChanges');
  end;
end;

procedure TfrmBatchGiftProcessing.GenerateDataEntryLogSql(pDeLogSQLList: TStringList; pCopyGiftProcessing: TpidCDSProvider);
var
  aDonationID, aAccountID: Integer;
  aAccountIDStr: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GenerateDataEntryLogSql');
  try
    //04/28/2014 RRR D-04751 - Replaced cdsGiftProcessing with pCopyGiftProcessing
    //------------------------------------------------------------------------------
    pCopyGiftProcessing.Filtered := False;
    try
      pCopyGiftProcessing.First;
      while not pCopyGiftProcessing.Eof do begin
        aDonationID := pCopyGiftProcessing.FieldByName('Donation_ID').AsInteger;
        aAccountID := pCopyGiftProcessing.FieldByName('Account_ID').AsInteger;
        aAccountIDStr := IntToStr(aAccountID);
        if (pCopyGiftProcessing.FieldByName('AcctIDAssignedOnAdd').AsBoolean) then begin
          // New account - User added a new account in Master Search / Add Master
          if pCopyGiftProcessing.FieldByName('ProspectAdd').AsBoolean then begin
            AddDataEntryLogSQL(pDeLogSQLList, 'P', aAccountIDStr)
          end else begin
            AddDataEntryLogSQL(pDeLogSQLList, 'A', aAccountIDStr);
          end;
        end else begin
          // 5/17/2013 gms cdsGiftProcessing.OnNewRecord always gets a good new donation ID
          //   using the sequence.  Thus, the donation ID is never negative.
          //   Will use the VCL UpdateStatus method to determine if the record is inserted, etc.
          if pCopyGiftProcessing.UpdateStatus = usInserted then begin
            AddDataEntryLogSQL(pDeLogSQLList, GetDonationCode(), aAccountIDStr);  //usually 'D', could be 'd' for FAIR;
          end;
          if HasChanges(DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst, aAccountID) then begin
            AddDataEntryLogSQL(pDeLogSQLList, 'U', aAccountIDStr);
          end;
          if HasChanges(DmGiftProcessing.DmAccount.cdsPhone, aAccountID) then begin
            AddDataEntryLogSQL(pDeLogSQLList, 'Q', aAccountIDStr);
          end;
          if HasChanges(DmGiftProcessing.DmAccount.cdsEMail, aAccountID) then begin
            AddDataEntryLogSQL(pDeLogSQLList, 'V', aAccountIDStr);
          end;
          if HasChanges(DmGiftProcessing.DmAccount.cdsFlag, aAccountID) then begin
            AddDataEntryLogSQL(pDeLogSQLList, 'F', aAccountIDStr);
          end;
          if HasChanges(DmGiftProcessing.DmAccount.cdsInterest, aAccountID) then begin
            AddDataEntryLogSQL(pDeLogSQLList, 'I', aAccountIDStr);
          end;

          //11/13/2014 RRR D-05162
          //Temporarily only applies to CARE, eventually the first "if" will be removed
          //Will apply to all clients once we make a permanent fix to DELOG processing
          if gPidiDDGlobal.ClientAcronym = 'CARE' then begin
            if GetConfigPointYesNoBoolean('ACCT', 'Suppression Active') = True then begin
              if HasChanges(DmGiftProcessing.DmAccount.cdsSuppress, aAccountID) then begin
                AddDataEntryLogSQL(pDeLogSQLList, 'S', aAccountIDStr);
              end;
            end;
          end;
        end;

        if (pCopyGiftProcessing.FieldByName('Category').AsString = 'I') or
            (pCopyGiftProcessing.FieldByName('Category').AsString = 'H') then begin
          DmGiftProcessing.DmImoIho.cdsImoIho.Filtered := False;
          DmGiftProcessing.DmImoIho.cdsImoIho.Filter := 'Donation_ID = ' +
             pCopyGiftProcessing.FieldByName('Donation_ID').AsString;
          DmGiftProcessing.DmImoIho.cdsImoIho.Filtered := True;
          DmGiftProcessing.DmImoIho.cdsImoIho.First;
          while not DmGiftProcessing.DmImoIho.cdsImoIho.eof do begin
            if DmGiftProcessing.DmImoIho.cdsImoIho.FieldByName('AcctIDAssignedOnAdd').AsBoolean then begin
              AddDataEntryLogSQL(pDeLogSQLList, 'J', aAccountIDStr);
            end;
            DmGiftProcessing.DmImoIho.cdsImoIho.Next;
          end;
        end;
        DmGiftProcessing.DmImoIho.cdsImoIho.Filtered := False;

        if pCopyGiftProcessing.FieldByName('SoftCredit').AsBoolean then begin
          DmGiftProcessing.DmDonation.cdsSoftCredit.Filtered := False;
          DmGiftProcessing.DmDonation.cdsSoftCredit.Filter := 'Donation_ID = ' +
             pCopyGiftProcessing.FieldByName('Donation_ID').AsString;
          DmGiftProcessing.DmDonation.cdsSoftCredit.Filtered := True;
          DmGiftProcessing.DmDonation.cdsSoftCredit.First;
          while not DmGiftProcessing.DmDonation.cdsSoftCredit.Eof do begin
            if DmGiftProcessing.DmDonation.cdsSoftCredit.FieldByName('AcctIDAssignedOnAdd').AsBoolean then begin
              AddDataEntryLogSQL(pDeLogSQLList, 'J', aAccountIDStr);
            end;
            DmGiftProcessing.DmDonation.cdsSoftCredit.Next;
          end;
        end;

        if pCopyGiftProcessing.FieldByName('Category').AsString = 'G' then begin
          DmGiftProcessing.DmDonation.cdsGiftMembership.Filtered := False;
          DmGiftProcessing.DmDonation.cdsGiftMembership.Filter := 'Donor_DonID = ' +
             pCopyGiftProcessing.FieldByName('Donation_ID').AsString;
          DmGiftProcessing.DmDonation.cdsGiftMembership.Filtered := True;
          DmGiftProcessing.DmDonation.cdsGiftMembership.First;
          while not DmGiftProcessing.DmDonation.cdsGiftMembership.Eof do begin
            if DmGiftProcessing.DmDonation.cdsGiftMembership.FieldByName('AcctIDAssignedOnAdd').AsBoolean then begin
              AddDataEntryLogSQL(pDeLogSQLList, 'J', aAccountIDStr);
            end;
            DmGiftProcessing.DmDonation.cdsGiftMembership.Next;
          end;
        end;

        pCopyGiftProcessing.Next;
      end;
    finally
      pCopyGiftProcessing.First;
    end;
    //------------------------------------------------------------------------------
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GenerateDataEntryLogSql');
  end;
end;

function TfrmBatchGiftProcessing.GetDonationCode: string;   //FAIR Only
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetDonationCode');
  try
    Result := 'D';
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetDonationCode');
  end;
end;

procedure TfrmBatchGiftProcessing.AddJournaledPledge();
var
  // 07/05/2010 jmp PP-3497 jmp Remove legacy CC/EFT Support.
  aPrg, aAccountID: Integer;
  aAmount, aPlgAmount: Currency;
  aBatchDate: TDateTime;
  aFund, aMcd: String;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddJournaledPledge');
  try
    aAccountID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger;
    aBatchDate := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('BDate').AsDateTime;
    aAmount := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').AsCurrency;
    // DD- 1088  Donation amount is shown as plgAmount on Pledge tab.
    aMcd := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Mcd').AsString;
    aFund:= DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Fund').AsString;
    aPrg := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsInteger;
    aPlgAmount := aAmount;

    DmGiftProcessing.DmDonation.cdsPledge.Filtered := False;
    TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsPledge);
    try
      DmGiftProcessing.DmDonation.cdsPledge.Insert;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Pledge_ID').AsInteger := DmGiftProcessing.DmDonation.GetNextSeqNum('PLEDGE_SEQUENCE');
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('PlgType_ID').AsInteger := 3;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Account_ID').AsInteger := aAccountID;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Program').AsInteger := aPrg;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Mail_Code').AsString := aMcd;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Fund').AsString := aFund;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Created').AsString := GetCurrentDateStr;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Plg_Date').AsDateTime := aBatchDate;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Plg_Amount').AsCurrency := aPlgAmount;
      if gPidiDDGlobal.ClientAcronym = 'JCL' then begin
        DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Original_Amount').AsCurrency := aPlgAmount;
      end;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('PlgFreq_ID').AsInteger := 8;
      DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Journaled').AsString := 'Y';
      //8/26/2010 SN PP-4168 Unicef 5.8.8 bug: Adjusting a Pledge Payment caused SQL Error
      if IsEmptyField(DmGiftProcessing.DmDonation.cdsPledge.FieldByName('full_amount')) then begin
        DmGiftProcessing.DmDonation.cdsPledge.FieldByName('full_amount').AsCurrency := 0.00;
      end;
      if IsEmptyField(DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Original_Amount')) then begin
        DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Original_Amount').AsCurrency := 0.00;
      end;
      DmGiftProcessing.DmDonation.cdsPledge.Post();

      if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
      end;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Pledge_ID').AsInteger :=
         DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Pledge_ID').AsInteger;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Fec').AsString := 'L';
      // 11/24/2013 gms b-04654 Journaled Pledge record must have No_Calc = N;
      //  db triggers are also being updated to leave this setting alone
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('No_Calc').AsString := 'N';
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
    finally
      TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsPledge);
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddJournaledPledge');
  end;
end;

// Added 10/21/2013 RRR D-04371
//The Journaled Pledge should have a Tracking Record Pledge Record
//Create it if its not there
procedure TfrmBatchGiftProcessing.AddTrackingRecordPledge;
var
  aSql: string;
  aSQLResult: TStringList;
  aTRPCnt: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddTrackingRecordPledge');
  try
    aTRPCnt := 0;
    aSql := 'SELECT count(*) as nRec FROM Tracking_Record_Pledge WHERE Pledge_ID = ' +
       DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('pledge_id').AsString + ' and Tracking_ID = ' +
       DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('tracking_id').AsString;
    aSQLResult := nil;
    try
      aSQLResult := TStringList.Create();
      LoadAstaData_Singleton(aSQL, aSQLResult, True, True);
      if (aSQLResult.Count > 0) and (IsEmptyStr(aSQLResult.Values['nRec']) = False) then begin
        aTRPCnt := StrToIntDef(aSQLResult.Values['nRec'], 0);
      end;
    finally
      aSQLResult.Free;
    end;

    if aTRPCnt = 0 then begin
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.Insert;
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.FieldByName('Tracking_Record_Pledge_ID').AsInteger := dmPidiCoreClient.GetNextSeqNum('Tracking_Record_Pledge_Seq');
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.FieldByName('Tracking_ID').AsInteger := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('tracking_id').AsInteger;
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.FieldByName('Pledge_ID').AsInteger := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('pledge_id').AsInteger;
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.FieldByName('Primary_Ind').AsString := 'Y';
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.FieldByName('FMDate').AsdateTime := Date();
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.FieldByName('FMUserID').AsString := gPidiDDGlobal.UserName;
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.FieldByName('UpdDt').AsdateTime := Date();
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.FieldByName('UpdUserID').AsString := gPidiDDGlobal.UserName;
      DmGiftProcessing.DmContactTickler.cdsAvailPledges.Post;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddTrackingRecordPledge');
  end;
end;

// 02/23/2009 jmp DD-915 New restricted logic.
//Deprecated  06/05/2014 RRR D-04831  - Not necessary, Linked Gift Amount is already computed correctly
(*
function TfrmBatchGiftProcessing.AdjustLinkedGiftAmt: TStringList;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AdjustLinkedGiftAmt');
  try
    Result := nil;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AdjustLinkedGiftAmt');
  end;
end;       *)

// 3/12/2010 dd-3073 ccfa only (5.8.4) get event fields for donation
function TfrmBatchGiftProcessing.GetMgfDeleteSql(pList: TStringList): String;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetMgfDeleteSql');
  try
    // 1/15/2010 gms dd-2840 null out new matched_acctid field
    // 6/18/2010 gms pp-3592 add update to soft_credit table
    if ((IsEmptyStr(pList.Values['Soft_Credit_ID']) = False) and
       (StrToInt(pList.Values['Soft_Credit_ID']) > 0)) then begin
      Result := 'UPDATE SOFT_CREDIT SET MATCHED_DON_ID = NULL, ' +
                'MATCHING_STATUS = NULL, ' +
                'MATCHED_ACCOUNT_ID = NULL ' +
                'WHERE SOFT_CREDIT_ID = ' +
                 pList.Values['Soft_Credit_ID'] + ';';
    end else begin
      Result := 'UPDATE DONATION SET MATCHED_DON_ID = NULL, ' +
                'MATCHING_STATUS = NULL, ' +
                'MATCHED_ACCOUNT_ID = NULL ' +
                'WHERE DONATION_ID = ' +
                 pList.Values['Donor_DonID'] + ';';
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetMgfDeleteSql');
  end;
end;

function TfrmBatchGiftProcessing.GetMgfUpdateSql(pList: TStringList): String;
var
  aIsSoftCredit: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetMgfUpdateSql');
  try
    // 1/15/2010 gms dd-2840 potential matching gift will have corp_acctid but no corp_donid
    //   still want to set matched_account_id in this case so don't Exit
    if ((IsEmptyStr(pList.Values['Corp_DonID']) = True) and (IsEmptyStr(pList.Values['Corp_AcctID']) = True)) or
       (IsEmptyStr(pList.Values['Donor_DonID']) = True) then begin
      Exit;
    end;

    // 1/15/2010 gms dd-2840 set new matched_acctid field to acct of company
    //   matched_don_id will not be updated in case of potential match because this field
    //   has no value in this case.
    // 6/18/2010 gms pp-3592 add update to soft_credit table
    aIsSoftCredit := IsEmptyStr(pList.Values['Soft_Credit_ID']) = False;
    if aIsSoftCredit then begin
      Result := 'UPDATE SOFT_CREDIT SET  ';
    end else begin
      Result := 'UPDATE DONATION SET  ';
    end;
    // 1/21/2010 gms dd-2840 only re-set matching status when corporation has made the matching
    //    donation signified by the non-null value of corp_donid.  Corp_DonID is null when
    //    a potentially matching gift is made.
    if (IsEmptyStr(pList.Values['Corp_DonID']) = False) then begin
      Result := Result + 'MATCHED_DON_ID = ' + pList.Values['Corp_DonID'] + ', ' +
         'MATCHING_STATUS = ^4^, ';
    end;
    if (IsEmptyStr(pList.Values['Corp_AcctID']) = False) then begin
      Result := Result + 'MATCHED_ACCOUNT_ID = ' + pList.Values['Corp_AcctID'];
    end;
    if not aIsSoftCredit then begin
      Result := Result + ', ENTITY = ^' + pList.Values['Entity'] + '^ ' +
         'WHERE DONATION_ID = ' + pList.Values['Donor_DonID'] + ';'
    end else begin
      Result := Result + ' WHERE SOFT_CREDIT_ID = ' + pList.Values['Soft_Credit_ID'] + ';'
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetMgfUpdateSql');
  end;
end;

function TfrmBatchGiftProcessing.AddEmploymentRec(pList: TStringList): String;
var
  aEmpCnt: Integer;
  aCompany, aCity, aState, aPhone: string;
  aDonorAcctIDStr, aCorpAcctIDStr: string;
  aSql: string;
  aSQLResult: TStringList;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddEmploymentRec');
  try
    Result := '';
    aEmpCnt := 0;
    aDonorAcctIDStr := pList.Values['Donor_AcctID'];
    aCorpAcctIDStr := pList.Values['Corp_AcctID'];

    aSql := 'SELECT Count(*) AS EmpCount from Employment where (Account_ID = ' +
           aDonorAcctIDStr + ') and (Company_ID = ' + aCorpAcctIDStr + ')';
    aSQLResult := nil;
    try
      aSQLResult := TStringList.Create();
      LoadAstaData_Singleton(aSQL, aSQLResult, True, True);

      if (aSQLResult.Count > 0) and (IsEmptyStr(aSQLResult.Values['EmpCount']) = False) then begin
        aEmpCnt := StrToIntDef(aSQLResult.Values['EmpCount'], 0);
      end;
    finally
      aSQLResult.Free;
    end;

    if (aEmpCnt = 0) then begin
      aCompany := '';
      aCity := '';
      aState := '';
      aPhone := '';
      if DmGiftProcessing.DmAccount.cdsMaster.Findkey([pList.Values['Corp_AcctID']]) then begin
        aCompany := DmGiftProcessing.DmAccount.cdsMaster.FieldByName('FullName').AsString;
        aCity := DmGiftProcessing.DmAccount.cdsMaster.FieldByName('City').AsString;
        aState := DmGiftProcessing.DmAccount.cdsMaster.FieldByName('State').AsString;
        aPhone := DmGiftProcessing.DmAccount.cdsMaster.FieldByName('Primary_Phone').AsString;
      end;
      Result := 'INSERT INTO EMPLOYMENT (Account_ID, Entity, Company_ID, Company, City, State, Phone) VALUES (' +
         aDonorAcctIDStr + ',' + '''P'',' + aCorpAcctIDStr + ',' +
         QuotedStr(aCompany) + ',' + QuotedStr(aCity) + ',' + QuotedStr(aState) + ',' + QuotedStr(aPhone) + ');'
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddEmploymentRec');
  end;
end;

procedure TfrmBatchGiftProcessing.AddMasterHst(pAccountID: Integer; pField, pOldValue, pNewValue: string);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddMasterHst');
  try
    DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst.Insert;
    DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst.FieldByName('MasterHstID').AsInteger := -1;
    DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst.FieldByName('Account_ID').AsInteger := pAccountID;
    DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst.FieldByName('Field').AsString := pField;
    DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst.FieldByName('Old_Value').AsString := pOldValue;
    DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst.FieldByName('New_Value').AsString := pNewValue;
    DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst.FieldByName('Batch').AsString := txtBatch.Text;
    DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst.FieldByName('BDate').AsString := Copy(FBatchDateStr, 5, 2) + '/' +
       Copy(FBatchDateStr, 7, 2) + '/' + Copy(FBatchDateStr, 1, 4);
    DmGiftProcessing.DmAccount.DmHistory.cdsMasterHst.Post;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddMasterHst');
  end;
end;

procedure TfrmBatchGiftProcessing.ChangeMasterValue(pDataSet: TpidCdsProvider;
   pAccountID: Integer; pField, pNewValue: string);
var
  aOldValue: string;
  aTmpField: TField;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ChangeMasterValue');
  try
    if not(pDataSet.State in [dsInsert, dsEdit]) then begin
      pDataSet.Edit;
    end;
    aTmpField := pDataSet.FindField(pField);
    if aTmpField = nil then begin
      raise Exception.Create('ChangeMasterValue: Unable to find field: ' + pField);
    end;
    aOldValue := aTmpField.AsString;
    aTmpField.AsVariant := pNewValue;
    pDataSet.Post;
    AddMasterHst(pAccountID, aTmpField.DisplayLabel, aOldValue, pNewValue);
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ChangeMasterValue');
  end;
end;

procedure TfrmBatchGiftProcessing.AddDonationData(pDonationID: string; pStringList: TStringList);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddDonationData');
  try
    if not DmGiftProcessing.DmDonation.cdsGiftProcessing.Locate('Donation_ID', VarArrayOf([pDonationID]), []) then begin
      raise Exception.Create('Unable to find record for Donation_ID ' + pDonationID);
    end;
    AddFieldDataToList(DmGiftProcessing.DmDonation.cdsGiftProcessing, pStringList);
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AddDonationData');
  end;
end;

function TfrmBatchGiftProcessing.GetPremiumPageName: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetPremiumPageName');
  try
    Result := 'Premiums';
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetPremiumPageName');
  end;
end;

procedure TfrmBatchGiftProcessing.SetInsertDonation(const pValue: Boolean);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetInsertDonation');
  try
    FInsertDonation := pValue;
    btnSave.Action := SaveAction;
    btnSave.Visible := True;
    btnCancelAndClose.Enabled := True;
    btnCancelAndClose.Visible := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetInsertDonation');
  end;
end;

procedure TfrmBatchGiftProcessing.SetEditDonation(const pValue: Boolean);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetEditDonation');
  try
    FEditDonation := pValue;
    if ((pValue = True) and
       (DmGiftProcessing.DmDonation.DataModuleMode = dmmAdjBatch)) then begin
      Self.Caption := 'Adjust Donation';
    end else if ((pValue = True) and
       (DmGiftProcessing.DmDonation.DataModuleMode = dmmEditDonation)) then begin
      Self.Caption := 'Edit Donation';
    end else begin
      Self.Caption := 'Post Donations / Gift Processing';
    end;
    pnlButtons.Visible := not pValue;
    btnSave.Action := SaveAction;
    btnSave.Visible := True;
    btnCancelAndClose.Enabled := True;
    btnCancelAndClose.Visible := True;
    btnOptionsLower.Visible := pValue;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetEditDonation');
  end;
end;

procedure TfrmBatchGiftProcessing.LoadSingleDonation(pBDate: TDateTime; pBatch: String);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LoadSingleDonation');
  try
    try
      FWorkInProgress := True;      //02/20/2014 RRR D-04700  - will force warning msg to print
      dtpBatchDate.Date := pBDate;
      txtBatch.Text := pBatch;
      FBatchDateStr := FormatDateTime('yyyymmdd', dtpBatchDate.Date);
      ValidateBatchStatus(False);      //02/20/2014 RRR D-04700
      dsGiftProcessing.DataSet := DmGiftProcessing.DmDonation.cdsGiftProcessing;   //10/30/2013 RRR D-04455
      DoBatchSearch();
      navMain.Enabled := True;
    finally
      FWorkInProgress := False;        //02/20/2014 RRR D-04700
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LoadSingleDonation');
  end;
end;

procedure TfrmBatchGiftProcessing.ShowPledgeColumns;
// 10/8/2013 gms d-04386 called from applyoptionstogrid and GiftProcessingOnPrgChangeDataEventCallBack
//   to show pledge columns for sustainer donations
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowPledgeColumns');
  try
    mnuReallocateSustainerExtraAmount.Visible := True;
    grdMainTableViewPlgAmount.Visible := True;
    grdMainTableViewPlgFreqDesc.Visible := True;
    grdMainTableViewPlgMethodDesc.Visible := True;
    grdMainTableViewExtraAmount.Visible := True;
    if GetConfigPointYesNoBoolean('DNTPRC', 'Sustainer Class Active') = True then begin
      grdMainTableViewSustainerClass.Visible := True;
      grdMainTableViewRecurrence.Visible := True;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowPledgeColumns');
  end;
end;

procedure TfrmBatchGiftProcessing.SetEditDonationID(const pValue: Integer);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetEditDonationID');
  try
    FEditDonationID := pValue;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetEditDonationID');
  end;
end;

procedure TfrmBatchGiftProcessing.CheckDonationDeletes(aDeltaDS: TClientDataSet);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CheckDonationDeletes');
  try
    aDeltaDS.First;
    while not aDeltaDS.Eof do begin
      if (aDeltaDS.UpdateStatus = usDeleted) then begin
        DonationDeleted(aDeltaDS);
      end;
      aDeltaDS.Next;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CheckDonationDeletes');
  end;
end;

procedure TfrmBatchGiftProcessing.DonationDeleted(pDeltaDS: TClientDataSet);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DonationDeleted');
  try
    // Available for Override
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DonationDeleted');
  end;
end;

function TfrmBatchGiftProcessing.LastDonation(pAccountID: Integer; pBatchDate: TDateTime): Boolean;
var
  aMaxDate: TDateTime;
  aSql: string; 
  aSQLResult: TStringList;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LastDonation');
  try
    Result := False;
    aSQLResult := nil;
    try
      aSQLResult := TStringList.Create();

      aSQL := 'SELECT TO_CHAR(MAX(BDate), ''YYYYMMDD'') AS MAXDATE FROM Donation WHERE Account_ID = ' + IntToStr(pAccountID);

      LoadAstaData_Singleton(aSQL, aSQLResult, True, True);

      if (aSQLResult.Count > 0) and (IsEmptyStr(aSQLResult.Values['MAXDATE']) = False) then begin
        aMaxDate := StrToDateTime(FmtYmd(aSQLResult.Values['MAXDATE']));
        if pBatchDate = aMaxDate then begin
          Result := True;
        end;
      end;
    finally
      aSQLResult.Free;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LastDonation');
  end;
end;

procedure TfrmBatchGiftProcessing.GetSolicitor;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetSolicitor');
  try
    // Available for Override
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetSolicitor');
  end;
end;

procedure TfrmBatchGiftProcessing.ResetTaxValue;    //ACLU Only
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ResetTaxValue');
  try
    //  Available For Override
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ResetTaxValue');
  end;
end;

function TfrmBatchGiftProcessing.FindAdjustmentBatches(pAdjustOrigDonationCds: TPidCdsProvider): Boolean;
var
  aBatchLogAdjustPickList: TfrmBatchLogAdjustPickList;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FindAdjustmentBatches');
  try
    Result := False;

    try
      aBatchLogAdjustPickList := TfrmBatchLogAdjustPickList.Create(Self,
         pAdjustOrigDonationCds, DmGiftProcessing.DmDonation);
      // Always show picker screen for A2H / FA.  Required to select a batch or Cancel Mode.
      if gPidiDDGlobal.ClientAcronym = 'A2H' then begin
        aBatchLogAdjustPickList.ShowModal;
        Result := IsEmptyStr(DmGiftProcessing.DmDonation.AdjustBatchNo) = False;
        if Result = False then begin
          gPidiDDGlobal.ErrorHandler.Reset;
          gPidiDDGlobal.ErrorHandler.Add('User is required to select an Adjustment Batch. Cancelling adjustment.', etValidation);
          gPidiDDGlobal.ErrorHandler.HandleErrors;
        end;
      end else if aBatchLogAdjustPickList.AvailableAdjBatchCount = 0 then begin
        Result := True;
      end else begin
        Result := (aBatchLogAdjustPickList.ShowModal = mrOK);
      end;
    finally
      aBatchLogAdjustPickList.Free;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.FindAdjustmentBatches');
  end;
end;

procedure TfrmBatchGiftProcessing.Add2cdsDonationAdjustment(pAdjID, pBackOutID, pNewID: Integer);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.Add2cdsDonationAdjustment');
  try
    DmGiftProcessing.DmDonation.cdsDonationAdjustment.Append;
    DmGiftProcessing.DmDonation.cdsDonationAdjustment.FieldByName('Adjustment_ID').AsInteger := pNewID * -1;
    DmGiftProcessing.DmDonation.cdsDonationAdjustment.FieldByName('Original_ID').AsInteger := pAdjID;
    DmGiftProcessing.DmDonation.cdsDonationAdjustment.FieldByName('backedout_ID').AsInteger := pBackOutID;
    if pNewID <> 0 then begin
      DmGiftProcessing.DmDonation.cdsDonationAdjustment.FieldByName('adjusted_ID').AsInteger := pNewID;
    end;
    DmGiftProcessing.DmDonation.cdsDonationAdjustment.FieldByName('Adj_Reason_Code').AsString :=
       DmGiftProcessing.DmDonation.AdjustReasonCode;  // LastValidAdjReason;
    DmGiftProcessing.DmDonation.cdsDonationAdjustment.FieldByName('Comments').AsString :=
       DmGiftProcessing.DmDonation.AdjustComments;
    DmGiftProcessing.DmDonation.cdsDonationAdjustment.Post;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.Add2cdsDonationAdjustment');
  end;
end;

procedure TfrmBatchGiftProcessing.btnCancelAndCloseClick(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnCancelAndCloseClick');
  try
    inherited;
    DoCancel(2);
    FNoSave := True;
    ModalResult := mrCancel;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnCancelAndCloseClick');
  end;
end;

function TfrmBatchGiftProcessing.LookupSID(pIsAltID: Boolean; var pID: string): Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LookupSID');
  try
    Result := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.LookupSID');
  end;
end;

procedure TfrmBatchGiftProcessing.SetCultCode;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetCultCode');
  try
    // Available for Override
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetCultCode');
  end;
end;

procedure TfrmBatchGiftProcessing.SetChapter;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetChapter');
  try
    // Available for Override
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetChapter');
  end;
end;

procedure TfrmBatchGiftProcessing.btnViewRecordClick(Sender: TObject);
var
  aDoEditAccountRecord: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnViewRecordClick');
  try
    inherited;

    aDoEditAccountRecord := False;

    if DmGiftProcessing.DmDonation.cdsGiftProcessing.RecordCount > 0 then begin
      if (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger > 0) and
         (dmPidiCoreClient.UserHasAccountAccess(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger)) then begin
        if (DmGiftProcessing.DmDonation.cdsGiftProcessing.ChangeCount > 0) or
           (DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
          if MessageDlg('Batch has unsaved records and they will be posted and saved. Do you wish to continue?',
             mtConfirmation, [mbYes, mbNo], 0) = mrYes then begin
            if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit] then begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
            end;
            aDoEditAccountRecord := Self.ApplyHostUpdate;
          end;
        end else begin
          aDoEditAccountRecord := True;
        end;
      end;
    end;

    if aDoEditAccountRecord = True then begin
      DoGiftProcEditAccountRecord(gpmeDonation,
         DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger, True);
    
      if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_MINIMUM_EDIT) = False then begin
        Screen.Cursor := crHourGlass;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.DisableControls;
        FIsBusyOutOfProcess := True;
        try
          DoCancel(1);
          btnSearchClick(Sender);
        finally
          FIsBusyOutOfProcess := False;
          DmGiftProcessing.DmDonation.cdsGiftProcessing.EnableControls;
          Screen.Cursor := crDefault;
        end; 
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnViewRecordClick');
  end;
end;

procedure TfrmBatchGiftProcessing.btnPickBatchClick(Sender: TObject);
var
  aNewForm: TfrmBatchLogPickList;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnPickBatchClick');
  try
    inherited;
    aNewForm := nil;
    if (btnSearch.Caption = '&Cancel') then begin
      ShowMessage('Please Cancel First');
      Exit;
    end;
    // Pick a batch.
    try
      aNewForm := TfrmBatchLogPickList.Create(Self);
      if (aNewForm.ShowPickList() = mrOk) then begin
        txtBatch.text := aNewForm.batchNum;
        dtpBatchDate.date := aNewForm.batchDate;
        btnSearch.Enabled := True;
      end;
    finally
      aNewForm.free;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.btnPickBatchClick');
  end;
end;

procedure TfrmBatchGiftProcessing.PrintRoutine;
var
  frmBatchGalleySimple: TPrintBatchGalleySimple;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.PrintRoutine');
  try
    // To protect when DmDonation is null  TWM D-04441 10/23/2013
    if (Assigned(DmGiftProcessing) = True) and (DmGiftProcessing <> nil) and
       (Assigned(DmGiftProcessing.DmDonation) = True) and (DmGiftProcessing.DmDonation <> nil) then begin
      // Will release itself
      frmBatchGalleySimple := TPrintBatchGalleySimple.Create(Self, DmGiftProcessing.DmDonation);
      frmBatchGalleySimple.RunReport;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.PrintRoutine');
  end;
end;

function TfrmBatchGiftProcessing.UserCanEditThisRecord: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UserCanEditThisRecord');
  try
    Result := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UserCanEditThisRecord');
  end;
end;

(*  Deprecated April 2014
function TfrmBatchGiftProcessing.UserCanAddFlags: Boolean;  //CARE Only
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UserCanAddFlags');
  try
    Result := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UserCanAddFlags');
  end;
end; *)

procedure TfrmBatchGiftProcessing.SetSplitGift;
var
  aMcd, aFundCode: string;
  aDonationID, aPrg: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetSplitGift');
  try
    if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
    end;
    aDonationID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger;
    if DmGiftProcessing.DmDonation.cdsSplitDonation.Locate('Donation_ID', VarArrayOf([aDonationID]), []) then begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift').AsBoolean := True;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Fund').AsString := 'SPLIT';
    end else begin
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift').AsBoolean := False;
      if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Fund').AsString = 'SPLIT' then begin
        aMcd := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Mcd').AsString;
        if not IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg')) then begin
          aPrg := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsInteger;
        end else begin
          aPrg := 1;
        end;
        aFundCode := '';
        if (not IsEmptyStr(aMcd)) and (aPrg > 0) then begin
          if DmGiftProcessing.DmDonation.cdsMailCode.FindKey([aMcd, aPrg]) then begin
            aFundCode := DmGiftProcessing.DmDonation.cdsMailCode.FieldByName('Fund').AsString;
          end;
        end;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Fund').AsString := aFundCode;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SetSplitGift');
  end;
end;

// KEEP FOR NOW - ShowTab is using this!!
procedure TfrmBatchGiftProcessing.ShowSplitGifts;
var
  aFormReadOnly: Boolean;
  aNewForm: TfrmSplitGiftNewClient;
  aAdjCode: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowSplitGifts');
  try
    if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Linked_Gift_ID')) = False then begin
      if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
      end;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift').AsBoolean := False;
      // 12/6/2013 gms d-04561 changing to using DD validation form
      // ShowMessage('Donation already has Split Donations');
      gPidiDDGlobal.ErrorHandler.Reset;
      gPidiDDGlobal.ErrorHandler.Add('Donation already has Split Donations', etValidation);
      gPidiDDGlobal.ErrorHandler.HandleErrors;
      Exit;
    end;

    FWorkInProgress := True; // Suppresses RecordChanged Event
    DmGiftProcessing.DmDonation.cdsGiftProcessing.DisableControls;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := True;
    // 9/9/2013 gms d-04321 not needed - only operation on cdsGiftProcessing is to (possibly) go into
    //   edit mode and change some fields, will not be posting here.
    // TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
    //aSaveRO := False;
    try
      aFormReadOnly := (aAdjCode = 'A') or (aAdjCode = 'B') or (aAdjCode = 'E') or (Self.FormReadOnly = True) or
         (DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes *
//       [gpremAccountPeriodClosed, gpremPostedToGlClosed, gpremBatchMngClosed, gpremCCEFTClosed] <> []);   //02/11/2015 RRR D-05303
         [gpremAccountPeriodClosed, gpremPostedToGlClosed, gpremBatchMngClosed] <> []);                     //02/11/2015 RRR D-05303

      aNewForm := TfrmSplitGiftNewClient.Create(Self, DmGiftProcessing.DmDonation, aFormReadOnly);
      aAdjCode := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_code').AsString;
      (* 12/6/2013 gms d-04561 changing below code so that SetSplitGift is called regardless of
          ModalResult as long as aFormReadOnly is False
      if aNewForm.ShowModal <> mrCancel then begin
        if DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes *
           [gpremAccountPeriodClosed, gpremPostedToGlClosed, gpremBatchMngClosed, gpremCCEFTClosed] = [] then begin
          SetSplitGift;
        end;
      end;
      *)
      aNewForm.ShowModal;
      if aFormReadOnly = False then begin
        SetSplitGift;
      end;

      // 7/25/2014 gms d-04993 focusing on a grid column will allow split gift checkbox to be
      //   turned off if necessary; otherwise, the column will be checked (if no records) until
      //   clicking on the grid
      if grdMainTableViewAmount.Options.Focusing = True then begin
        grdMainTableViewAmount.Focused := True;
      end;

      //Removed this statement - Was causing dialog to re-appear    RRR 11/06/2013
      //Clicked post button immeadiately, did not reappear,  problem must have been fixed
//    ThreadedMoveToNextField;
    finally
      // aNewForm.Free;   don't free; form has action = caFree in FormClose
      // DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').ReadOnly := False;//aSaveRO;
      // 9/9/2013 gms d-04321 not needed - only operation on cdsGiftProcessing is to (possibly) go into
      //   edit mode and change some fields, will not be posting here.
      // TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
      DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := False;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.EnableControls;
      gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction; // MUST have this
      FWorkInProgress := False; // Suppresses RecordChanged Event
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowSplitGifts');
  end;
end;

//01/02/2015 RRR  D-05249
//When scrolling thru splitdonations, make sure donation filters are set correctly
procedure TfrmBatchGiftProcessing.cdsGiftProcessingAfterScroll(DataSet: TDataSet);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TdmDonation.cdsGiftProcessingAfterScroll');
  try
    DmGiftProcessing.DmDonation.GiftProcSetFilterOnDonationDatasets(Dataset.FieldByName('Donation_Id').AsInteger);
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TdmDonation.cdsGiftProcessingAfterScroll');
  end;
end;

 //01/02/2015 RRR  D-05249
 //Moved from ShowSplitDonations  below
procedure TfrmBatchGiftProcessing.ValidateSplitDonation(pDataSet: TpidCDSProvider; var pAnyErrors: Boolean);
var
  aPledgeID: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TdmDonation.ValidateSplitDonation');
  try
    if ((DmGiftProcessing.DmDonation.CreditCardBatch) and (gPidiEPSubSys.IsThirdPartyCCMode)) or
       ((DmGiftProcessing.DmDonation.EFTBatch) and (gPidiEPSubSys.IsThirdPartyEFTMode)) then begin
      if (pDataSet.FieldByName('CC_Last_Approval').AsString = 'A') then begin
        if (DmGiftProcessing.DmDonation.DataModuleMode <> dmmAdjBatch) then begin
          pAnyErrors := True;
          gPidiDDGlobal.ErrorHandler.Add('Donation is a Third Party Credit Card/EFT Transaction' + #13#10 +
             'Donation may only be split with an Adjustment', etValidation);
          end;
        end else begin
          pAnyErrors := True;
          gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation is a Third Party Credit Card/EFT Transaction' + #13#10 +
            'Donation may be split with an Adjustment once it has been Approved', etValidation);
       end;
     end;

     if DmGiftProcessing.DmDonation.cdsSoftCredit.RecordCount > 0 then begin
       pAnyErrors := True;
       gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation Contains Soft Credits' + #13#10 +
          'Remove All Soft Credits and then Continue Splitting', etValidation);
     end;

     if DmGiftProcessing.DmDonation.cdsPremium.RecordCount > 0 then begin
       pAnyErrors := True;
       gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation Contains Premiums' + #13#10 +
          'Remove All Premiums and then Continue Splitting', etValidation);
     end;

     if (pDataSet.FieldByName('Category').AsString = 'H') or
        (pDataSet.FieldByName('Category').AsString = 'I') then begin
       pAnyErrors := True;
       gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation Contains IMO/IHO Records' + #13#10 +
          'Remove All IMO/IHO Records and then Continue Splitting', etValidation);
     end;

     if pDataSet.FieldByName('Tracking_ID').AsInteger > 0 then begin   //RRR 09/19/2013  D-04367
       pAnyErrors := True;
       gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation is Attached to Tracking Records' + #13#10 +
          'Detach All Tracking Records and then Continue Splitting', etValidation);
     end;

     if pDataSet.FieldByName('Type').AsString = 'P' then begin
       aPledgeID := pDataSet.FieldByName('Pledge_ID').AsInteger;
       DmGiftProcessing.DmDonation.cdsPledge.Filtered := False;
       if DmGiftProcessing.DmDonation.cdsPledge.Locate('Pledge_ID', VarArrayOf([aPledgeID]), []) then begin
         if DmGiftProcessing.DmDonation.cdsPledge.FieldByName('AmountPaid').AsCurrency > 0 then begin
           pAnyErrors := True;
           gPidiDDGlobal.ErrorHandler.Add('Donation is a Journaled Pledge with Payments, Please Detach all Payments' + #13#10 +
              'Remember to Re-Attach Payments after Splitting', etValidation);
         end;
       end;
     end;

     if pDataSet.FieldByName('Matched_Don_ID').AsInteger > 0 then begin
       pAnyErrors := True;
       gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation Contains Matching Gifts', etValidation);
     end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TdmDonation.ValidateSplitDonation');
  end;
end;

// KEEP FOR NOW - ShowTab is using this!!
procedure TfrmBatchGiftProcessing.ShowSplitDonation;
// 12/30/2014 gms d-05250 removed pNewSplit; was not used
var
  aAdjCode: string;
  aNewForm: TfrmSplitDonationClient;
  aSaveHighDonID, aCurrDonID: Integer;
  aReadOnly, aLastRec: Boolean;
  aCopyDataSet: TpidCDSProvider;
  aAnyErrors, aDonationIsSplit: Boolean;  //01/02/2015 RRR  D-05249
  aDonationID, aLinkedGiftID: string;     //01/02/2015 RRR  D-05249
  aSaveBeforePost, aSaveAfterPost: TDataSetNotifyEvent;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowSplitDonation');
  try
    gPidiDDGlobal.ErrorHandler.Reset;
    aAnyErrors := False;
    if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount')) then begin
      aAnyErrors := True;
      gPidiDDGlobal.ErrorHandler.Add('Please Enter an Amount', etValidation);
    end else if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').AsCurrency = 0.0 then begin
      aAnyErrors := True;
      gPidiDDGlobal.ErrorHandler.Add('Please Enter an Amount', etValidation);
    end;

//  if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Linked_Gift_ID')) then begin


      //06/18/2014 RRR D-04907
      //If client uses Third Party Processing - Split Donations are not allowed before the transaction has been approved.
      //Once the donation is approved, the donation must be adjusted in order to split.

      //The adjustment can not proceed unless the batch is closed.  A message will be issued when the
      //adjustment is attempted indicating that the batch is not closed.
      //See IsCCEFTClosed procedure for a list of states that indicate the batch is closed.
      //The batch may be in an interim state such as CC_PROCED.  In this case the user must wait
      //until the batch moves into a closed state before the adjustment can proceed.

    //01/02/2015 RRR  D-05249
    if DmGiftProcessing.DmDonation.cdsGiftProcessing.State <> dsInsert then begin  //no need to check new donation
      aLinkedGiftID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Linked_Gift_ID').AsString;
      aDonationIsSplit := False;
      if IsEmptyStr(aLinkedGiftID) = False then begin
        ADonationIsSplit := True;  //Save the fact that the donation is already split
        aDonationID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsString; //Save the donation ID that was selected
      end;

      try
      //if its already split, copy the linked donations to a temporary dataset
      //--------------------------------------------------------------------------------------
        if aDonationIsSplit then begin
          aCopyDataSet := nil;
          aCopyDataSet := TpidCDSProvider.Create(nil);
          aSaveBeforePost := DmGiftProcessing.DmDonation.cdsGiftProcessing.BeforePost;
          aSaveAfterPost := DmGiftProcessing.DmDonation.cdsGiftProcessing.AfterPost;
          DmGiftProcessing.DmDonation.cdsGiftProcessing.BeforePost := nil;
          DmGiftProcessing.DmDonation.cdsGiftProcessing.AfterPost := nil;
          CopyCDSAssign(aCopyDataSet, DmGiftProcessing.DmDonation.cdsGiftProcessing,
             DmGiftProcessing.DmDonation.cdsGiftProcessing.Name + '_copy', True, False);
          DmGiftProcessing.DmDonation.cdsGiftProcessing.BeforePost := aSaveBeforePost;
          DmGiftProcessing.DmDonation.cdsGiftProcessing.AfterPost := aSaveAfterPost;
          aCopyDataSet.AfterScroll := cdsGiftProcessingAfterScroll;  //This makes sure Donation Filters are set
          aCopyDataSet.Data := DmGiftProcessing.DmDonation.cdsGiftProcessing.Data;
          aCopyDataSet.Filter :=   //Include only donations in this split
             '(Linked_Gift_ID = '+ aLinkedGiftID + ') and ((Adj_Code = ''N'') or (Adj_Code = ''D''))';
          aCopyDataSet.Filtered := True;
          aCopyDataSet.First;
        end;
      //--------------------------------------------------------------------------------------

      //Validation Loop
      //If already split, loop thru all the splits using temporary dataset to avoid iterating on cdsGiftProcessing
      //If not already split, go thru loop once using cdsGiftProcessing, no iterating
        aLastRec := False;
        repeat
          if aDonationIsSplit then begin   //if its already split, copy the linked donations to a temporary dataset
            ValidateSplitDonation(aCopyDataSet, aAnyErrors);    //Validate using temporary dataset
            aCopyDataSet.Next;
            if aCopyDataSet.Eof then begin
              aLastRec := True;
            end;
          end else begin
            ValidateSplitDonation(DmGiftProcessing.DmDonation.cdsGiftProcessing, aAnyErrors)  //Validate using cdsGiftProcessing
          end;
        until (aLastRec = True) or (aDonationIsSplit = False) or aAnyErrors;
        if aDonationIsSplit then begin  //if already split, Locate original donation to make sure filters are set correctly
          aCopyDataSet.Locate('Donation_ID', VarArrayOf([aDonationID]), []);
        end;

      finally
        if aDonationIsSplit then begin
          aCopyDataSet.Free;
        end;
      end;
    end;


//Validation Logic was moved above into ValidateSplitDonation   above
(*        if ((DmGiftProcessing.DmDonation.CreditCardBatch) and (gPidiEPSubSys.IsThirdPartyCCMode)) or
             ((DmGiftProcessing.DmDonation.EFTBatch) and (gPidiEPSubSys.IsThirdPartyEFTMode)) then begin
            if (aCopyDataSet.FieldByName('CC_Last_Approval').AsString = 'A') then begin
              if (DmGiftProcessing.DmDonation.DataModuleMode <> dmmAdjBatch) then begin
                aAnyErrors := True;
                gPidiDDGlobal.ErrorHandler.Add('Donation is a Third Party Credit Card/EFT Transaction' + #13#10 +
                   'Donation may only be split with an Adjustment', etValidation);
              end;
            end else begin
              aAnyErrors := True;
              gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation is a Third Party Credit Card/EFT Transaction' + #13#10 +
                 'Donation may be split with an Adjustment once it has been Approved', etValidation);
            end;
          end;

          if DmGiftProcessing.DmDonation.cdsSoftCredit.RecordCount > 0 then begin
            aAnyErrors := True;
            gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation Contains Soft Credits' + #13#10 +
               'Remove All Soft Credits and then Continue Splitting', etValidation);
          end;

          if DmGiftProcessing.DmDonation.cdsPremium.RecordCount > 0 then begin
            aAnyErrors := True;
            gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation Contains Premiums' + #13#10 +
               'Remove All Premiums and then Continue Splitting', etValidation);
          end;

          if (aCopyDataSet.FieldByName('Category').AsString = 'H') or
             (aCopyDataSet.FieldByName('Category').AsString = 'I') then begin
            aAnyErrors := True;
            gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation Contains IMO/IHO Records' + #13#10 +
               'Remove All IMO/IHO Records and then Continue Splitting', etValidation);
          end;

          if aCopyDataSet.FieldByName('Tracking_ID').AsInteger > 0 then begin   //RRR 09/19/2013  D-04367
            aAnyErrors := True;
            gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation is Attached to Tracking Records' + #13#10 +
               'Detach All Tracking Records and then Continue Splitting', etValidation);
          end;

          if aCopyDataSet.FieldByName('Type').AsString = 'P' then begin
            aPledgeID := aCopyDataSet.FieldByName('Pledge_ID').AsInteger;
            DmGiftProcessing.DmDonation.cdsPledge.Filtered := False;
            if DmGiftProcessing.DmDonation.cdsPledge.Locate('Pledge_ID', VarArrayOf([aPledgeID]), []) then begin
              if DmGiftProcessing.DmDonation.cdsPledge.FieldByName('AmountPaid').AsCurrency > 0 then begin
                aAnyErrors := True;
                gPidiDDGlobal.ErrorHandler.Add('Donation is a Journaled Pledge with Payments, Please Detach all Payments' + #13#10 +
                   'Remember to Re-Attach Payments after Splitting', etValidation);
              end;
            end;
          end;
//  end;

          if aCopyDataSet.FieldByName('Matched_Don_ID').AsInteger > 0 then begin
            aAnyErrors := True;
            gPidiDDGlobal.ErrorHandler.Add('Cannot Split Donation, Donation Contains Matching Gifts', etValidation);
          end;  *)

    if gPidiDDGlobal.ErrorHandler.HandleErrors then begin
      if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Linked_Gift_ID')) then begin
        if not (DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert,dsEdit]) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
        end;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift2').AsBoolean := False;   //06/18/2014 RRR D-04907
      end;
      BusinessRuleAbort;
    end;

    DmGiftProcessing.DmDonation.cdsGiftProcessing.DisableControls;
    // 9/11/2013 gms d-04321 DEPRECATED TurnOff/TurnOn not needed; setting dataset.LoadingData to
    //   True will bypass all relevant event methods.
    DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := True;
    // TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
    FWorkInProgress := True;
    try
      aAdjCode := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_code').AsString;
      aCurrDonID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('DonID').AsInteger;
      aSaveHighDonID := DmGiftProcessing.DmDonation.GiftProcDonationGridSequence;

      try
        aReadOnly := (aAdjCode = 'A') or (aAdjCode = 'B') or (aAdjCode = 'E') or (Self.FormReadOnly = True) or
           (DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes *
           [gpremAccountPeriodClosed, gpremPostedToGlClosed, gpremBatchMngClosed] <> []);


        aNewForm := TfrmSplitDonationClient.Create(Self, DmGiftProcessing.DmDonation, DmGiftProcessing.DmImoIho,
          DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes,
          DmGiftProcessing.DmDonation.GiftProcDonationGridSequence, aReadOnly);

        FAnySplitDonations := False;

        if aNewForm.ShowModal = mrOK then begin
          FAnySplitDonations := True;
          // 7/3/2013 gms TEMPORARY FIX to calculate totals;  needed here because SplitDonationFrm
          //   procedures UpdateDonations and DeleteDonations turn off events; thus the
          //   cdsGiftProcessing AfterPost and AfterDelete is not called (which calls CalcTotals)
          DmGiftProcessing.DmDonation.GiftProcCalcTotals();
          DisplayQtys;
          FWorkInProgress := True;  // DisplayQtys turned it off, need it on to close dialog
        end;

        // 9/12/2013 gms d-04321 use copy of cdsGiftProcessing in the loop to get max of donid
        aCopyDataSet := nil;
        try
          aCopyDataSet := TpidCDSProvider.Create(nil);
          CopyCDSAssign(aCopyDataSet, DmGiftProcessing.DmDonation.cdsGiftProcessing,
             DmGiftProcessing.DmDonation.cdsGiftProcessing.Name + '_copy', True, False);
          aCopyDataSet.Data := DmGiftProcessing.DmDonation.cdsGiftProcessing.Data;

          aCopyDataSet.First;
          while not aCopyDataSet.Eof do begin
            if aCopyDataSet.FieldByName('DonID').AsInteger > DmGiftProcessing.DmDonation.GiftProcDonationGridSequence then begin
              DmGiftProcessing.DmDonation.GiftProcDonationGridSequence := aCopyDataSet.FieldByName('DonID').AsInteger;
            end;
            aCopyDataSet.Next;
          end;
        finally
          aCopyDataSet.Free;
        end;

        // 10/24/08 gms code added from 5.5
        // 9/12/2013 gms d-04321 Below code is needed so that the cursor is placed on the last
        //   split record - same behavior as in 6.2
        if DmGiftProcessing.DmDonation.GiftProcDonationGridSequence > aSaveHighDonID then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.Locate('DonID',
             VarArrayOf([DmGiftProcessing.DmDonation.GiftProcDonationGridSequence]), []);
        end else begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.Locate('DonID', VarArrayOf([aCurrDonID]), []);
        end;

        if grdMainTableViewAmount.Options.Focusing = True then begin
          grdMainTableViewAmount.Focused := True;
        end;
      finally
        // aNewForm.Free; don't free; form has action = caFree in FormClose
        gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction;
      end;
    finally
      if FAnySplitDonations then begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, True);

        //12/20/2013 RRR D-04480
        //Do not allow change of Mail Code, Program or Fund on Journaled Pledges
        //Must do on Split Donation Screen to insure that Pledge and Donation match up
        if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').AsString = 'P' then begin
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewMcd, True);
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPrg, True);
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewFundCode, True);
        end;
      end;

      // 9/11/2013 gms d-04321 DEPRECATED TurnOff/TurnOn not needed; setting dataset.LoadingData to
      //   True will bypass all relevant event methods.
      DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := False;
      // TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
      DmGiftProcessing.DmDonation.cdsGiftProcessing.EnableControls;
      FWorkInProgress := False;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowSplitDonation');
  end;
end;

procedure TfrmBatchGiftProcessing.ShowSplitGroups;
var
  aNewForm: TfrmSplitGroupsClient;
  aRepost: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowSplitGroups');
  try
    aNewForm := nil;
    try
      aNewForm := TfrmSplitGroupsClient.Create(Self);
      // This line causes the groups to be loaded for the mail code.
      // It needs to be called First.
      aNewForm.MailCode  := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('mcd').AsString;
      if aNewForm.MailCodeEventGroups = 0 then begin
        gPidiDDGlobal.ErrorHandler.Reset;
        gPidiDDGlobal.ErrorHandler.Add('The selected donation Mail Code: "' + aNewForm.MailCode +
                    '" does not have any Event Groups associated with it. ' + #10#13 +
                    'Please configure an Event for this Mail Code first.', etValidation);
        gPidiDDGlobal.ErrorHandler.HandleErrors;
        try
          DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := True;
          aRepost := DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsBrowse;
          if (aRepost = True) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
          end;
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('GroupDonations').AsBoolean := False;
        finally
          if (aRepost = True) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
          end;
          DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := False;
        end;
      end else begin
        // This line causes a load of the donation records.
        aNewForm.DonationID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_ID').AsInteger;
        aNewForm.AccountID  := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger;
        aNewForm.DonorName  := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('FullName').AsString;
        aNewForm.DonDate    := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('BDate').AsDateTime;
        aNewForm.DonAmount  := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').AsCurrency;

        aNewForm.ReadOnly :=
           (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_code').AsString = 'A') or
           (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_code').AsString = 'B') or
           (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_code').AsString = 'E') or
           (Self.FormReadOnly = True);

        aNewForm.ShowModal();
      end;
    finally
      aNewForm.Free();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowSplitGroups');
  end;
end;

function TfrmBatchGiftProcessing.UserCanSeeThisBatch: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UserCanSeeThisBatch');
  try
    Result := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.UserCanSeeThisBatch');
  end;
end;

procedure TfrmBatchGiftProcessing.GetDonationCount(pAccountIDStr: string);  //Spinal Only
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetDonationCount');
  try
    FDonationCount := 1;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.GetDonationCount');
  end;
end;

// 01/03/2009 jmp New MailCode picklist functionality.
// 01/12/2009 jmp New solicitor functionality.
procedure TfrmBatchGiftProcessing.ShowSolicitor();
var
  aNewForm: TfrmSolicitorClient;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowSolicitor');
  try
    aNewForm := nil;
    try
      aNewForm := TfrmSolicitorClient.Create(Self);
      aNewForm.SetSolicitorEvent(SolicitorEvent);
      // Edit solicitors
      aNewForm.RecordDonationSolicitationsMode(DmGiftProcessing.DmDonation,
         DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('donation_id').AsInteger,
         DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('fullname').AsString,
         DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('batch').AsString,
         DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('bdate').AsDateTime,
         False, False);
      // Clear the event
      aNewForm.SetSolicitorEvent(nil);
    finally
      aNewForm.Free();
    end;
  finally
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowSolicitor');
  end;
end;

procedure TfrmBatchGiftProcessing.SolicitorEvent(pSolicitorList: string);
var
  aSaveBeforePost: TDataSetNotifyEvent;
  aSaveAfterPost: TDataSetNotifyEvent;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SolicitorEvent');
  try
    aSaveBeforePost := DmGiftProcessing.DmDonation.cdsGiftProcessing.BeforePost;
    aSaveAfterPost := DmGiftProcessing.DmDonation.cdsGiftProcessing.AfterPost;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.BeforePost := nil;
    DmGiftProcessing.DmDonation.cdsGiftProcessing.AfterPost := nil;
    // Update the donation Solicitor_List.
    try
      DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('solicitor_list').AsString := pSolicitorList;
      if (grdMain.Showing) and (grdMain.CanFocus)  and (grdMain.Focused = False) then begin
        grdMain.SetFocus();
      end;
    finally
      DmGiftProcessing.DmDonation.cdsGiftProcessing.BeforePost := aSaveBeforePost;
      DmGiftProcessing.DmDonation.cdsGiftProcessing.AfterPost := aSaveAfterPost;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.SolicitorEvent');
  end;
end;

procedure TfrmBatchGiftProcessing.splMainAfterOpen(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.splMainAfterOpen');
  try
    inherited;
    // 12/2/2013 gmsa d-04501 Ensure current record is in view when the window is resized
    //   or if the splitter is opened or moved
    if grdMainTableView.Controller.FocusedRecord <> nil then begin
      grdMainTableView.Controller.FocusedRecord.MakeVisible;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.splMainAfterOpen');
  end;
end;

procedure TfrmBatchGiftProcessing.splMainMoved(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.splMainMoved');
  try
    inherited;
    // 12/2/2013 gmsa d-04501 Ensure current record is in view when the window is resized
    //   or if the splitter is opened or moved
    if grdMainTableView.Controller.FocusedRecord <> nil then begin
      grdMainTableView.Controller.FocusedRecord.MakeVisible;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.splMainMoved');
  end;
end;

// 03/11/2009 jmp DD-1202 Method to reload donor info.
procedure TfrmBatchGiftProcessing.mnuReloadDonorInfoClick(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuReloadDonorInfoClick');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.mnuReloadDonorInfoClick';
  try
    inherited;

    if DmGiftProcessing.DmDonation.GiftProcIsValidAccountId(
       DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger, gpvaDonation) then begin
      DmGiftProcessing.DmDonation.GiftProcSetAccountData;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuReloadDonorInfoClick');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.mnuReloadDonorInfoClick';
  end;
end;

 //02/24/2015 RRR D-05313 The Writeoff Feature was removed.  User can now edit the donation in the grid
(*
procedure TfrmBatchGiftProcessing.mnuWriteOffClick(Sender: TObject);
var
  aNewForm: TfrmPledgeWriteOffClient;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuWriteOffClick');
  try
    inherited;

    aNewForm := TfrmPledgeWriteOffClient.Create(Self, DmGiftProcessing.DmDonation);
    if aNewForm.ShowModal = mrOK then begin

    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuWriteOffClick');
  end;
end;   *)

procedure TfrmBatchGiftProcessing.mnuAttachTrackingRecordClick(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuAttachTrackingRecordClick');
  try
    inherited;
    DmGiftProcessing.DmDonation.GiftProcAttachTrackingRecord(DmGiftProcessing.DmDonation.cdsGiftProcessing, 'Account_id');
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuAttachTrackingRecordClick');
  end;
end;

procedure TfrmBatchGiftProcessing.mnuAttachVehicleClick(Sender: TObject);
var
  aType: string;
  aShowVehicles: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuAttachVehicleClick');
  try
    inherited;
    aShowVehicles := False;
    aType := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').AsString;
    if aType = 'V' then begin
      aShowVehicles := True;
    end else begin
      if MessageDlg('Change Donation Type to Vehicle?', mtConfirmation, [mbYes, mbNo], 0) = mrYes then begin
        if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
        end;
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').AsString := 'V';
        aShowVehicles := True;
      end;
    end;
    if aShowVehicles then begin
      ShowVehicles;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuAttachVehicleClick');
  end;
end;

procedure TfrmBatchGiftProcessing.mnuDetachVehicleClick(Sender: TObject);
// 10/31/2014 gms b-05053 new menu item to detach vehicle
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuDetachVehicleClick');
  try
    inherited;
    if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donated_Vehicle_ID')) = False then begin
      if MessageDlg('Are you sure you want to detach the vehicle ' +
         DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Item_Desc').AsString, mtConfirmation, mbYesNoCancel, 0) = mrYes then begin
        DetachVehicleFromDonation();
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuDetachVehicleClick');
  end;
end;

function TfrmBatchGiftProcessing.DeferConstraintsSQL: TStringList;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DeferConstraintsSQL');
  try
    Result := TStringList.Create;
    Result.Add('EXECUTE IMMEDIATE ''ALTER SESSION SET CONSTRAINTS = DEFERRED'';')
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DeferConstraintsSQL');
  end;
end;

// 04/29/2010 jmp D-02002 New feature.
procedure TfrmBatchGiftProcessing.mnuReallocateSustainerExtraAmountClick(Sender: TObject);
var
  aVal: string;
  aOldAmt: Double;
  aOldExAmt: Double;
  aNewAmt: Double;
  aNewExAmt: Double;
  aRO: Boolean;
  aEditing: Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuReallocateSustainerExtraAmountClick');
  try
    inherited;
    // Get new extra amount from user.
    aVal := Trim(InputBox('What is the Total Extra Amount?',
                          'Total Extra Amount:', '0.00'));
    if not IsEmptyStr(aVal) then begin
      // Validate user input.
      aNewExAmt := StrToFloat(aVal);
      if (aNewExAmt >= 0.00) then begin
        // Calculate new amounts.
        aOldAmt := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('amount').AsCurrency;
        aOldExAmt := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('extra_amount').AsCurrency;

        if (aNewExAmt <= (aOldAmt + aOldExAmt)) then begin
          aNewAmt := aOldAmt + aOldExAmt - aNewExAmt;
          // DataSet Events.
          DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := True;
          // 9/9/2013 gms d-04321 using LoadingData now instead of TurnOffEvents
          // TurnOffEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
          try
            aEditing := DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsEdit, dsInsert];
            if not aEditing then begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit();
            end;
            aRO := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('amount').ReadOnly;
            pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, False);
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('amount').AsCurrency := aNewAmt;
            if aRO then begin
              pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, True);
            end;

            aRO := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('extra_amount').ReadOnly;
            pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewExtraAmount, False);
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('extra_amount').AsCurrency := aNewExAmt;
            if aRO then begin
              pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewExtraAmount, True);
            end;
            if not aEditing then begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.Post();
            end;
            gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction;
            SaveAction.Enabled := True;
            gPidiDDGlobal.MainMenuButtonSave.Enabled := True;
          finally
            // DataSet Events.
            // 9/9/2013 gms d-04321 using LoadingData now instead of TurnOffEvents
            // TurnOnEvents(FEventList, DmGiftProcessing.DmDonation.cdsGiftProcessing);
            DmGiftProcessing.DmDonation.cdsGiftProcessing.LoadingData := False;
          end;
        end else begin
          ShowMessage('The Extra Amount Cannot Exceed the Original Total Amount');
        end;
      end else begin
        ShowMessage('The Extra Amount Must be Positive and Greater Than or Equal to Zero.');
      end;
    end else begin
      ShowMessage('A Positive Value is Required.');
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.mnuReallocateSustainerExtraAmountClick');
  end;
end;

//*****************************************************************************
// begin: GRID FUNCTIONS SECTION
//*****************************************************************************
(* 6/19/2014 gms b-05611 no longer using threads to move field to field
procedure TfrmBatchGiftProcessing.ThreadedMoveToField(pDevExpressGridView: TPIDIDBTableView; pFieldName: string);
var
  aThread: TUIThread;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ThreadedMoveToField');
  try
    aThread := TUIThread.Create(True);
    aThread.OwnerForm := Self;
    aThread.FDevExpressGridView := pDevExpressGridView;
    aThread.FFieldName := pFieldName;
    aThread.Resume();
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ThreadedMoveToField');
  end;
end;
*)

procedure TfrmBatchGiftProcessing.MoveToField();
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.MoveToField()');
  try
    MoveToField(FTempMoveDevExpressGridView, FTempMoveFieldName);
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.MoveToField()');
  end;
end;

procedure TfrmBatchGiftProcessing.MoveToField(pDevExpressGridView: TPIDIDBTableView; pFieldName: string);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.MoveToField(x,y)');
  try
    if (DmGiftProcessing <> nil) then begin
      if (DmGiftProcessing.DmDonation.cdsGiftProcessing.IsEmpty = False) then begin
        // Focus the field
        if pDevExpressGridView.Visible then begin
          pDevExpressGridView.Focused := True;
          // Better choice for keyboard navigation??
          pDevExpressGridView.GetColumnByFieldName(pFieldName).FocusWithSelection;
        end;
        // Show the correct tab if this is coming from the main donation grid.
        (* 6/30/2014 gms B-05704 DEPRECATED not needed; ShowTab now called in OnFocusedItemChanged
        if (pDevExpressGridView = grdMainTableView) then begin
          ShowTab;
        end;
        *)
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.MoveToField(x,y)');
  end;
end;

(* 6/19/2014 gms b-05611 no longer using threads to move field to field
procedure TfrmBatchGiftProcessing.ThreadedMoveToNextField;
var
  aThread: TUIThread;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ThreadedMoveToNextField');
  try
    aThread := TUIThread.Create(True);
    aThread.OwnerForm := Self;
    aThread.Resume();
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ThreadedMoveToNextField');
  end;
end;
*)

procedure TfrmBatchGiftProcessing.MoveToNextField;
var
  aAmountIndex: Integer;
  i, aEditableColumnIndex: Integer;
  aAmountColumnEditable: Boolean;
  aFocusedItemFieldName: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.MoveToNextField');
  try
    if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID')) then begin
      MoveToField(grdMainTableView, 'Account_ID');
    end else if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Mcd')) then begin
      MoveToField(grdMainTableView, 'Mcd');
    end else if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg')) then begin
      MoveToField(grdMainTableView, 'Prg');
    // 2/22/2013 gms sometimes Amount was set to $0.00 (credit card batch) but field is still
    //   editable (because client not IsThirdPartyCCMode)
    end else if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount')) or
       ((DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').AsCurrency = 0.0) and
           grdMainTableViewAmount.Options.Editing) then begin
      MoveToField(grdMainTableView, 'Amount');
    end else if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type')) then begin
      MoveToField(grdMainTableView, 'Type');
    end else begin
      // get the fieldname of the currently focused column, if available
      if (FFocusedGridTableItem <> nil) and (TcxGridDBColumn(FFocusedGridTableItem).DataBinding <> nil) then begin
        aFocusedItemFieldName := TcxGridDBColumn(FFocusedGridTableItem).DataBinding.FieldName;
      end else begin
        aFocusedItemFieldName := '';
      end;

      // Move to the field just past Amount.
      aAmountIndex := grdMainTableView.GetColumnByFieldName('Amount').Index;
      aAmountColumnEditable := grdMainTableView.GetColumnByFieldName('Amount').Options.Editing = True;
      // aDidMove := False;

      // Find a column that is visible, editable and can focus. The preference is for the first column
      //  after the amount column.  If nothing after amount is editable, take the last column
      //  found that is editable.
      aEditableColumnIndex := -1;
      for i := 0 to grdMainTableView.ColumnCount - 1 do begin
        // 8/26/2013 gms 2 criteria for a column eligible for moving to:
        //    1 visible, editable, focusable,  and not equal to current focused item
        //    2 Donation Type column always eligible if visible and focusable
        if ((grdMainTableView.Columns[i].Visible = True) and
            (grdMainTableView.Columns[i].Options.Editing = True) and
            (grdMainTableView.Columns[i].Options.Focusing = True) and
            (grdMainTableView.Columns[i].DataBinding.FieldName <> aFocusedItemFieldName)) or
           ((grdMainTableView.Columns[i].Visible = True) and (grdMainTableView.Columns[i].Options.Focusing = True) and
            (grdMainTableView.Columns[i].DataBinding.FieldName = 'Type')) then begin
          aEditableColumnIndex := i;
          if aEditableColumnIndex > aAmountIndex then begin
            Break;
          end;
        end;
      end;

      if (aEditableColumnIndex < 0) and aAmountColumnEditable then begin
        aEditableColumnIndex := aAmountIndex;
      end;

      if aEditableColumnIndex >= 0 then begin
        MoveToField(grdMainTableView, grdMainTableView.Columns[aEditableColumnIndex].DataBinding.FieldName);
        FFocusedGridTableItem := grdMainTableView.Columns[aEditableColumnIndex];
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.MoveToNextField');
  end;
end;

// When a column changes, we need to display the correct tab.
// This is a generic method that several columns point to...like DonType, GiftType, etc.
// You can also put special behavior in here based on specific column changes.
procedure TfrmBatchGiftProcessing.StandardGridColumnOnChange(Sender: TObject);
var
  aPlgAmount, aDonAmount: Currency;
  aPlgFreqID: Integer;
  aNewDonType: string;
  aDonTypeField: TField;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.StandardGridColumnOnChange');
  try
    inherited;
    if (DmGiftProcessing <> nil) then begin
      if (DmGiftProcessing.DmDonation.cdsGiftProcessing.IsEmpty = False) then begin

        // 4/16/2014 gms b-05022 Amount field change
        //   when adjusting cc or eft donations that have been processed, only allow amount to be changed to 0
        if (grdMainTableViewAmount.Focused = True) and (DmGiftProcessing.DataModuleMode = dmmAdjBatch) and
           (DmGiftProcessing.DmDonation.IsCCEFTClosed(DmGiftProcessing.DmDonation.AdjustOrigDonationCds.FieldByName('Batch').AsString,
              DmGiftProcessing.DmDonation.AdjustOrigDonationCds.FieldByName('BDate').AsDateTime)) then begin
          if ((gPidiEPSubSys.IsThirdPartyCCMode) and (gPidiEPSubSys.CreditCardProcessingMode <> 'PAYPAL')) or
             ((gPidiEPSubSys.IsThirdPartyEFTMode) and (gPidiEPSubSys.EFTProcessingMode <> 'PAYPAL')) then begin
            // 6/9/2014 gms d-04871 don't assign EditingValue to local currency var in case it is null
            //   test first and if null, assign 0
            if IsEmptyVariant(grdMainTableView.Controller.EditingController.Edit.EditingValue) = True then begin
              aDonAmount := 0;
            end else begin
              aDonAmount := grdMainTableView.Controller.EditingController.Edit.EditingValue;
            end;
            if (aDonAmount <> DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').AsCurrency) then begin
              if (aDonAmount = 0) then begin
                gPidiDDGlobal.ErrorHandler.Reset;
                gPidiDDGlobal.ErrorHandler.Add('You have backed out this donation. ' +
                   ' After saving this adjustment, please go to your Virtual Terminal application ' +
                   'to manually back out the CC/EFT transaction', etValidation);
                gPidiDDGlobal.ErrorHandler.HandleErrors;
                // don't abort; just an informational message
              end else begin
                gPidiDDGlobal.ErrorHandler.Reset;
                gPidiDDGlobal.ErrorHandler.Add('You can only adjust a credit card/EFT amount to zero dollars', etValidation);
                gPidiDDGlobal.ErrorHandler.HandleErrors;
                grdMainTableViewAmount.EditValue :=
                    DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').AsCurrency;
              end;
            end;
          end;
        end;

        // 10/31/2014 gms b-05053 donation type changed; below code is to detach vehicle when
        //    when changing donation type from vehicle to other type
        if grdMainTableViewDonType.Focused = True then begin
          if (GetConfigPointYesNoBoolean('VDM', 'Active') = True) then begin
            if IsEmptyVariant(grdMainTableView.Controller.EditingController.Edit.EditingValue) = True then begin
              aNewDonType := '';
            end else begin
              aNewDonType := grdMainTableView.Controller.EditingController.Edit.EditingValue;
            end;
            if (DmGiftProcessing.DmDonation.GiftProcOrigDonType = 'V') and (aNewDonType <> 'V') and
               (IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donated_Vehicle_ID')) = False) then begin
              if MessageDlg('The Donation Type has changed and the link to the vehicle will be removed.  Continue?',
                  mtConfirmation, mbYesNo, 0) = mrYes then begin
                DetachVehicleFromDonation();
              end else begin
                DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').AsString :=
                   DmGiftProcessing.DmDonation.GiftProcOrigDonType;
                DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('DonTypeDesc').AsString := 'Vehicle';
              end;
            end;
          end;
        end;

        // Pledge Method Changed
        // Control ReadOnly status of some columns.
        if ((grdMainTableViewPlgMethodDesc.Focused = True) or
           (grdMainTableViewPlgMethod.Focused = True)) then begin
          if (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Method').AsString = 'CC') or
             (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Method').AsString = 'EF') then begin
            pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewRecurrence, False);
          end else begin
            pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewRecurrence, True);
          end;
        end;

        // Pledge Amount Changed
        // Handle pledge amount and frequency fields.
        if (grdMainTableView.GetColumnByFieldName('Plg_Amount').Focused = True) then begin
          if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin  // D-04825 TWM 2014.05.20
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
          end;
          // 8/27/2013 gms can't use dataset field value because it is not yet transferred from grid
          //   to field. Controller.EditingController.Edit.EditingValue holds the just entered value
          // aPlgAmount := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Amount').AsCurrency;
          // 6/9/2014 gms d-04871 don't assign EditingValue to local currency var in case it is null
          //   test first and if null, assign 0
          if IsEmptyVariant(grdMainTableView.Controller.EditingController.Edit.EditingValue) = True then begin
            aPlgAmount := 0;
          end else begin
            aPlgAmount := grdMainTableView.Controller.EditingController.Edit.EditingValue;
          end;

          aDonAmount := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Amount').AsCurrency;
          aPlgFreqID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('PlgFreq_ID').AsInteger;
          // 8/27/2013 gms if pledge amount is 0 and donation amount > 0, set pledge amount to donation amount
          //   else set to just entered pledge amount.
          if (aDonAmount > 0.00) and (aPlgAmount = 0.00) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Amount').AsCurrency := aDonAmount;
          end else begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Amount').AsCurrency := aPlgAmount;
          end;
          if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State <> dsBrowse) and
             (aPlgFreqID = 0) and (aPlgAmount > 0.00) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('PlgFreq_ID').AsInteger := 5;
          end;
          // 8/27/2013 gms default pledge method to donation type. But set the field only
          //   if pledge method is empty because the credit card or EFT panels might set it.
          if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Method')) then begin
            aDonTypeField := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type');
            if DmGiftProcessing.DmDonation.GiftProcIsCreditCardType(aDonTypeField) then begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Method').AsString := 'CC';
            end else if DmGiftProcessing.DmDonation.GiftProcIsEFTType(aDonTypeField) then begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Method').AsString := 'EF';
            end else begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Method').AsString := 'CH';
            end;
          end;
        end;

        // Pledge Frequency Changed
        // Default the pledge frequency
        if (grdMainTableViewPlgFreqDesc.Focused = True) then begin
          if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin // D-04825 TWM 2014.05.20
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
          end;
          aPlgFreqID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('PlgFreq_ID').AsInteger;
          if (aPlgFreqID = 0) and (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Plg_Amount').AsCurrency > 0) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('PlgFreq_ID').AsInteger := 5;
          end;
        end;

        // Show the correct tab.
        ShowTab;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.StandardGridColumnOnChange');
  end;
end;

//*****************************************************************************
// END: GRID FUNCTIONS SECTION
//*****************************************************************************

//*****************************************************************************
// begin: GRID METHODS
//*****************************************************************************
procedure TfrmBatchGiftProcessing.grdMainTableViewFocusedItemChanged(Sender: TcxCustomGridTableView;
  APrevFocusedItem, AFocusedItem: TcxCustomGridTableItem);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewFocusedItemChanged');
  try
    inherited;

    // 7/21/2014 gms d-04866 FFocusedGridTableItem must always be set; was previously inside the IF
    FFocusedGridTableItem := AFocusedItem;
    if DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = False then begin  //07/14/2014 RRR D-04955
      // 6/30/2014 gms B-05704 Call ShowTab here because this event is fired when changing columns
      if grdMain.Enabled = True then begin
        ShowTab;
        FSplitterChangedProcessed := True;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewFocusedItemChanged');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewFocusedRecordChanged(
  Sender: TcxCustomGridTableView; APrevFocusedRecord,
  AFocusedRecord: TcxCustomGridRecord; ANewItemRecordFocusingChanged: Boolean);
var
  aAdjCode: string;
//aGLIsRO: Boolean;
//aRestricted: Boolean;  //12/20/2013 RRR D-04700
  aStatus: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewFocusedRecordChanged');
  try
    inherited;
    if (FWorkInProgress = False) then begin
      // If inserting, exit this logic.

      //12/20/2013 RRR D-04480
      //These fields may have been set to RO previously, reset RO status

 //12/20/2013 RRR D-04700 - Rewrite this logic to keep prg ReadOnly for CCEFTClosed case
//    aRestricted := DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremAccountPeriodClosed,
//       gpremPostedToGlClosed, gpremBatchMngClosed] <> [];
//    pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewMcd, aRestricted);
//    pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPrg, aRestricted);
//    pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewFundCode, aRestricted);

      if DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremAccountPeriodClosed,
         gpremPostedToGlClosed, gpremBatchMngClosed] <> [] then begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewMcd, True);
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPrg, True);
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewFundCode, True);
      end else if DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremCCEFTClosed] <> [] then begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewMcd, False);
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPrg, True);
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewFundCode, False);
      end else begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewMcd, False);
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPrg, False);
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewFundCode, False);
      end;


     //12/26/2013 RRR B-05312  Do not Allow Sustainer Amount reallocation if
     // Editing is restricted
     // Donation is not a sustainer
     // Donation is Third Party CC or EFT transaction
      if mnuReallocateSustainerExtraAmount.Visible then begin
        mnuReallocateSustainerExtraAmount.Enabled := True;

//      if aRestricted then begin    //12/20/2013 RRR D-04700
        if DmGiftProcessing.DmDonation.GiftProcRestrictedEditingModes * [gpremAccountPeriodClosed,
          gpremPostedToGlClosed, gpremBatchMngClosed, gpremCCEFTClosed] <> [] then begin
          mnuReallocateSustainerExtraAmount.Enabled := False;
        end else if not DmGiftProcessing.DmDonation.DmDonationCodes.IsSusProgram(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsInteger) then begin
          mnuReallocateSustainerExtraAmount.Enabled := False;
        end else if (DmGiftProcessing.DmDonation.CreditCardBatch) and (gPidiEPSubSys.IsThirdPartyCCMode) then begin
          mnuReallocateSustainerExtraAmount.Enabled := False;
        end else if (DmGiftProcessing.DmDonation.EFTBatch) and (gPidiEPSubSys.IsThirdPartyEFTMode) then begin
          mnuReallocateSustainerExtraAmount.Enabled := False;
        end;
      end else begin
        mnuReallocateSustainerExtraAmount.Enabled := False;
      end;

      //02/24/2014 RRR D-04705 TK-13726  - Moved from below - was exiting before setting RO Status
      aStatus := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Matching_Status').AsString;
      if aStatus = '4' then begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewMatchingStatusDesc, True);
      end else begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewMatchingStatusDesc, False);
      end;

 //02/24/2015 RRR D-05313 The user can now edit Split Donation Amount, MCD, Fund in the grid.
 //We will make sure that the Linked Full Amount is adjusted, if necessary
(*    if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift2').AsBoolean then begin
//      pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, True); //RRR 01/29/2015 D-05281

        //12/20/2013 RRR D-04480
        //Do not allow change of Mail Code, Program or Fund on Journaled Pledges
        //Must do on Split Donation Screen to insure that Pledge and Donation match up
        if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').AsString = 'P' then begin
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, True); //RRR 01/29/2015 D-05281
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewMcd, True);
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPrg, True);
          pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewFundCode, True);
        end
      end else begin    *)
      if FRestrictedFieldList.IndexOf('Amount') >= 0 then begin //Check if the amount is readonly
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, True);
      end else begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewAmount, False);
      end;
//    end;

      if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert]) then begin
        grdMainTableView.OptionsBehavior.AlwaysShowEditor := True;
        grdMainTableView.OptionsView.ShowEditButtons := gsebForFocusedRecord;
        grdMainTableView.OptionsSelection.CellSelect := True;
        Exit;
      end;


      // This readonly logic need to change on a row-by-row basis
      // Do not allow edit based on the matching status.
      // NOTE ADJUSTMENT LOGIC BELOW CAN OVERRIDE THIS

//02/24/2014 RRR D-04705 TK-13726  - Moved above and cleaned up  - was exiting before setting RO Status
//    if (grdMainTableView.GetColumnByFieldName('Matching_Status').Focused = True) then begin
//    aStatus := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Matching_Status').AsString;
//    if aStatus = '4' then begin
//      grdMainTableView.OptionsView.ShowEditButtons := gsebNever;
//      grdMainTableView.OptionsSelection.CellSelect := False;
//    end else begin
//      grdMainTableView.OptionsView.ShowEditButtons := gsebForFocusedRecord;
//      grdMainTableView.OptionsSelection.CellSelect := True;
//    end;
//    end else begin
//      grdMainTableView.OptionsView.ShowEditButtons := gsebForFocusedRecord;
//      grdMainTableView.OptionsSelection.CellSelect := True;
//    end;
//---------------------------------------------------------------

      // Pledge / Sustainer stuff
      if DmGiftProcessing.DmDonation.DmDonationCodes.IsSusProgram(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsInteger) then begin
        EnablePledgeFields
      end else begin
        DisablePledgeFields;
      end;

      // 10/31/2014 gms b-05053 when vehicle menu items are visible (vdm config point active)
      //   set the menu items' Enabled property based on the Donated_Vehicle_Id field.  If not
      //   empty, a vehicle has been attached to the donation.
      if mnuAttachVehicle.Visible = True then begin
        if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donated_Vehicle_ID')) = True then begin
          mnuAttachVehicle.Enabled := True;
          mnuDetachVehicle.Enabled := False;
        end else begin
          mnuAttachVehicle.Enabled := False;
          mnuDetachVehicle.Enabled := True;
        end;
      end;

      // Set some global fields.
      aAdjCode := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_code').AsString;
      //FIsRO := gPidiDDGlobal.X_restriction and (not FEditDonation) and (not (DmGiftProcessing.DataModuleMode = dmmAdjBatch));
      FIsRO := gPidiDDGlobal.ViewOnly and (not (DmGiftProcessing.DataModuleMode in [dmmAdjBatch, dmmEditDonation]));
      FIsRO := FIsRO or (not UserCanEditThisRecord);
      FIsRO := FIsRO or (aAdjCode = 'A') or (aAdjCode = 'B') or (aAdjCode = 'E');

      // ?????? Don't think this should be here!!!!
      // Restrict some more fields.
      //RestrictEditing(DmGiftProcessing.DmDonation.GiftProcIsRestrictedEditing);

      // DEPRECATED 01/2013 jmp Always allow insert regardless of what record you are on. Don't allow edit or delete.
      // Adjustments - readonly if not on the "edit" record.
      navMainDelete.Enabled := not FIsRO;
      navMainEdit.Enabled := not FIsRO;
      navMainInsert.Enabled := not Self.FormReadOnly;   //02/24/2014 RRR D-04705 TK-13727
      if (DmGiftProcessing.DmDonation.DataModuleMode = dmmAdjBatch) then begin
        navMainInsert.Enabled := False;  //no inserts on adjustments
      end;

      grdMainTableView.OptionsBehavior.AlwaysShowEditor := not FIsRO;
      if (FIsRO = False) then begin
        grdMainTableView.OptionsView.ShowEditButtons := gsebForFocusedRecord;
        grdMainTableView.OptionsSelection.CellSelect := True;
      end else begin
        grdMainTableView.OptionsView.ShowEditButtons := gsebNever;
        grdMainTableView.OptionsSelection.CellSelect := False;
      end;

      // Show the right tab
      FRefreshTabs := True;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewFocusedRecordChanged');
  end;
end;

procedure TfrmBatchGiftProcessing.DisablePledgeFields;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DisablePledgeFields');
  try
    pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.GetColumnByFieldName('Extra_Amount'), True);
    pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.GetColumnByFieldName('Plg_Amount'), True);
    pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPlgFreqDesc, True);
    pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPlgMethod, True);
    pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewRecurrence, True);
    pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewSustainerClass, True);
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DisablePledgeFields');
  end;
end;

procedure TfrmBatchGiftProcessing.EnablePledgeFields;

//============================  Sub Procedures  ============================ //

  function EnableRecurrenceCode: Boolean;
  var
    aErcPledgeID, aErcPlgMethod: string;
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.EnablePledgeFields: EnableRecurrenceCode');
    try
      Result := False;
      if not DmGiftProcessing.DmDonation.GiftProcIsSustainerClassActive then begin
        Exit;
      end;

      aErcPledgeID := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Pledge_ID').AsString;
      if IsEmptyStr(aErcPledgeID) = True then begin
        Exit;
      end;

      if not DmGiftProcessing.DmDonation.cdsPledge.FindKey([aErcPledgeID]) then begin
        Exit;
      end;

      aErcPlgMethod := DmGiftProcessing.DmDonation.cdsPledge.FieldByName('Plg_Flag').AsString;
      if (aErcPlgMethod = 'CC') or (aErcPlgMethod = 'EF') then begin
        Result := True;
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.EnablePledgeFields: EnableRecurrenceCode');
    end;
  end;

//=========================== End Sub Procedures  =========================== //

begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.EnablePledgeFields');
  try
    pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.GetColumnByFieldName('Plg_Amount'), False);
    if mnuReallocateSustainerExtraAmount.Enabled = True then begin   //01/08/2013 RRR B-05312
      pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.GetColumnByFieldName('Extra_Amount'), False);
    end else begin;
      pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.GetColumnByFieldName('Extra_Amount'), True);
    end;

    pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPlgFreqDesc, False);
    if DmGiftProcessing.DmDonation.GiftProcIsSustainerClassActive then begin
      pidiCore.SetDevExpressColumnReadOnly(grdMainTableView.GetColumnByFieldName('Sustainer_Class'), False);
      pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewSustainerClass, False);
      if EnableRecurrenceCode then begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewRecurrence, False);
      end else begin
        pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewRecurrence, True);
      end;
    end;

    if (not DmGiftProcessing.DmDonation.CreditCardBatch) and (not DmGiftProcessing.DmDonation.EFTBatch) then begin
      pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPlgMethod, False);
    end else begin
      pidiCore.SetDevExpressColumnReadOnly(grdMainTableViewPlgMethod, True);
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.EnablePledgeFields');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainEnter(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainEnter');
  gPidiBugReport.SIInfo := 'SI EnterMethod: TfrmBatchGiftProcessing.grdMainEnter';
  try
    FWorkInProgress := True; // Prevents ShowTab
    try
      // When editing donation cannot insert, can insert when adjust mode
      if ((EditDonation = True) and (DmGiftProcessing.DataModuleMode <> dmmAdjBatch)) then begin
        navMainInsert.Enabled := False;
      end;

      gPidiDDGlobal.MainFormStatusPane.Caption := StatusMsg;

      //01/15/2014 RRR D-04378   Reset the check boxes if coming from lower grid
//    if (splMain.State <> ssClosed) then begin  //05/16/2014 RRR D-04830
//    if DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin  //07/14/2014 RRR D-04955 - Moved to CanFocusRecord
//      SetCheckedColumns(False);
        // 5/21/2014 gms d-04823 don't close splitter here; will be closed in MouseDown or ShowTab
        // DoCloseSplitter();     //05/16/2014 RRR D-04830
//    end;

      StdEnter(Sender);
      DmGiftProcessing.DmDonation.GiftProcOldDonationFilter := '';
      (* 07/14/2014 RRR D-04955 - Not needed; if user changes record when returning from
           lower grid; the filter reset procs will be called in cdsGiftProcessingAfterScroll
      DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen := False;
      if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_Id')) = False then begin
        DmGiftProcessing.DmDonation.GiftProcSetFilterOnDonationDatasets(
           DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donation_Id').AsInteger);
      end;
      if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID')) = False then begin
        DmGiftProcessing.DmDonation.GiftProcSetFilterOnMasterDatasets(
           DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger);
      end;
      *)

      // Have to reset these
      gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.grdMainEnter: Reset SaveAction';
      gPidiDDGlobal.MainMenuButtonSave.Action := SaveAction;
      PageControlInfo.SaveAction := SaveAction;


      // Don't activate the Print Button unless DMDonation has been created.
      // This can prevent in inadvertent Access Violation
      gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.grdMainEnter: Activate Print Button';
      if DmGiftProcessing.DmDonation <> nil then begin
        PageControlInfo.PrintAction := PrintAction;
      end;

      
      gPidiBugReport.OtherInfo := 'TfrmBatchGiftProcessing.grdMainEnter: Assign navMain DataSource';
      navMain.DataSource := dsGiftProcessing;
    finally
      FWorkInProgress := False;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainEnter'); 
    gPidiBugReport.SIInfo := 'SI LeaveMethod: TfrmBatchGiftProcessing.grdMainEnter';
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainExit(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainExit');
  try
    FWorkInProgress := True; // Prevents ShowTab
    try
      gPidiDDGlobal.MainFormStatusPane.Caption := '';
      
      StdExitNoValidate(Sender); // Must be no-validate version.
      if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
        Exit;
      end;

      // UI Behaviour
      if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsInsert) and
         (IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_id'))) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.Cancel;
      end;
    finally
      FWorkInProgress := False;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainExit');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainResize(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainResize');
  try
    inherited;
    // 12/2/2013 gms D-04501 Ensure current record is in view when the window is resized
    //   or if the splitter is opened or moved
    if grdMainTableView.Controller.FocusedRecord <> nil then begin
      grdMainTableView.Controller.FocusedRecord.MakeVisible;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainResize');
  end;
end;

// This event processes various features like displaying MasterView on F3
// NO NAVIGATION METHODS SHOULD BE PUT IN HERE, USE EditKeyUp INSTEAD
procedure TfrmBatchGiftProcessing.grdMainTableViewEditKeyDown(
  Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem;
  AEdit: TcxCustomEdit; var Key: Word; Shift: TShiftState);
var
  i, aLastVisibleActiveColumn: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewEditKeyDown');
  try
    inherited;

    if FWorkInProgress = False then begin

      if (Key = VK_RETURN) or (Key = VK_TAB) then begin
        aLastVisibleActiveColumn := grdMainTableView.VisibleColumnCount - 1;
        // Find the last column that can get focus
        for i := grdMainTableView.VisibleColumnCount - 1 downto 0 do begin
          try
            (* 2/25/2015 gms d-05369 The Columns array is the incorrect property to use
                for this purpose as it represents all columns, not the visible columns;
                will now use the VisibleColumns array
            if not((grdMainTableView.Columns[i].Options.Focusing = False) or
               ((grdMainTableView.Columns[i].Properties <> nil) and
               (grdMainTableView.Columns[i].Properties.ReadOnly = True)) or
               ((grdMainTableView.Columns[i].RepositoryItem <> nil) and
               (grdMainTableView.Columns[i].RepositoryItem.Properties <> nil) and
               (grdMainTableView.Columns[i].RepositoryItem.Properties.ReadOnly = True))) then begin
            *)
            if not((grdMainTableView.VisibleColumns[i].Options.Focusing = False) or
               ((grdMainTableView.VisibleColumns[i].Properties <> nil) and
               (grdMainTableView.VisibleColumns[i].Properties.ReadOnly = True)) or
               ((grdMainTableView.VisibleColumns[i].RepositoryItem <> nil) and
               (grdMainTableView.VisibleColumns[i].RepositoryItem.Properties <> nil) and
               (grdMainTableView.VisibleColumns[i].RepositoryItem.Properties.ReadOnly = True))) then begin
              aLastVisibleActiveColumn := i;
              Break;
            end;
          except
            aLastVisibleActiveColumn := i;
            Break;
          end;
        end;
      end;

    // Process user key presses.
      case Key of
        VK_RETURN:
          begin
            if ((Assigned(AItem) = True) and
               (AItem.VisibleIndex = aLastVisibleActiveColumn)) then begin
              if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit] then begin
                DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
              end;
              if DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsBrowse then begin
                DmGiftProcessing.DmDonation.cdsGiftProcessing.Append;
                // 7/3/2014 gms d-04952 removing key so that focus stays on account ID;
                //   without it the table view's GoToNextCellOnEnter moves the focus to the program column
                Key := 0;
              end;
            end;
          end;

        //06/19/2014 RRR B-05611   - If TAB hit on last column, don't leave grid, stay on current column
        VK_TAB:
          begin
            if Assigned(AItem) = True then begin
              // if you are on the last column eat the tab keystroke
              if AItem.VisibleIndex = aLastVisibleActiveColumn then begin
                Key := 0;
              end;
            end;

           (* Deprecated Feb 2015 TWM
             if ((Assigned(AItem) = True) and
               (AItem.VisibleIndex = grdMainTableView.VisibleColumnCount - 1)) then begin
              Key := 0;
            end;  *)
          end;
        // 6/20/2013 gms Insert key will now append at end and is available from any column
        VK_INSERT:
          begin
            if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit] then begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.Post;
            end;
            if DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsBrowse then begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.Append;
            end;
          end;
        VK_SPACE:
          if (grdMainTableView.GetColumnByFieldName('Flag_List').Focused = True) or
             (grdMainTableView.GetColumnByFieldName('Interest_List').Focused = True) or
             (grdMainTableView.GetColumnByFieldName('Suppress_List').Focused = True) or
             (grdMainTableView.GetColumnByFieldName('Activist_List').Focused = True) then begin
           // Wait for some feedback to see if we should test this or not.
           // if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit] then begin
             DoGiftProcEditAccountRecord(gpmeCodeMaintenance,
                DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger, False);
          // end;
          end;
        VK_F2:
          if (grdMainTableView.GetColumnByFieldName('Account_ID').Focused = True) then begin
            if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit] then begin
              DoAccountSearch();
            end else if DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsBrowse then begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.Append;
              if not(DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_ZIP_SURNAME_SEARCH)) then begin
                DoAccountSearch();
              end;
            end;
          end else if (DmGiftProcessing.DmDonation.cdsGiftProcessing.IsEmpty = True) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Append;
            if not(DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_ZIP_SURNAME_SEARCH)) then begin
              DoAccountSearch();
            end;
          end;
        VK_F3:
          begin
            DoGiftProcEditAccountRecord(gpmeDonation,
               DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger, False);
          end;
        VK_F4:
          if (grdMainTableView.GetColumnByFieldName('Account_ID').Focused = True) then begin
            FProspectSearch := True;
            if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit] then begin
              DoAccountSearch();
            end else if DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsBrowse then begin
              DmGiftProcessing.DmDonation.cdsGiftProcessing.Append;
              if not(DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_ZIP_SURNAME_SEARCH)) then begin
                DoAccountSearch();
              end;
            end;
          end else if (DmGiftProcessing.DmDonation.cdsGiftProcessing.IsEmpty = True) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Append;
            if not(DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_ZIP_SURNAME_SEARCH)) then begin
              DoAccountSearch();
            end;
          end;
      else
        FCursorLocSet := False;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewEditKeyDown');
  end;
end;

// This event is to ensure the right tab displays during keyboard navigation
procedure TfrmBatchGiftProcessing.grdMainTableViewEditKeyUp(
  Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem;
  AEdit: TcxCustomEdit; var Key: Word; Shift: TShiftState);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewEditKeyUp');
  try
    inherited;
    // Process user key presses.
    // 6/30/2014 gms B-05704 Removing ShowTab calls; now called in OnFocusedItemChanged
    case Key of
      0:
          begin
            // This key occurrs when moving from non-editor column to editor column.
            // Show the correct tab.
            // ShowTab;
          end;
      VK_Return:
          begin
            // Show the correct tab.
            // ShowTab;
          end;
      VK_TAB:
          begin
            // Show the correct tab.
            // ShowTab;
          end;
      VK_RIGHT:
          begin
            // Show the correct tab.
            // ShowTab;
          end;
      VK_LEFT:
          begin
            // Show the correct tab.
            // ShowTab;
          end;
      else begin
        // 5/23/2014 gms d-04823 adding closing splitter here when using keystrokes
        //   to move back to top grid.
        if PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin
//      if (splMain.State <> ssClosed) then begin
          // Update the checked columns.
          DoCloseSplitter();
          SetCheckedColumns(False);
        end;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewEditKeyUp');
  end;
end;

// This event opens the correct tab when a column is clicked.
procedure TfrmBatchGiftProcessing.grdMainTableViewMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  aPoint: TPoint;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewMouseDown');
  try
    inherited;

    try
      aPoint.X := X;
      aPoint.Y := Y;
      //ShowMessage('Mouse: ' + IntToStr(Ord(grdMainTableView.GetHitTest(aPoint).ViewInfo = nil)));
      if (grdMainTableView.GetHitTest(aPoint).ViewInfo = nil) then begin
        // Grid clicked, clicked on open space, then close tabs
        if PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin
  //    if (splMain.State <> ssClosed) then begin
          // Update the checked columns.
          // 5/21/2014 gms d-04823 Moved SetCheckColumns after DoCloseSpliter; closing splitter
          //   can post or cancel lower dataset; SetCheckColumns operates when lower dataset in
          //   browse mode; so call DoCloseSplitter so that lower tabs can post or cancel
          DoCloseSplitter();
          SetCheckedColumns(False);
          (* 3/20/2014 gms d-04568 code now in DoCloseSplitter
          // Close the splitter
          splMain.CloseSplitter;
          splMain.Visible := False;
          grdMainTableView.Focused := True;
          grdMainTableViewAccountId.Focused := True;
          *)
        end;

      end else begin
        // Grid clicked, clicked on cell in record, then potentially show the tab.
        // 6/30/2014 gms b-05704 not needed except for use case described below
        // ShowTab;
        // 6/30/2014 gms b-05704 when coming back from lower grid and click in same cell that
        //   opened lower grid, call ShowTab to close splitter;  need this because OnFocusedItemChanged
        //   does not fire because focused item did not change.
        if (grdMainTableView.GetHitTest(aPoint).HitTestCode = htCell) then begin
          if TcxGridRecordCellHitTest(grdMainTableView.GetHitTest(aPoint)).Item = FFocusedGridTableItem then begin
            if FSplitterChangedProcessed = False then begin
              ShowTab;
            end;
          end;
        end;
      end;
    finally
      FSplitterChangedProcessed := False;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewMouseDown');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewPrgDescPropertiesEditValueChanged(
  Sender: TObject);
begin 
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewPrgDescPropertiesEditValueChanged');
  try
    inherited;

    DmGiftProcessing.DmDonation.cdsMailCode.Filtered := False;
    if not DmGiftProcessing.DmDonation.cdsMailCode.FindKey(
       [DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('MCD').AsString,
       DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsString]) then begin
      grdMainTableViewMcd.Styles := TcxGridColumnStyles(gPidiStyleSettings.BGPRedFont);
    end else if DmGiftProcessing.DmDonation.cdsMailCode.FieldByName('IsActive').AsString <> 'Y' then begin
      grdMainTableViewMcd.Styles := TcxGridColumnStyles(gPidiStyleSettings.BGPLimeFont);
    end;

  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewPrgDescPropertiesEditValueChanged');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewResetColumns(Sender: TObject);
var
  aInifile: TInifile;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewResetColumns');
  try
    inherited;

    aInifile := TInifile.Create(gPidiDDGlobal.DonorDirectIniFileName);
    try
      aInifile.EraseSection('GiftProcUserOptions');
    finally
      aInifile.Free;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewResetColumns');
  end;
end;

// This event colors rows.
procedure TfrmBatchGiftProcessing.grdMainViewStylesGetContentStyle(
  Sender: TcxCustomGridTableView; ARecord: TcxCustomGridRecord;
  AItem: TcxCustomGridTableItem; out AStyle: TcxStyle);
var
  aPrg: Integer;
  aMcdStr, aPrgStr: string;
  aValue: Variant;
  aDonationIsAdjusted: Boolean;
begin
  // NO SI
  //SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewStylesGetContentStyle');
  try
    inherited;
    // Color column
    (* 8/14/2014 gms d-05006 DEPRECATED only used for Care to color the fund code column
       per agreement with Care, we will no longer color the column if fund is restricted
    if (AItem = grdMainTableViewFundCode) then begin
      if DmGiftProcessing.DmDonation.GiftProcFundCodeRestricted then begin
        AStyle := gPidiStyleSettings.BGPRedFont;
        Exit;
      end;
    end;
    *)

    // Color column
    if (AItem = grdMainTableViewPrg) or (AItem = grdMainTableViewPrgDesc) or
       (AItem = grdMainTableViewMcd) then begin
      aValue := ARecord.Values[grdMainTableViewMcd.Index];
      aMcdStr := '';
      // 10/22/2013 gms tk-12953 replace 2 tests with new IsEmptyVariant function which is more robust
      // if (not VarIsNull(aValue)) and (not VarIsEmpty(aValue)) then begin
      if IsEmptyVariant(aValue) = False then begin
        aMcdStr := VarToStr(aValue);
      end;
      if (IsEmptyStr(aMcdStr) = False) then begin
        aValue := ARecord.Values[grdMainTableViewPrg.Index];
        aPrgStr := '';
        // 10/22/2013 gms tk-12953 replace 2 tests with new IsEmptyVariant function which is more robust
        // if (not VarIsNull(aValue)) and (not VarIsEmpty(aValue)) then begin
        if IsEmptyVariant(aValue) = False then begin
          aPrgStr := VarToStr(aValue);
        end;
        if (IsEmptyStr(aPrgStr)) then begin
          AStyle := gPidiStyleSettings.BGPRedFont;
          Exit;
        end else begin
          aPrg := StrToInt(aPrgStr);
          DmGiftProcessing.DmDonation.cdsMailCode.Filtered := False;
          if not DmGiftProcessing.DmDonation.cdsMailCode.FindKey([aMcdStr, aPrg]) then begin
            AStyle := gPidiStyleSettings.BGPRedFont;
          end else if DmGiftProcessing.DmDonation.cdsMailCode.FieldByName('IsActive').AsString <> 'Y' then begin
            AStyle := gPidiStyleSettings.BGPLimeFont;
          end;
        end;
      end;
    end;

    // Color rows
    // 1/20/2015 gms d-05261 adding boolean flag to indicate the row is colored within the
    //   adjustment process for a, b, d, and e records
    aDonationIsAdjusted := False;
    AValue := ARecord.Values[grdMainTableViewAdjCode.Index];
    // 10/22/2013 gms tk-12953 replace 2 tests with new IsEmptyVariant function which is more robust
    // if (not VarIsNull(aValue)) and (not VarIsEmpty(aValue)) then begin
    if IsEmptyVariant(aValue) = False then begin
//    if (ARecord.Focused = False) then begin       //02/24/2014 RRR D-04705 TK-13728
      if (AValue = 'A') or (AValue = 'E') then begin
        AStyle := gPidiStyleSettings.BGPYellowBrush;
        aDonationIsAdjusted := True;
      end else if AValue = 'B' then begin
        AStyle := gPidiStyleSettings.BGPRedFontYellowBrush;
        aDonationIsAdjusted := True;
      end else if AValue = 'D' then begin
        // Color row - Split Donations
        AValue := ARecord.Values[grdMainTableViewSplitGift2.Index];
        if ((AValue <> Null) and (AValue = True)) then begin
          if (ARecord.Focused = False) then begin
            AStyle := gPidiStyleSettings.BGPGreenBrush;
            aDonationIsAdjusted := True;
          end;
        end;
      end;
//    end;      //02/24/2014 RRR D-04705 TK-13728
    // 12/30/2014 gms d-05250 adj code is never empty; so, give a chance to color for splits
    //   as on TabDonationFrm, split donation has highest priority
    // end else begin
    end;
    // 1/20/2015 gms d-05261 only if row has not been colored for adjustments above, proceed to
    //   coloring for splits
    // Color row - Split Donations
    if aDonationIsAdjusted = False then begin
      AValue := ARecord.Values[grdMainTableViewSplitGift2.Index];
      if ((AValue <> Null) and (AValue = True)) then begin
        if (ARecord.Focused = False) then begin
          AStyle := gPidiStyleSettings.BGPGreenBrush;
        end;
      end;
    end;
  finally
    // NO SI
    //SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainViewStylesGetContentStyle');
  end;
end;

//*****************************************************************************
// END: GRID METHODS
//*****************************************************************************

//*****************************************************************************
// begin: GRID COLUMN METHODS
//*****************************************************************************
// Pick an Account
procedure TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesButtonClick(
   Sender: TObject; AButtonIndex: Integer);
var
  aAccountId: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesButtonClick');
  try
    inherited;
    // 4/3/2014 gms d-04662 get value of account ID edit box to send into CanChangeAccount so that
    //   GiftProcIsValidAccountID is using the correct account.
    aAccountId := -1;
    if IsEmptyStr((Sender as TcxButtonEdit).Text) = False  then begin
      if (IsNumeric((Sender as TcxButtonEdit).Text)) then begin
        aAccountId := StrToInt((Sender as TcxButtonEdit).Text);
      end;
    end;
    if (CanChangeAccount(aAccountId) = True) then begin
      DoAccountSearch();
      (* 4/10/2014 d-04768 Moved to DoAccountSearch in connection with removing
           GiftProcEditAccountRecord from DoAccountSearch
      // 4/2/2014 gms d-04662 dataset account_ID field OnChange no longer used.
      //   Call EditValueChanged to set rest of account data
      grdMainTableViewAccountIdPropertiesEditValueChanged(Sender);
      *)
      // 6/19/2014 gms b-05611 not needed; below done in editvaluechanged
      // ThreadedMoveToNextField;
    end else begin
      if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
        DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger :=
           DmGiftProcessing.DmDonation.GiftProcLastAccountId;
        // 6/19/2014 gms b-05611 no longer using threading to move to a different field
        // ThreadedMoveToField(grdMainTableView, 'Account_ID');
        MoveToField(grdMainTableView, 'Account_ID');
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesButtonClick');
  end;
end;

// Pick an Account
procedure TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesEditValueChanged(
   Sender: TObject);
var
  aAccountIdStr: string;
  aAccountID: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesEditValueChanged');
  try
    inherited;
    // 3/27/2014 gms d-04662 added test for showing, etc to avoid error message when focus not
    //   on form.  An example is when the user clicks View/Account while still changing the acct
    // 4/2/2014 gms d-04662 removed test for grid.focused because was always false
    if (grdMain.Showing = True) and (grdMain.CanFocus = True) then begin
      aAccountIdStr := (Sender as TcxButtonEdit).EditValue;
      // Check to see if the change resulted in a number and not a blank field
      if (IsEmptyStr(aAccountIdStr) = False) and (IsNumeric(aAccountIdStr) = True) and
         (StrToInt(aAccountIdStr) >= 1) then begin
        aAccountID := StrToInt(aAccountIdStr);
        // Check to see if Combine To Account is set
        if (DmGiftProcessing.DmDonation.GiftProcCombineToAccount > 0) and
           (DmGiftProcessing.DmDonation.GiftProcCombineToAccount <> aAccountID) then begin
          (Sender as TcxButtonEdit).EditValue := DmGiftProcessing.DmDonation.GiftProcCombineToAccount;
          aAccountID := DmGiftProcessing.DmDonation.GiftProcCombineToAccount;
        end;
        DoAccountIDEditValueChanged(aAccountID);
        (* 4/10/2014 gms d-04768 Moved to DoAccountIDEditValueChanged
        // Check to see if there are child records / other restrictions on changing Account Id
        // 4/3/2014 gms d-04662 send current value of edit box into CanChangeAccount so that
        //   GiftProcIsValidAccountID is using the correct account.
        if (CanChangeAccount(aAccountID) = True) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger := aAccountID;
          // 4/2/2014 gms d-04662 dataset account_ID field OnChange no longer used.
          //   Call GiftProcSetAccountData to set rest of account data
          DmGiftProcessing.DmDonation.GiftProcSetAccountData;
          ThreadedMoveToNextField;
          if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_UPDATE_MASTER_INFO) then begin
            DoGiftProcEditAccountRecord(gpmeDonation,
               DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger, False);
          end;
        end else begin
          if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State <> dsBrowse) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger :=
               DmGiftProcessing.DmDonation.GiftProcLastAccountId;
            // 4/2/2014 gms d-04662 dataset account_ID field OnChange no longer used.
            //   Call GiftProcSetAccountData to set rest of account data
            DmGiftProcessing.DmDonation.GiftProcSetAccountData;
            ThreadedMoveToField(grdMainTableView, 'Account_ID');
          end;
        end;
        *)
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesEditValueChanged');
  end;
end;

procedure TfrmBatchGiftProcessing.DoAccountIDEditValueChanged(pAccountID: Integer);
// 4/10/2014 gms d-04768 moved code from Account ID's column OnEditValueChanged so that it
//   can be called from place where the account ID is not focused
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoAccountIDEditValueChanged');
  try
    inherited;
    // 3/27/2014 gms d-04662 added test for showing, etc to avoid error message when focus not
    //   on form.  An example is when the user clicks View/Account while still changing the acct
    // 4/2/2014 gms d-04662 removed test for grid.focused because was always false
    if (grdMain.Showing = True) and (grdMain.CanFocus = True) then begin

      if pAccountId >= 1 then begin
        // Check to see if there are child records / other restrictions on changing Account Id
        // 4/3/2014 gms d-04662 send current value of edit box into CanChangeAccount so that
        //   GiftProcIsValidAccountID is using the correct account.
        if (CanChangeAccount(pAccountID) = True) then begin 
          if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin // D-04825 TWM 2014.05.20
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
          end;

          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger := pAccountID;
          // 4/2/2014 gms d-04662 dataset account_ID field OnChange no longer used.
          //   Call GiftProcSetAccountData to set rest of account data
          DmGiftProcessing.DmDonation.GiftProcSetAccountData;
          // 6/19/2014 gms b-05611 no longer using threading to move to a different field
          // ThreadedMoveToNextField;
          // 7/2/2014 gms d-04952 movetonextfield not needed; except for search; this proc
          //   always called when moving to another field
          // MoveToNextField;
          if DmGiftProcessing.DmDonation.IsGiftProcOptionSelected(OPTION_UPDATE_MASTER_INFO) then begin
            DoGiftProcEditAccountRecord(gpmeDonation,
               DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger, False);
          end;
        end else begin
          if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsEdit, dsInsert]) then begin

//05/05/2014 RRR D-04793  -  Do don't reset Account ID, instead cancel the transaction
//                           Resetting the account ID was not working when user posted the donation after changinf Account
//          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger :=
//             DmGiftProcessing.DmDonation.GiftProcLastAccountId;
            // 4/2/2014 gms d-04662 dataset account_ID field OnChange no longer used.
            //   Call GiftProcSetAccountData to set rest of account data
//          DmGiftProcessing.DmDonation.GiftProcSetAccountData;
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Cancel;

            // 6/19/2014 gms b-05611 no longer using threading to move to a different field
            // ThreadedMoveToField(grdMainTableView, 'Account_ID');
            MoveToField(grdMainTableView, 'Account_ID');
          end;
        end;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.DoAccountIDEditValueChanged');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesValidate(Sender: TObject;
  var DisplayValue: Variant; var ErrorText: TCaption; var Error: Boolean);
var
  aDisplayStr: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesValidate');
  gPidiBugReport.SIInfo := 'SI EnterMethod: TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesValidate';
  try
    inherited;
    // 3/27/2014 gms d-04662 added test for showing, etc to avoid error message when focus not
    //   on form.  An example is when the user clicks View/Account while still changing the acct
    // 4/2/2014 gms d-04662 removed test for grid.focused because was always false
    if (grdMain.Showing = True) and (grdMain.CanFocus = True) then begin
      // 3/25/2014 gms d-04662 OnValidate method called when leaving column by any means;
      //    column property ValidateOnEnter = True also generates event when clicking enter on column
      //    Do immediate validation when attempting to leave column; Resolves problems of enter
      //    key leaving invalid value; Also testing variant for empty and non-numeric/float to
      //    avoid any variant conversion issues.
      Error := False;
      if (IsEmptyVariant(DisplayValue) = False) then begin
        aDisplayStr := VarToStr(DisplayValue);
        gPidiBugReport.OtherInfo := 'grdMainTableViewAccountIdPropertiesValidate.DisplayValue: ' + aDisplayStr;  // inside if to guard against converting empty value
        // 4/2/2014 gms d-04662 VarIsNumeric was not returning true; convert to string and test for numeric
        // 4/24/2014 twm D-04790 Passing the variant in for integer and also checking the length
        if (IsNumeric(aDisplayStr) =  False) or (Length(aDisplayStr) > 9) or
           (DmGiftProcessing.DmDonation.GiftProcIsValidAccountId(StrToInt(aDisplayStr), gpvaDonation) = False) then begin
          Error := True;
          ErrorText := 'Invalid Account ID';
        end;
      end;
    end;
  finally
    gPidiBugReport.SIInfo := 'SI LeaveMethod: TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesValidate';
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewAccountIdPropertiesValidate');
  end;
end;

//Added - 07/14/2014 RRR D-04955
//Keep on the current Donation after closing the splitter - Make sure colums are checked correctly
procedure TfrmBatchGiftProcessing.grdMainTableViewCanFocusRecord(
  Sender: TcxCustomGridTableView; ARecord: TcxCustomGridRecord;
  var AAllow: Boolean);
var
  aDonIDVar: Variant;
  aDonID: Integer;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewCanFocusRecord');
  try
    inherited;

    AAllow := True;
    aDonIDVar := ARecord.Values[grdMainTableViewDonationID.Index];
    if IsEmptyVariant(aDonIDVar) = False then begin
      aDonID := VarAsType(aDonIDVar, varInteger);
    end else begin
      aDonID := -1;
    end;
    
    if DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin
      DoCloseSplitter();
      if DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin
        AAllow := False;
      end else begin
        // 7/21/2014 gms d-04866 only call SetCheckedColumns if lower grid was closed successfully
        SetCheckedColumns(False);
        // If staying on same account
        if aDonID = DmGiftProcessing.DmDonation.CurrentDonationId then begin
          FSplitterChangedProcessed := True;
        end;
      end;
    end;

    // 7/21/2014 gms d-04866 abort other mouse/key events when staying in lower grid
    if AAllow = False then begin
      Abort;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewCanFocusRecord');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewCategoryDescPropertiesCloseUp(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewCategoryDescPropertiesCloseUp');
  try
    // 7/8/2014 gms b-05704 adding showtab here in OnCloseUp for use case of user typing
    //   value instead of using mouse to select.  Typing first letter and enter does not call
    //   StandardGridColumnOnChange when the value is ultimately selected.
    //   But only call ShowTab if splitter not already opened by previous call to ShowTab
    inherited;
    if (IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category')) = False) and
       ((splMain.State = ssClosed)) then begin
      ShowTab;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewCategoryDescPropertiesCloseUp');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewCellClick(
  Sender: TcxCustomGridTableView; ACellViewInfo: TcxGridTableDataCellViewInfo;
  AButton: TMouseButton; AShift: TShiftState; var AHandled: Boolean);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewCellClick');
  try
    inherited;

    //  If Form Is ReadOnly
    if (TcxCustomGridTableView(Sender).OptionsData.Deleting = False) and
       (TcxCustomGridTableView(Sender).OptionsData.Editing = False) and
       (TcxCustomGridTableView(Sender).OptionsData.Inserting = False) then begin
      if (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'Category') or
         (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'Type') or
         (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'GroupDonations') or
         (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'Matching_Status') or
         (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'Order_IR') or
         (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'PlgMethodDesc') or
         (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'Premium_List') or
         (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'SoftCredit') or
         (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'SplitGift') or
         (TcxGridDBColumn(ACellViewInfo.Item).DataBinding.FieldName = 'SplitGift2') then begin
        ShowTab(TcxGridDBColumn(ACellViewInfo.Item));
      end else begin
        ShowTab(nil);
      end;
    end else if (TcxGridDBColumn(ACellViewInfo.Item).Options.Focusing = False) then begin
      // If Column is Focusing False
      if PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin
//    if (splMain.State <> ssClosed) then begin
        // Update the checked columns.
        // 5/21/2014 gms d-04823 Moved SetCheckColumns after DoCloseSpliter; closing splitter
        //   can post or cancel lower dataset; SetCheckColumns operates when lower dataset in
        //   browse mode; so call DoCloseSplitter so that lower tabs can post or cancel
        DoCloseSplitter();
        SetCheckedColumns(False);
        (* 3/20/2104 gms d-04568 code now in DoCloseSplitter
        // Close the splitter
        splMain.CloseSplitter;
        splMain.Visible := False;
        if (grdMain.Showing) and (grdMain.CanFocus) then begin
          grdMain.SetFocus;
        end;
        *)
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewCellClick');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewCodeListPropertiesButtonClick(
  Sender: TObject; AButtonIndex: Integer);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewCodeListPropertiesButtonClick');
  try
    inherited;
    if DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit] then begin
      DoGiftProcEditAccountRecord(gpmeCodeMaintenance,
         DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_Id').AsInteger, False);
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewCodeListPropertiesButtonClick');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewDonTypePropertiesInitPopup(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewDonTypePropertiesInitPopup');
  try
    inherited;

    // StdLookUpDropDownFilterOn(Sender);

    // 10/02/2014 F. D-05151 Control has no parent window." Error when attempting to change credit card type
    if (Sender is TcxCustomLookupComboBox) then begin
      if (TcxCustomLookupComboBox(Sender).Properties.ListSource <> nil) and
         (TcxCustomLookupComboBox(Sender).Properties.ListSource.DataSet <> nil) and
         (TcxCustomLookupComboBox(Sender).Properties.ListSource.DataSet.FindField('IsActive') <> nil) then begin
        TcxCustomLookupComboBox(Sender).Properties.ListSource.DataSet.Filtered := False;
        TcxCustomLookupComboBox(Sender).Properties.ListSource.DataSet.Filter := 'IsActive = ''Y''';

        //06/04/2014 RRR D-04891 - Don't allow Journaled Pledges  on Sustainers
        if DmGiftProcessing.DmDonation.DmDonationCodes.IsSusProgram(
           DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsInteger) then begin
             TcxCustomLookupComboBox(Sender).Properties.ListSource.DataSet.Filter :=
              (Sender as TcxCustomLookupComboBox).Properties.ListSource.DataSet.Filter +
              ' and (Code <> ' + QuotedStr('P') + ') ';
        end;


        // 8/28/2013 gms tk-12545 Filter out credit card donation types if not in credit card batch or in 3rd party mode
        if (DmGiftProcessing.DmDonation.CreditCardBatch = False) then begin
          if pidiGlobals.gPidiEPSubSys.IsThirdPartyCCMode = True then begin
              TcxCustomLookupComboBox(Sender).Properties.ListSource.DataSet.Filter :=
               (Sender as TcxCustomLookupComboBox).Properties.ListSource.DataSet.Filter +
               ' and (Code <> ' + QuotedStr('D') + ') and (Code <> ' + QuotedStr('CC') + ')';
          end;
        end;

        // 8/28/2013 gms tk-12545 Filter out EFT donation types if not in EFT batch or in 3rd party mode
        if (DmGiftProcessing.DmDonation.EFTBatch = False) then begin
          if pidiGlobals.gPidiEPSubSys.IsThirdPartyEFTMode = True then begin
              TcxCustomLookupComboBox(Sender).Properties.ListSource.DataSet.Filter :=
               (Sender as TcxCustomLookupComboBox).Properties.ListSource.DataSet.Filter +
               ' and (Code <> ' + QuotedStr('E') + ') and (Code <> ' + QuotedStr('EF') + ')' +
               ' and (Code <> ' + QuotedStr('ET') + ') and (Code <> ' + QuotedStr('EFT') + ')' +
               ' and (Code <> ' + QuotedStr('WT') + ')';
          end;
        end;
        TcxCustomLookupComboBox(Sender).Properties.ListSource.DataSet.Filtered := True;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewDonTypePropertiesInitPopup');
  end;
end;

function TfrmBatchGiftProcessing.CanChangeAccount(pAccountID: Integer): Boolean;
var
  aMsg: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CanChangeAccount'); 
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.CanChangeAccount';
  try
    Result := True;
    // 3/25/2014 gms d-04662 allow account change if account ID is not valid
    // 4/3/2014 gms d-04662 adding account ID parameter for caller to send in;
    //    used in editvaluechanged to use the entered account ID before assignment to field
    //    -1 value sent in when clicking ellipses button to do search before user assigned account.
    //04/30/2014 RRR D-04893 - Switched from ShowMessage to ErrorHandler

    if pAccountID > 0 then begin
      //04/30/2014 RRR D-04793
      //Added 3 new cases
      //Can not change account on Journaled Pledges, Pledge Payments and Split Donations
      //------------------------------------------------------------------------------------------------------------
      gPidiDDGlobal.ErrorHandler.Reset;
      if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Pledge_ID').AsInteger > 0 then begin
        if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Type').AsString = 'P' then begin
          Result := False;
          gPidiDDGlobal.ErrorHandler.Add('ERROR - This donation is a Journaled Pledge. You cannot Change the Account.', etValidation);
        end else begin
          Result := False;
          gPidiDDGlobal.ErrorHandler.Add('ERROR - This donation is a Pledge payment. You cannot Change the Account.', etValidation);
        end;
      end;

      if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Linked_Gift_ID').AsInteger > 0 then begin
        Result := False;
        gPidiDDGlobal.ErrorHandler.Add('ERROR - This donation is a Split. You cannot Change the Account.', etValidation);
      end;
      //------------------------------------------------------------------------------------------------------------

      if DmGiftProcessing.DmDonation.GiftProcIsValidAccountId(pAccountID, gpvaDonation) = True then begin
        if DmGiftProcessing.DmDonation.GiftProcHasChildRecords(aMsg) = True then begin
          Result := False;
          aMsg := 'ERROR: This Record has Related Child Records. You cannot Change the Account.' + #10#13#10#13 + aMsg;
          gPidiDDGlobal.ErrorHandler.Add(aMsg, etValidation);
        end;
      end;

      gPidiDDGlobal.ErrorHandler.HandleErrors;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.CanChangeAccount');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.CanChangeAccount';
  end;
end;


procedure TfrmBatchGiftProcessing.grdMainTableViewEvent_GuestNamePropertiesButtonClick(
  Sender: TObject; AButtonIndex: Integer);
// 3/11/2010 dd-3073 ccfa only (5.8.4) get event purchaser/guest name for donation
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewEvent_GuestNamePropertiesButtonClick');
  try
    inherited;
    DoGetEventTicketPurchaserGuest();
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewEvent_GuestNamePropertiesButtonClick');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewEvent_NamePropertiesButtonClick(Sender: TObject;
  AButtonIndex: Integer);
// 3/11/2010 dd-3073 ccfa only (5.8.4) get event for donation
var
  aSaveEventName: string;
  aEventSearchFrm: TfrmEventSearchClient;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewEvent_NamePropertiesButtonClick');
  try
    inherited;
    aEventSearchFrm := nil;
    try
      aEventSearchFrm := TfrmEventSearchClient.Create(Self, nil, False);
      // clear any previous selection
      aSaveEventName := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('EVENT_Name').AsString;
      aEventSearchFrm.SearchForEvent();

        if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin // D-04825 TWM 2014.05.20
          DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
        end;

        if (aEventSearchFrm.EventID < 0) and IsEmptyStr(aSaveEventName) then begin
        // EventID<0 means user Exited without selecting event, only clear info if no event
        //   previously posted
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('EVENT_ID').Clear;
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('EVENT_Name').Clear;
        end else if (aEventSearchFrm.EventID > 0) then begin  // user selected new event
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('EVENT_ID').AsInteger := aEventSearchFrm.EventID;
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('EVENT_Name').AsString := aEventSearchFrm.EventName;
        end;
    finally
      aEventSearchFrm.Free;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewEvent_NamePropertiesButtonClick');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewEvent_PurchaserNamePropertiesButtonClick(
  Sender: TObject; AButtonIndex: Integer);
// 3/11/2010 dd-3073 ccfa only (5.8.4) get event purchaser/guest name for donation
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewEvent_PurchaserNamePropertiesButtonClick');
  try
    inherited;
    DoGetEventTicketPurchaserGuest();
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewEvent_PurchaserNamePropertiesButtonClick');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewMatchingStatusDescPropertiesCloseUp(Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewMatchingStatusDescPropertiesCloseUp');
  try
    inherited;
    // 7/8/2014 gms b-05704 adding showtab here in OnCloseUp for use case of user typing
    //   value instead of using mouse to select.  Typing first letter and enter does not call
    //   StandardGridColumnOnChange when the value is ultimately selected.
    //   But only call ShowTab if splitter not already opened by previous call to ShowTab
    StdLookUpCloseUpFilterOff(Sender);
    if (IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Matching_Status')) = False) and
       ((splMain.State = ssClosed)) then begin
      ShowTab;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewMatchingStatusDescPropertiesCloseUp');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewMatchingStatusDescPropertiesPopup(
  Sender: TObject);
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewMcdPropertiesButtonClick');
  try
    inherited;
    PageControlInfo.DmGiftProcessing.DmDonation.DmDonationCodes.cdsMatchingStatus.Filter :=
       '(Code = ''1'') or (Code = ''3'')';
    PageControlInfo.DmGiftProcessing.DmDonation.DmDonationCodes.cdsMatchingStatus.Filtered := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewMcdPropertiesButtonClick');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewMcdPropertiesButtonClick(
  Sender: TObject; AButtonIndex: Integer);
var
  aNewForm: TfrmMailCodePickList;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewMcdPropertiesButtonClick');
  try
    inherited;

    // No pick if editing.
    if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsEdit, dsInsert]) then begin
      aNewForm := nil;
      try
        // 4/21/2014 gms d-04754 only need create and showmodal; create now sends in program (here null string);
        //  last parameter specifies this form can not pick an inactive code
        aNewForm := TfrmMailCodePickList.Create(Self, DmGiftProcessing.DmDonation.DmDonationCodes, '', False);
        // if (aNewForm.ShowPickList() = mrOk) then begin
        if (aNewForm.ShowModal() = mrOk) then begin
          if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
          end;

          if DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsString <> aNewForm.ProgramCode then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsString := aNewForm.ProgramCode;   //was firing change event even when equal
          end;

          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Mcd').AsString := aNewForm.MailCode;
          // 6/19/2014 gms b-05611 not needed; called in below procedure
          // ThreadedMoveToNextField;
        end;
      finally
        aNewForm.Free;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewMcdPropertiesButtonClick');
  end;
end;

procedure TfrmBatchGiftProcessing.grdMainTableViewMcdPropertiesEditValueChanged(
  Sender: TObject);
var
  aMCDText: string;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewMcdPropertiesEditValueChanged');
  try
    inherited;
    if (DmGiftProcessing <> nil) then begin
      if (DmGiftProcessing.DmDonation.cdsGiftProcessing.IsEmpty = False) then begin
        // MailCode Changed
        // If we are in the mailcode field and prg is empty, fill in last prg.
        if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State = dsInsert) and
           (grdMainTableView.GetColumnByFieldName('Mcd').Focused = True) and
           (IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg'))) and
           (not IsEmptyStr(DmGiftProcessing.DmDonation.GiftProcOrigPrg)) then begin
          DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Prg').AsString :=
             DmGiftProcessing.DmDonation.GiftProcOrigPrg;
        end;
        // MailCode Changed
        // If in the mailcode field and it changed, post the data to the underlying column.
        (*if (DmGiftProcessing.DmDonation.cdsGiftProcessing.State <> dsBrowse) and   // D-04825 TWM 2014.05.20
           (grdMainTableView.GetColumnByFieldName('Mcd').Focused = True) then begin*)

        if (grdMainTableView.GetColumnByFieldName('Mcd').Focused = True) then begin  
          if not(DmGiftProcessing.DmDonation.cdsGiftProcessing.State in [dsInsert, dsEdit]) then begin // D-04825 TWM 2014.05.20
            DmGiftProcessing.DmDonation.cdsGiftProcessing.Edit;
          end;

          // 7/2/2014 gms d-04952 adding code to get control text so that we don't need
          //   override in ACLU which otherwise had the same code
          if gPidiDDGlobal.ClientAcronym = 'ACLU' then begin
            aMCDText := (Sender as TcxLookupComboBox).Text;
          end else begin
            aMCDText := (Sender as TcxButtonEdit).Text;
          end;
          // The control does not automatically flush like other controls' "ImmediatePost".
          // This line of code corrects for this problem.
          if (not IsEmptyStr(aMCDText)) then begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Mcd').AsString :=
               aMCDText;
          end else begin
            DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Mcd').Clear;
          end;
          MailCodeClientEditValueChanged;
          // 6/19/2014 gms b-05611 no longer using threading to move to a different field
          // ThreadedMoveToNextField;
          // 7/2/2014 gms d-04952 not needed; proc always called when moving to another field
          // MoveToNextField;
        end;
      end;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewMcdPropertiesEditValueChanged');
  end;
end;

procedure TfrmBatchGiftProcessing.MailCodeClientEditValueChanged;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.MailCodeClientEditValueChanged');
  try
    // used for special client processing after the mail code's value changes; for now only ATC
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.MailCodeClientEditValueChanged');
  end;
end;


// Solicitor List
procedure TfrmBatchGiftProcessing.grdMainTableViewSolicitorListPropertiesButtonClick(
  Sender: TObject; AButtonIndex: Integer);
begin
  inherited;
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewSolicitorListPropertiesButtonClick');
  try
    inherited;
    if (DmGiftProcessing.DataModuleMode = dmmAdjBatch) then begin
      ShowMessage('You cannot change the solicitors when adjusting the donation. '+
         'You can change the solicitors by editing the donation.  If this is a pledge '+
         'donation, you can also change the solicitors on the pledge tab');
    end else begin
      ShowSolicitor();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.grdMainTableViewSolicitorListPropertiesButtonClick');
  end;
end;

//*****************************************************************************
// END: GRID COLUMN METHODS
//*****************************************************************************

//*****************************************************************************
//     TAB CONTROL SECTION
//*****************************************************************************
// Use this method for showing tabs based on field changes.
// This is for showing tabs, NOT adding combos, setting field data, etc.
procedure TfrmBatchGiftProcessing.ShowTab(pForceShowTab: TcxGridDBColumn = nil);
var
  aAdjCode: string;
  aShowSplitGifts1, aShowSplitGifts2, aShowGroupDonations, aShowVehicles: Boolean;
  aTab: TRzTabSheet;
  aCursor: TCursor;
  aGridsHeight: Integer;
  aAccountIsValid: Boolean;
  aShowInvalidAcctMessage: Boolean;

//============================  Sub Procedures  ============================ //

  function EligibleColumn(pCol: TcxGridDBColumn): Boolean;
  var
    aFieldName: string;
  const
    aValidFieldList: string = 'MATCHING_STATUS;TYPE;PLG_METHOD;CATEGORY;SOFTCREDIT;SPLITGIFT2;PREMIUM_LIST;ORDER_IR;GROUPDONATIONS';
  begin
    SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowTab: EligibleColumn');
    try
      if pCol <> nil then begin
        aFieldName := UpperCase(pCol.DataBinding.FieldName);
        Result := (Pos(aFieldName, aValidFieldList) > 0);
      end;
    finally
      SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowTab: EligibleColumn');
    end;
  end;

//=========================== End Sub Procedures  =========================== //

begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowTab');
  gPidiBugReport.SIInfo := 'EnterMethod: TfrmBatchGiftProcessing.ShowTab';
  try
    inherited;
    aShowSplitGifts1 := False;
    aShowSplitGifts2 := False;
    aShowGroupDonations := False;
    aShowVehicles := False;
    aTab := nil;
    aCursor := Screen.Cursor;
    Screen.Cursor := crHourGlass;
    try
      // If doing something then don't show tabs
      if FWorkInProgress = True then begin
        Exit;
      end;

      // Make sure the business column is selected
      if DmGiftProcessing = nil then begin
        Exit;
      end;

      // Do not show tab if no records
      if (DmGiftProcessing.DmDonation.cdsGiftProcessing.IsEmpty = True) then begin
        Exit;
      end;

      // Do not show tab if disabled
      if grdMain.Enabled = False then begin
        Exit;
      end;

      // Do not show tab if no column is selected
      if (HasFocusedColumn(grdMainTableView) = False) and (pForceShowTab = nil) then begin
        aAdjCode := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_Code').AsString;
        // If the user clicks to an adjusted row, close the splitter if open.
        if (PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True) and
//      if (splMain.State <> ssClosed) and
           ((aAdjCode = 'A') or (aAdjCode = 'B') or (aAdjCode = 'E')) then begin
          // Close the splitter
          DoCloseSplitter();
          (* 3/20/2014 gms d-04568 code now in DoCloseSplitter
          splMain.CloseSplitter;
          splMain.Visible := False;
          if (grdMain.Showing) and (grdMain.CanFocus) then begin
            grdMain.SetFocus;
          end;
          *)
        end;
        Exit;
      end;

      // Don't run this method except for specific column
      // User has clicked a non-bottom-tab-related column
      // OR there are no focused columns and the user clicks
      // from the bottom to the top grid.
      if (((EligibleColumn(GetFocusedColumn(grdMainTableView)) = False) or
         (HasFocusedColumn(grdMainTableView) = False))) and
         (pForceShowTab = nil) then begin
        if PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin
//      if (splMain.State <> ssClosed) then begin
          // Update the checked columns.
          // 5/21/2014 gms d-04823 Moved SetCheckColumns after DoCloseSpliter; closing splitter
          //   can post or cancel lower dataset; SetCheckColumns operates when lower dataset in
          //   browse mode; so call DoCloseSplitter so that lower tabs can post or cancel
          DoCloseSplitter();
          SetCheckedColumns(False);
          (* 3/20/2104 gms d-04568 code now in DoCloseSplitter
          // Close the splitter
          splMain.CloseSplitter;
          splMain.Visible := False;
          if (grdMain.Showing) and (grdMain.CanFocus) then begin
            grdMain.SetFocus;
          end;
          *)
        end;
        // Leave now
        Exit;
      end;

      // FFocusedGridTableItem := nil;
      // Determine the correct tab to switch to.
      if IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID')) then begin
        // Do not show tab based on whether there is a selected/populated account
        aTab := nil;
      end else if ((grdMainTableView.GetColumnByFieldName('Type').Focused = True) or
         (pForceShowTab = grdMainTableViewDonType)) then begin
        aTab := nil;
        FFocusedGridTableItem := grdMainTableViewDonType;
        if (gPidiEPSubSys.IsThirdPartyCCMode) and (DmGiftProcessing.DmDonation.CreditCardBatch = True) then begin
          aTab := TabCreditCardInfo;
        end else if (gPidiEPSubSys.IsThirdPartyEFTMode) and (DmGiftProcessing.DmDonation.EFTBatch = True) then begin
          aTab := TabEftInfo;
        // 6/5/2014 gms d-04897 only show CC or EFT panels if processing mode <> None
        end else if (DmGiftProcessing.DmDonation.GiftProcIsCreditCardType(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('TYPE')) = True) and
           (gPidiEPSubSys.CreditCardProcessingMode <> 'None') then begin
          aTab := TabCreditCardInfo;
        end else if (DmGiftProcessing.DmDonation.GiftProcIsEFTType(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('TYPE')) = True) and
           (gPidiEPSubSys.EFTProcessingMode <> 'None') then begin
          aTab := TabEftInfo;
        // 4/26/2013 gms added test for vehicle config point active; there are 2 clients (irc and smile)
        //   that have donation type V that is not Vehicle, so use the config point
        end else if (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('TYPE').AsString = 'V') and
           (GetConfigPointYesNoBoolean('VDM', 'Active') = True) and
           (IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Donated_Vehicle_ID'))) then begin
          aShowVehicles := True;
        end;
      end else if (grdMainTableViewPlgMethodDesc.Focused = True) or
         (pForceShowTab = grdMainTableViewPlgMethodDesc) then begin
        aTab := nil;
        FFocusedGridTableItem := grdMainTableViewPlgMethodDesc;
        if (DmGiftProcessing.DmDonation.CreditCardBatch = True) then begin
          aTab := TabCreditCardInfo;
        end else if (DmGiftProcessing.DmDonation.EFTBatch = True) then begin
          aTab := TabEftInfo;
        // 6/5/2014 gms d-04897 only show CC or EFT panels if processing mode <> None
        end else if (DmGiftProcessing.DmDonation.GiftProcIsCreditCardType(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('TYPE')) = True) and
           (gPidiEPSubSys.CreditCardProcessingMode <> 'None') then begin
          aTab := TabCreditCardInfo;
        end else if (DmGiftProcessing.DmDonation.GiftProcIsEFTType(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('TYPE')) = True) and
           (gPidiEPSubSys.EFTProcessingMode <> 'None') then begin
          aTab := TabEftInfo;
        end;
      end else if (grdMainTableView.GetColumnByFieldName('Category').Focused = True) or
         (pForceShowTab = grdMainTableViewCategoryDesc) then begin
        aTab := nil;
        FFocusedGridTableItem := grdMainTableViewCategoryDesc;
        if (IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category')) = False) then begin
          if (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').AsString = 'I') then begin
            aTab := TabImoIho;
          end else if (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').AsString = 'H') then begin
            aTab := TabImoIho;
          end else if (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').AsString = 'M') then begin
            aTab := TabMatchingGift;
          end else if (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Category').AsString = 'G') then begin
            aTab := TabGiftMembership;
          end;
        end;
      end else if ((grdMainTableView.GetColumnByFieldName('Matching_Status').Focused = True) or
         (pForceShowTab = grdMainTableViewMatchingStatusDesc)) and
         ((DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Matching_Status').AsString = '1') or
         (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Matching_Status').AsString = '4')) then begin
        FFocusedGridTableItem := grdMainTableViewMatchingStatusDesc;
        aTab := TabMatchingGift;
      end else if ((grdMainTableView.GetColumnByFieldName('SoftCredit').Focused = True) or
         (pForceShowTab = grdMainTableViewSoftCredit)) and
         (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SoftCredit').AsBoolean = True) then begin
        FFocusedGridTableItem := grdMainTableViewSoftCredit;
        aTab := TabSoftCredit;
      end else if ((grdMainTableView.GetColumnByFieldName('SplitGift2').Focused = True) or
         (pForceShowTab = grdMainTableViewSplitGift2)) and
         (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift2').AsBoolean = True) then begin
        aAdjCode := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_Code').AsString;
        if (aAdjCode = 'N') or (aAdjCode = 'D') or (IsEmptyStr(aAdjCode) = True) then begin
          // Show the form for now. Go back and convert tab later.
          aTab := nil;//TabSplitDonations;
          aShowSplitGifts2 := True;
          FFocusedGridTableItem := grdMainTableViewSplitGift2;
        end else begin
          // Can't split gift on adjustments.
          aTab := nil;
        end;
      end else if ((grdMainTableView.GetColumnByFieldName('SplitGift').Focused = True) or
         (pForceShowTab = grdMainTableViewSplitGift)) and
         (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('SplitGift').AsBoolean = True) then begin
        aAdjCode := DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Adj_Code').AsString;
        if (aAdjCode = 'N') or (aAdjCode = 'D') or (IsEmptyStr(aAdjCode) = True) then begin
          // Show the form for now. Go back and convert tab later.
          aTab := nil;//TabSplitGifts;
          aShowSplitGifts1 := True;
          FFocusedGridTableItem := grdMainTableViewSplitGift;
        end else begin
          // Can't split gift on adjustments.
          aTab := nil;
        end;
      end else if (grdMainTableView.GetColumnByFieldName('Premium_List').Focused = True) or
         ((pForceShowTab = grdMainTableViewPremium_List) and
            (IsEmptyField(DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Premium_List')) = False)) then begin
        FFocusedGridTableItem := grdMainTableViewPremium_List;
        aTab := TabPremiums;
      end else if ((grdMainTableView.GetColumnByFieldName('order_ir').Focused = True) or
         (pForceShowTab = grdMainTableViewOrderIr)) and
         (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('order_ir').AsBoolean = True) then begin
        FFocusedGridTableItem := grdMainTableViewOrderIr;
        aTab := TabIROrders;
      end else if ((grdMainTableView.GetColumnByFieldName('GroupDonations').Focused = True)  or
         (pForceShowTab = grdMainTableViewGroupDonations)) and
         (DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('GroupDonations').AsBoolean = True) then begin
        // Show the form for now. Go back and convert tab later.
        aTab := nil;//TabSplitGroups;
        FFocusedGridTableItem := grdMainTableViewGroupDonations;
        aShowGroupDonations := True;
      end;

      // 4/2/2014 gms d-04662 check validity of account before opening lower grids or
      //   popup dialogs.  Invalid account might have slipped through to other columns
      //   We don't want to allow entry into lower grids unless we have a valid account.
      aAccountIsValid := DmGiftProcessing.DmDonation.GiftProcIsValidAccountId(
         DmGiftProcessing.DmDonation.cdsGiftProcessing.FieldByName('Account_ID').AsInteger, gpvaDonation);
      // 5/21/2014 gms d-04823 if entered here with splitter open, close the splitter
      //   and remain on the donation grid.
      if (PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True) and (pgcMain.ActivePage = aTab) then begin
//    if (splMain.State <> ssClosed) and (pgcMain.ActivePage = aTab) then begin
        // Update the checked columns.
        // 5/21/2014 gms d-04823 Moved SetCheckColumns after DoCloseSpliter; closing splitter
        //   can post or cancel lower dataset; SetCheckColumns operates when lower dataset in
        //   browse mode; so call DoCloseSplitter so that lower tabs can post or cancel
        DoCloseSplitter();
        SetCheckedColumns(False);
        Exit;
      end;
      // Now show it.
      if ((aTab <> nil) and (splMain.State = ssClosed)) or
         ((aTab <> nil) and (pgcMain.ActivePage <> aTab)) or
         ((aTab <> nil) and (FRefreshTabs)) then begin
        if aAccountIsValid = False then begin
          gPidiDDGlobal.ErrorHandler.Reset;
          gPidiDDGlobal.ErrorHandler.Add('Please enter a valid Account ID', etValidation);
          gPidiDDGlobal.ErrorHandler.HandleErrors;
        end else begin
          if (PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True) and (pgcMain.ActivePage = aTab) then begin
//        if (splMain.State <> ssClosed) and (pgcMain.ActivePage = aTab) then begin
            // Update the checked columns.
            // 5/21/2014 gms d-04823 Moved SetCheckColumns after DoCloseSpliter; closing splitter
            //   can post or cancel lower dataset; SetCheckColumns operates when lower dataset in
            //   browse mode; so call DoCloseSplitter so that lower tabs can post or cancel
            // if PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin
  //        if splMain.State <> ssClosed then begin
            DoCloseSplitter();
            // end;

            SetCheckedColumns(False);
          end;
          FRefreshTabs := False; // Only refresh once
          pgcMain.ActivePage := aTab;
          splMain.Visible := True;

          // 12/3/2013 gms d-04501 calculate the actual height of the area contained by the
          //   two grids and the splitter by the form height less the top panels and bottom status panel
          aGridsHeight := Self.Height - pnlSearch.Height - pnlOptions.Height - pnlStatus.Height;
          // Setting AutoPosition to False allows us the set the position of the splitter
          //  and thus the size of the bottom panel
          splMain.AutoPosition := False;
          // Set the Position of the splitter and thus the bottom panel height to half of the
          //  height of the grid area calculated above.
          splMain.PositionAfterOpen := aGridsHeight div 2;

          splMain.OpenSplitter; // Needs to be here
          // Initializes the UI, refreshes data, etc
          pgcMainChange(nil); // Needs to be here
        end;
      end else if (aTab = nil) then begin
        // Close the splitter
        if PageControlInfo.DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen = True then begin
//      if splMain.State <> ssClosed then begin
          DoCloseSplitter();
        end;

        (* 3/20/2104 gms d-04568 code now in DoCloseSplitter
        splMain.CloseSplitter;
        splMain.Visible := False;

        if (grdMain.Showing) and (grdMain.CanFocus) and (not grdMain.IsFocused) then begin
          grdMain.SetFocus;
        end;
        *)

        // 4/2/2014 gms d-04662 not all instances of tab=nil will show a popup dialog
        //    test validity of account within the places where we will show a popup
        //    show the popup if valid; set show boolean if not; at end will show
        //    invalid acct message if acct not valid and show message true
        aShowInvalidAcctMessage := False;
        // This technique is smoother from UI perspective.
        if (aShowSplitGifts1 = True) then begin
          if aAccountIsValid = True then begin
            ShowSplitGifts();
          end else begin
            aShowInvalidAcctMessage := True;
          end;
        end else if (aShowSplitGifts2 = True) then begin
          if aAccountIsValid = True then begin
            // 12/30/2014 gms d-05250 removed parameter; was not used
            ShowSplitDonation;
          end else begin
            aShowInvalidAcctMessage := True;
          end;
        end else if (aShowGroupDonations = True) then begin
          if aAccountIsValid = True then begin
            ShowSplitGroups;
          end else begin
            aShowInvalidAcctMessage := True;
          end;
        end else if (aShowVehicles = True) then begin
          if aAccountIsValid = True then begin
            ShowVehicles;
          end else begin
            aShowInvalidAcctMessage := True;
          end;
        end;
        if (aAccountIsValid = False) and (aShowInvalidAcctMessage = True) then begin
          gPidiDDGlobal.ErrorHandler.Reset;
          gPidiDDGlobal.ErrorHandler.Add('Please enter a valid Account ID', etValidation);
          gPidiDDGlobal.ErrorHandler.HandleErrors;
        end;
      end;
    finally
      pgcMain.Refresh;
      Screen.Cursor := aCursor;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.ShowTab');
    gPidiBugReport.SIInfo := 'LeaveMethod: TfrmBatchGiftProcessing.ShowTab';
  end;
end;

//*****************************************************************************
//     pcMain Change method. Controls creation of tab forms.
//*****************************************************************************
procedure TfrmBatchGiftProcessing.pgcMainChange(Sender: TObject);
var
  aCursor: TCursor;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.pgcMainChange');
  try
    inherited;
    aCursor := Screen.Cursor;
    Screen.Cursor := crHourGlass;
    try
      if (not pgcMain.Enabled) then begin
        Exit;
      end;
      DmGiftProcessing.DmDonation.GiftProcLowerGridIsOpen := True;
      if (pgcMain.ActivePage = TabImoIho) then begin
        InitializeTabImoIho;
      end else if (pgcMain.ActivePage = TabMatchingGift) then begin
        InitializeTabMatchingGift;
      end else if (pgcMain.ActivePage = TabGiftMembership) then begin
        InitializeTabGiftMembership;
      end else if (pgcMain.ActivePage = TabPremiums) then begin
        InitializeTabPremiums;
      end else if (pgcMain.ActivePage = TabSoftCredit) then begin
        InitializeTabSoftCredit;
      end else if (pgcMain.ActivePage = TabCreditCardInfo) then begin
        InitializeTabCreditCardInfo;
      end else if (pgcMain.ActivePage = TabEFTInfo) then begin
        InitializeTabEFTInfo;
      end else if (pgcMain.ActivePage = TabIROrders) then begin
        InitializeTabIROrders;
      end;
    finally
      pgcMain.Refresh;
      Screen.Cursor := aCursor;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.pgcMainChange');
  end;
end;

//*****************************************************************************
// begin: Tab Initialization Methods
//*****************************************************************************

//*****************************************************************************
//     Imo/Iho Tab
//*****************************************************************************
procedure TfrmBatchGiftProcessing.InitializeTabImoIho;
var
  aCursor: TCursor;
  aTabSheetFrm: TfrmTabSheet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabImoIho');
  try
    if (not PageControlInfo.TabIsCreated(TabImoIho)) then begin
      aCursor := Screen.Cursor;
      Screen.Cursor := crHourGlass;
      try
        // Create the form.
        // This will Create the form, add a new TabSheetInto to
        // the PageControlInfo, and dock it on the tab.
        TfrmTabGPImoIhoClient.Create(Self, PageControlInfo, TabImoIho);
      finally
        Screen.Cursor := aCursor;
      end;
    end;
    aTabSheetFrm := TfrmTabSheet(PageControlInfo.GetFormForTab(TabImoIho));
    if (aTabSheetFrm <> nil) then begin
      aTabSheetFrm.InitializeUI();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabImoIho');
  end;
end;

//*****************************************************************************
//     Matching Gift Tab
//*****************************************************************************
procedure TfrmBatchGiftProcessing.InitializeTabMatchingGift;
var
  aCursor: TCursor;
  aTabSheetFrm: TfrmTabSheet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabMatchingGift');
  try
    if (not PageControlInfo.TabIsCreated(TabMatchingGift)) then begin
      aCursor := Screen.Cursor;
      Screen.Cursor := crHourGlass;
      try
        // Create the form.
        // This will Create the form, add a new TabSheetInto to
        // the PageControlInfo, and dock it on the tab.
        TfrmTabGPMatchingGiftClient.Create(Self, PageControlInfo, TabMatchingGift);
      finally
        Screen.Cursor := aCursor;
      end;
    end;
    aTabSheetFrm := TfrmTabSheet(PageControlInfo.GetFormForTab(TabMatchingGift));
    if (aTabSheetFrm <> nil) then begin
      aTabSheetFrm.InitializeUI();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabMatchingGift');
  end;
end;

//*****************************************************************************
//     Gift Membership Tab
//*****************************************************************************
procedure TfrmBatchGiftProcessing.InitializeTabGiftMembership;
var
  aCursor: TCursor;
  aTabSheetFrm: TfrmTabSheet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabGiftMembership');
  try
    if (not PageControlInfo.TabIsCreated(TabGiftMembership)) then begin
      aCursor := Screen.Cursor;
      Screen.Cursor := crHourGlass;
      try
        // Create the form.
        // This will Create the form, add a new TabSheetInto to
        // the PageControlInfo, and dock it on the tab.
        TfrmTabGPGiftMembershipClient.Create(Self, PageControlInfo, TabGiftMembership);
      finally
        Screen.Cursor := aCursor;
      end;
    end;
    aTabSheetFrm := TfrmTabSheet(PageControlInfo.GetFormForTab(TabGiftMembership));
    if (aTabSheetFrm <> nil) then begin
      aTabSheetFrm.InitializeUI();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabGiftMembership');
  end;
end;

//*****************************************************************************
//     Premiums Tab
//*****************************************************************************
procedure TfrmBatchGiftProcessing.InitializeTabPremiums;
var
  aCursor: TCursor;
  aTabSheetFrm: TfrmTabSheet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabPremiums');
  try
    if (not PageControlInfo.TabIsCreated(TabPremiums)) then begin
      aCursor := Screen.Cursor;
      Screen.Cursor := crHourGlass;
      try
        // Create the form.
        // This will Create the form, add a new TabSheetInto to
        // the PageControlInfo, and dock it on the tab.
        TfrmTabGPPremiumClient.Create(Self, PageControlInfo, TabPremiums);
      finally
        Screen.Cursor := aCursor;
      end;
    end;
    aTabSheetFrm := TfrmTabSheet(PageControlInfo.GetFormForTab(TabPremiums));
    if (aTabSheetFrm <> nil) then begin
      aTabSheetFrm.InitializeUI();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabPremiums');
  end;
end;

//*****************************************************************************
//     Soft Credit Tab
//*****************************************************************************
procedure TfrmBatchGiftProcessing.InitializeTabSoftCredit;
var
  aCursor: TCursor;
  aTabSheetFrm: TfrmTabSheet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabSoftCredit');
  try
    if (not PageControlInfo.TabIsCreated(TabSoftCredit)) then begin
      aCursor := Screen.Cursor;
      Screen.Cursor := crHourGlass;
      try
        // Create the form.
        // This will Create the form, add a new TabSheetInto to
        // the PageControlInfo, and dock it on the tab.
        TfrmTabGPSoftCreditClient.Create(Self, PageControlInfo, TabSoftCredit);
      finally
        Screen.Cursor := aCursor;
      end;
    end;
    aTabSheetFrm := TfrmTabSheet(PageControlInfo.GetFormForTab(TabSoftCredit));
    if (aTabSheetFrm <> nil) then begin
      aTabSheetFrm.InitializeUI();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabSoftCredit');
  end;
end;

//*****************************************************************************
//     Credit Card Info Tab
//*****************************************************************************
procedure TfrmBatchGiftProcessing.InitializeTabCreditCardInfo;
var
  aCursor: TCursor;
  aCreditCardFrm: TfrmTabGPCreditCardClient;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabCreditCardInfo');
  try
    if (not PageControlInfo.TabIsCreated(TabCreditCardInfo)) then begin
      aCursor := Screen.Cursor;
      Screen.Cursor := crHourGlass;
      try
        // Create the form.
        // This will Create the form, add a new TabSheetInto to
        // the PageControlInfo, and dock it on the tab.
        TfrmTabGPCreditCardClient.Create(Self, PageControlInfo, TabCreditCardInfo);
      finally
        Screen.Cursor := aCursor;
      end;
    end;

    aCreditCardFrm := TfrmTabGPCreditCardClient(PageControlInfo.GetFormForTab(TabCreditCardInfo));
    if (aCreditCardFrm <> nil) then begin
      aCreditCardFrm.InitializeUI(FIsRO);
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabCreditCardInfo');
  end;
end;

//*****************************************************************************
//     EFT Info Tab
//*****************************************************************************
procedure TfrmBatchGiftProcessing.InitializeTabEFTInfo;
var
  aCursor: TCursor;
  aEFTForm: TfrmTabGPEFTClient;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabEFTInfo');
  try
    if (not PageControlInfo.TabIsCreated(TabEFTInfo)) then begin
      aCursor := Screen.Cursor;
      Screen.Cursor := crHourGlass;
      try
        // Create the form.
        // This will Create the form, add a new TabSheetInto to
        // the PageControlInfo, and dock it on the tab.
        TfrmTabGPEFTClient.Create(Self, PageControlInfo, TabEFTInfo);
      finally
        Screen.Cursor := aCursor;
      end;
    end;
    // 4/18/2014 gms b-05022 now using specific form type so that we can call
    //    overloaded InitializeUI with read only parameter; same as credit card above
    aEFTForm := TfrmTabGPEFTClient(PageControlInfo.GetFormForTab(TabEFTInfo));
    if (aEFTForm <> nil) then begin
      aEFTForm.InitializeUI(FIsRO);
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabEFTInfo');
  end;
end;

//*****************************************************************************
//     IR Orders Tab
//*****************************************************************************
procedure TfrmBatchGiftProcessing.InitializeTabIROrders;
var
  aCursor: TCursor;
  aTabSheetFrm: TfrmTabSheet;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabIROrders');
  try
    if (not PageControlInfo.TabIsCreated(TabIROrders)) then begin
      aCursor := Screen.Cursor;
      Screen.Cursor := crHourGlass;
      try
        // Create the form.
        // This will Create the form, add a new TabSheetInto to
        // the PageControlInfo, and dock it on the tab.
        TfrmTabGPIROrdersClient.Create(Self, PageControlInfo, TabIROrders);
      finally
        Screen.Cursor := aCursor;
      end;
    end;
    aTabSheetFrm := TfrmTabSheet(PageControlInfo.GetFormForTab(TabIROrders));
    if (aTabSheetFrm <> nil) then begin
      aTabSheetFrm.InitializeUI();
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.InitializeTabIROrders');
  end;
end;
//*****************************************************************************
// END: Tab Initialization Methods
//*****************************************************************************

//******************************************************************************
// begin: ADJUSTMENT SECTION
//******************************************************************************
function TfrmBatchGiftProcessing.AdjustThisDonation(pAdjustOrigDonationCds: TPidCdsProvider): Boolean;
var
  aCursor: TCursor;
  aBatchLogGiftProcessing: TfrmBatchLogGiftProcessingClient;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AdjustThisDonation');
  try
    Result := False;
    // aBatchLogGiftProcessing := nil; // will release itself
    aCursor := Screen.Cursor;
    Screen.Cursor := crHourGlass;
    try

      if (gPidiDDGlobal.MainFormStatusPane <> nil) then begin
        gPidiDDGlobal.MainFormStatusPane.Caption := 'Identiftying an adjustment batch ...';
      end;

      if FindAdjustmentBatches(pAdjustOrigDonationCds) then begin

        DmGiftProcessing.DmDonation.BatchLogMode := blmAdjustmentMode;
        aBatchLogGiftProcessing := TfrmBatchLogGiftProcessingClient.Create(Self,
           blmAdjustmentMode, pAdjustOrigDonationCds, DmGiftProcessing.DmDonation);
        if aBatchLogGiftProcessing.ShowModal = mrOK then begin
           // Set some class settings.
          DmGiftProcessing.DmDonation.AdjustOrigDonationCds :=  pAdjustOrigDonationCds;

//   DmGiftProcessing.DmDonation.AdjustComments := aBatchComments;  // We don't need this anymore, already set
//   We don't need these anymore, but don't want to delete yet.
          DmGiftProcessing.DmDonation.AdjustAccountID := pAdjustOrigDonationCds.FieldByName('Account_ID').AsInteger;
          DmGiftProcessing.DmDonation.AdjustDonationID := pAdjustOrigDonationCds.FieldByName('Donation_ID').AsInteger;

          // First provide the batch where the original donation is.  That way, existing
          // logic will bring down all related records for this donation.  Then we have to
          // simply reverse the amount to negative and change the batch and donation id's.
          EditDonation := True;
          EditDonationID := DmGiftProcessing.DmDonation.AdjustDonationID;
          FLinkedGiftID := pAdjustOrigDonationCds.FieldByName('Linked_Gift_ID').AsInteger;
          // Load it up
          gPidiDDGlobal.MainFormStatusPane.Caption := 'Loading Donation ...';
          LoadSingleDonation(DmGiftProcessing.DmDonation.AdjustBatchDate,DmGiftProcessing.DmDonation.AdjustBatchNo);
          pidiCoreDB.SetIndex(DmGiftProcessing.DmDonation.cdsGiftProcessing, 'Donation_ID;Adj_Code');

          Result := True;
        end;
      end;
    finally

      if (gPidiDDGlobal.MainFormStatusPane <> nil) then begin
        gPidiDDGlobal.MainFormStatusPane.Caption := StatusMsg;
      end;
      // aBatchLogGiftProcessing.Free; 3/27/2014 gms will release itself
      Screen.Cursor := aCursor;
    end;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.AdjustThisDonation');
  end;
end;

function TfrmBatchGiftProcessing.EditThisDonation(pAdjustOrigDonationCds: TPidCdsProvider): Boolean;
begin
  SiMain.EnterMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.EditThisDonation');
  try
    Result := False;
    DmGiftProcessing.DmDonation.AdjustAccountID := pAdjustOrigDonationCds.FieldByName('Account_ID').AsInteger;
    DmGiftProcessing.DmDonation.AdjustDonationID := pAdjustOrigDonationCds.FieldByName('Donation_ID').AsInteger;
    DmGiftProcessing.DmDonation.AdjustBatchNo := pAdjustOrigDonationCds.FieldByName('Batch').AsString;
    DmGiftProcessing.DmDonation.AdjustBatchDate := pAdjustOrigDonationCds.FieldByName('BDate').AsDateTime;
    // don't set AdjustAcctDate; not needed

    EditDonation := True;
    EditDonationID := DmGiftProcessing.DmDonation.AdjustDonationID;
    FLinkedGiftID := pAdjustOrigDonationCds.FieldByName('Linked_Gift_ID').AsInteger;  //RRR 01/29/2015 D-05281

    // Load it up
    gPidiDDGlobal.MainFormStatusPane.Caption := 'Loading Donation ...';
    LoadSingleDonation(DmGiftProcessing.DmDonation.AdjustBatchDate,
       DmGiftProcessing.DmDonation.AdjustBatchNo);
    gPidiDDGlobal.MainFormStatusPane.Caption := StatusMsg;
    pidiCoreDB.SetIndex(DmGiftProcessing.DmDonation.cdsGiftProcessing, 'Donation_ID;Adj_Code');
    Result := True;
  finally
    SiMain.LeaveMethod(lvMessage, Self, 'TfrmBatchGiftProcessing.EditThisDonation');
  end;
end;

//*****************************************************************************
// END: ADJUSTMENT SECTION
//*****************************************************************************

end.
